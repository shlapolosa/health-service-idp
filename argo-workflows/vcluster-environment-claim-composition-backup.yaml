apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: "{\"apiVersion\":\"apiextensions.crossplane.io/v1\",\"kind\":\"Composition\",\"metadata\":{\"annotations\":{},\"labels\":{\"crossplane.io/xrd\":\"xvclusterenvironmentclaims.platform.example.org\",\"provider\":\"helm-kubernetes\"},\"name\":\"vcluster-environment-claim-composition\"},\"spec\":{\"compositeTypeRef\":{\"apiVersion\":\"platform.example.org/v1alpha1\",\"kind\":\"XVClusterEnvironmentClaim\"},\"resources\":[{\"base\":{\"apiVersion\":\"kubernetes.crossplane.io/v1alpha1\",\"kind\":\"Object\",\"spec\":{\"forProvider\":{\"manifest\":{\"apiVersion\":\"v1\",\"kind\":\"Namespace\",\"metadata\":{\"labels\":{\"vcluster.loft.sh/namespace\":\"true\"},\"name\":\"placeholder\"}}},\"providerConfigRef\":{\"name\":\"default\"}}},\"name\":\"vcluster-namespace\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.name\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-namespace\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"helm.crossplane.io/v1beta1\",\"kind\":\"Release\",\"spec\":{\"forProvider\":{\"chart\":{\"name\":\"vcluster\",\"repository\":\"https://charts.loft.sh\",\"version\":\"0.15.0\"},\"namespace\":\"placeholder\",\"skipCreateNamespace\":true,\"values\":{\"controlPlane\":{\"statefulSet\":{\"resources\":{\"limits\":{\"cpu\":\"1000m\",\"memory\":\"2Gi\"},\"requests\":{\"cpu\":\"200m\",\"memory\":\"512Mi\"}}}},\"networking\":{\"advanced\":{\"proxyKubelets\":{\"byHostname\":false,\"byIP\":false}}},\"nodeSelector\":{\"eks.amazonaws.com/nodegroup\":\"socrateshlapolosa-karpenter-demo-ng-medium\"},\"rbac\":{\"clusterRole\":{\"create\":true}},\"service\":{\"type\":\"ClusterIP\"},\"sync\":{\"fromHost\":{\"csiDrivers\":{\"enabled\":false},\"csiStorageCapacities\":{\"enabled\":false},\"nodes\":{\"enabled\":true,\"selector\":{\"all\":true}}},\"toHost\":{\"persistentVolumes\":{\"enabled\":true},\"priorityClasses\":{\"enabled\":true},\"storageClasses\":{\"enabled\":true}}}}},\"providerConfigRef\":{\"name\":\"default\"}}},\"name\":\"vcluster-helm-release\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.namespace\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-vcluster\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.values.nameOverride\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.values.fullnameOverride\",\"transforms\":[{\"string\":{\"fmt\":\"%s-vcluster\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"status.atProvider.state\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"status.ready\",\"transforms\":[{\"map\":{\"deployed\":true,\"failed\":false},\"type\":\"map\"}],\"type\":\"ToCompositeFieldPath\"},{\"fromFieldPath\":\"spec.forProvider.namespace\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"status.clusterEndpoint.direct\",\"transforms\":[{\"string\":{\"fmt\":\"https://%s-vcluster.%s.svc.cluster.local:443\"},\"type\":\"string\"}],\"type\":\"ToCompositeFieldPath\"},{\"fromFieldPath\":\"metadata.name\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"status.adminCredentials.kubeconfig\",\"transforms\":[{\"string\":{\"fmt\":\"Secret:
      %s-vcluster-connection in crossplane-system namespace\"},\"type\":\"string\"}],\"type\":\"ToCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"helm.crossplane.io/v1beta1\",\"kind\":\"Release\",\"spec\":{\"forProvider\":{\"chart\":{\"name\":\"crossplane\",\"repository\":\"https://charts.crossplane.io/stable\",\"version\":\"1.14.0\"},\"namespace\":\"crossplane-system\",\"skipCreateNamespace\":false,\"values\":{\"args\":[\"--debug\",\"--enable-composition-revisions\",\"--enable-environment-configs\"],\"image\":{\"tag\":\"v1.14.0\"},\"metrics\":{\"enabled\":true},\"resourcesCrossplane\":{\"limits\":{\"cpu\":\"500m\",\"memory\":\"1Gi\"},\"requests\":{\"cpu\":\"200m\",\"memory\":\"512Mi\"}},\"webhooks\":{\"enabled\":true}}},\"providerConfigRef\":{\"name\":\"vcluster-provider\"}}},\"name\":\"vcluster-crossplane-install\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-crossplane\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"kubernetes.crossplane.io/v1alpha1\",\"kind\":\"Object\",\"spec\":{\"forProvider\":{\"manifest\":{\"apiVersion\":\"apiextensions.crossplane.io/v1\",\"kind\":\"CompositeResourceDefinition\",\"metadata\":{\"name\":\"xappcontainerclaims.platform.example.org\"},\"spec\":{\"claimNames\":{\"kind\":\"AppContainerClaim\",\"plural\":\"appcontainerclaims\"},\"group\":\"platform.example.org\",\"names\":{\"kind\":\"XAppContainerClaim\",\"plural\":\"xappcontainerclaims\"},\"versions\":[{\"name\":\"v1alpha1\",\"referenceable\":true,\"schema\":{\"openAPIV3Schema\":{\"properties\":{\"spec\":{\"description\":\"AppContainerClaim
      specification for creating application container infrastructure\",\"properties\":{\"description\":{\"default\":\"CLAUDE.md-compliant
      application container\",\"description\":\"Description of the application container\",\"type\":\"string\"},\"dockerRegistry\":{\"default\":\"docker.io/socrates12345\",\"description\":\"Docker
      registry for container images\",\"type\":\"string\"},\"enableObservability\":{\"default\":true,\"description\":\"Whether
      to enable observability stack (Prometheus, Grafana, Jaeger)\",\"type\":\"boolean\"},\"enableSecurity\":{\"default\":true,\"description\":\"Whether
      to enable security scanning and policies\",\"type\":\"boolean\"},\"gitHubOrg\":{\"default\":\"shlapolosa\",\"description\":\"GitHub
      organization where repositories will be created\",\"type\":\"string\"},\"name\":{\"description\":\"Name
      of the application container (must be DNS-1123 compliant)\",\"maxLength\":63,\"pattern\":\"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$\",\"type\":\"string\"}},\"required\":[\"name\"],\"type\":\"object\"},\"status\":{\"description\":\"AppContainerClaim
      status\",\"properties\":{\"gitopsRepository\":{\"description\":\"GitOps repository
      information\",\"properties\":{\"branch\":{\"description\":\"Default branch name\",\"type\":\"string\"},\"cloneUrl\":{\"description\":\"Git
      clone URL\",\"type\":\"string\"},\"url\":{\"description\":\"GitOps repository
      URL\",\"type\":\"string\"}},\"type\":\"object\"},\"ready\":{\"description\":\"Indicates
      whether the app container is ready\",\"type\":\"boolean\"},\"sourceRepository\":{\"description\":\"Source
      repository information\",\"properties\":{\"branch\":{\"description\":\"Default
      branch name\",\"type\":\"string\"},\"cloneUrl\":{\"description\":\"Git clone
      URL\",\"type\":\"string\"},\"url\":{\"description\":\"Source repository URL\",\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"}},\"type\":\"object\"}},\"served\":true}]}}},\"providerConfigRef\":{\"name\":\"vcluster-provider\"}}},\"name\":\"vcluster-app-container-claim-xrd\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-app-container-xrd\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"kubernetes.crossplane.io/v1alpha1\",\"kind\":\"Object\",\"spec\":{\"forProvider\":{\"manifest\":{\"apiVersion\":\"apiextensions.crossplane.io/v1\",\"kind\":\"CompositeResourceDefinition\",\"metadata\":{\"name\":\"xapplicationclaims.platform.example.org\"},\"spec\":{\"claimNames\":{\"kind\":\"ApplicationClaim\",\"plural\":\"applicationclaims\"},\"group\":\"platform.example.org\",\"names\":{\"kind\":\"XApplicationClaim\",\"plural\":\"xapplicationclaims\"},\"versions\":[{\"name\":\"v1alpha1\",\"referenceable\":true,\"schema\":{\"openAPIV3Schema\":{\"properties\":{\"spec\":{\"description\":\"ApplicationClaim
      specification\",\"properties\":{\"appContainer\":{\"default\":\"health-service-idp\",\"description\":\"Name
      of the AppContainer this microservice belongs to\",\"maxLength\":63,\"pattern\":\"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$\",\"type\":\"string\"},\"cache\":{\"default\":\"none\",\"description\":\"Cache
      type to provision for the application\",\"enum\":[\"redis\",\"none\"],\"type\":\"string\"},\"database\":{\"default\":\"none\",\"description\":\"Database
      type to provision for the application\",\"enum\":[\"postgres\",\"none\"],\"type\":\"string\"},\"exposeApi\":{\"default\":false,\"description\":\"Whether
      to expose the API via AWS API Gateway\",\"type\":\"boolean\"},\"framework\":{\"description\":\"Application
      framework to use\",\"enum\":[\"fastapi\",\"springboot\"],\"type\":\"string\"},\"hasFrontend\":{\"default\":false,\"description\":\"Whether
      the application includes a frontend component\",\"type\":\"boolean\"},\"language\":{\"description\":\"Programming
      language for the application\",\"enum\":[\"python\",\"java\"],\"type\":\"string\"},\"name\":{\"description\":\"Name
      of the microservice (must be DNS-1123 compliant)\",\"maxLength\":63,\"pattern\":\"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$\",\"type\":\"string\"}},\"required\":[\"name\",\"language\",\"framework\"],\"type\":\"object\"},\"status\":{\"description\":\"ApplicationClaim
      status\",\"properties\":{\"application\":{\"description\":\"Deployed application
      information\",\"properties\":{\"apiGatewayEndpoint\":{\"description\":\"AWS
      API Gateway endpoint if exposeApi is true\",\"type\":\"string\"},\"endpoint\":{\"description\":\"Application
      endpoint URL\",\"type\":\"string\"},\"knativeService\":{\"description\":\"Knative
      service name\",\"type\":\"string\"}},\"type\":\"object\"},\"ready\":{\"description\":\"Indicates
      whether the application is ready and deployed\",\"type\":\"boolean\"},\"repository\":{\"description\":\"GitHub
      repository information\",\"properties\":{\"branch\":{\"description\":\"Default
      branch name\",\"type\":\"string\"},\"cloneUrl\":{\"description\":\"Git clone
      URL\",\"type\":\"string\"},\"url\":{\"description\":\"GitHub repository URL\",\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"}},\"type\":\"object\"}},\"served\":true}]}}},\"providerConfigRef\":{\"name\":\"vcluster-provider\"}}},\"name\":\"vcluster-application-claim-xrd\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-app-claim-xrd\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"kubernetes.crossplane.io/v1alpha1\",\"kind\":\"Object\",\"spec\":{\"forProvider\":{\"manifest\":{\"apiVersion\":\"batch/v1\",\"kind\":\"Job\",\"metadata\":{\"name\":\"placeholder\",\"namespace\":\"crossplane-system\"},\"spec\":{\"template\":{\"spec\":{\"containers\":[{\"command\":[\"/bin/sh\",\"-c\",\"set
      -e\\necho \\\"Installing Crossplane Compositions in vCluster...\\\"\\n\\n# Note:
      In a production environment, these compositions would be\\n# stored in a Git
      repository and applied via GitOps.\\n# For now, we're embedding them directly
      in the installer.\\n\\necho \\\"âœ… AppContainerClaim and ApplicationClaim Compositions
      would be installed here\\\"\\necho \\\"\U0001F4CB TODO: Copy full compositions
      from host cluster or Git repository\\\"\\necho \\\"\U0001F527 For now, vCluster
      will use the XRDs for API definitions\\\"\\necho \\\"\U0001F680 Users can apply
      compositions manually or via GitOps after vCluster creation\\\"\\n\"],\"image\":\"bitnami/kubectl:latest\",\"name\":\"composition-installer\"}],\"nodeSelector\":{\"eks.amazonaws.com/nodegroup\":\"socrateshlapolosa-karpenter-demo-ng-medium\"},\"restartPolicy\":\"OnFailure\",\"serviceAccountName\":\"crossplane-installer\"}}}}},\"providerConfigRef\":{\"name\":\"kubernetes-provider\"}}},\"name\":\"vcluster-composition-installer\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-composition-installer\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-composition-installer\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"kubernetes.crossplane.io/v1alpha1\",\"kind\":\"Object\",\"spec\":{\"forProvider\":{\"manifest\":{\"apiVersion\":\"batch/v1\",\"kind\":\"Job\",\"metadata\":{\"name\":\"placeholder\",\"namespace\":\"crossplane-system\"},\"spec\":{\"template\":{\"spec\":{\"containers\":[{\"command\":[\"/bin/sh\",\"-c\",\"set
      -e\\necho \\\"Installing Crossplane Providers in vCluster...\\\"\\n\\n# Install
      GitHub Provider\\nkubectl apply -f - \\u003c\\u003cEOF\\napiVersion: pkg.crossplane.io/v1\\nkind:
      Provider\\nmetadata:\\n  name: provider-github\\nspec:\\n  package: xpkg.upbound.io/crossplane-contrib/provider-github:v0.7.0\\n---\\napiVersion:
      pkg.crossplane.io/v1\\nkind: Provider\\nmetadata:\\n  name: provider-kubernetes\\nspec:\\n
      \ package: xpkg.upbound.io/crossplane-contrib/provider-kubernetes:v0.10.0\\n---\\napiVersion:
      pkg.crossplane.io/v1\\nkind: Provider\\nmetadata:\\n  name: provider-helm\\nspec:\\n
      \ package: xpkg.upbound.io/crossplane-contrib/provider-helm:v0.16.0\\nEOF\\n\\n#
      Wait for providers to be healthy\\necho \\\"Waiting for providers to be healthy...\\\"\\nkubectl
      wait --for=condition=Healthy provider/provider-github --timeout=300s || true\\nkubectl
      wait --for=condition=Healthy provider/provider-kubernetes --timeout=300s ||
      true\\nkubectl wait --for=condition=Healthy provider/provider-helm --timeout=300s
      || true\\n\\necho \\\"Crossplane Providers installed successfully\\\"\\n\"],\"image\":\"bitnami/kubectl:latest\",\"name\":\"provider-installer\"}],\"nodeSelector\":{\"eks.amazonaws.com/nodegroup\":\"socrateshlapolosa-karpenter-demo-ng-medium\"},\"restartPolicy\":\"OnFailure\",\"serviceAccountName\":\"crossplane-installer\"}}}}},\"providerConfigRef\":{\"name\":\"kubernetes-provider\"}}},\"name\":\"vcluster-crossplane-providers\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-provider-installer\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-provider-installer\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"kubernetes.crossplane.io/v1alpha1\",\"kind\":\"Object\",\"spec\":{\"forProvider\":{\"manifest\":{\"apiVersion\":\"v1\",\"kind\":\"ServiceAccount\",\"metadata\":{\"name\":\"vcluster-admin\",\"namespace\":\"placeholder\"}}},\"providerConfigRef\":{\"name\":\"default\"}}},\"name\":\"vcluster-admin-sa\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.namespace\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-admin-sa\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"kubernetes.crossplane.io/v1alpha1\",\"kind\":\"Object\",\"spec\":{\"forProvider\":{\"manifest\":{\"apiVersion\":\"rbac.authorization.k8s.io/v1\",\"kind\":\"ClusterRoleBinding\",\"metadata\":{\"name\":\"placeholder\"},\"roleRef\":{\"apiGroup\":\"rbac.authorization.k8s.io\",\"kind\":\"ClusterRole\",\"name\":\"cluster-admin\"},\"subjects\":[{\"kind\":\"ServiceAccount\",\"name\":\"vcluster-admin\",\"namespace\":\"placeholder\"}]}},\"providerConfigRef\":{\"name\":\"default\"}}},\"name\":\"vcluster-admin-crb\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-admin-crb\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.subjects[0].namespace\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-admin-crb\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"kubernetes.crossplane.io/v1alpha1\",\"kind\":\"Object\",\"spec\":{\"forProvider\":{\"manifest\":{\"apiVersion\":\"networking.istio.io/v1beta1\",\"kind\":\"Gateway\",\"metadata\":{\"name\":\"placeholder\",\"namespace\":\"placeholder\"},\"spec\":{\"selector\":{\"istio\":\"ingressgateway\"},\"servers\":[{\"hosts\":[\"placeholder\"],\"port\":{\"name\":\"http\",\"number\":80,\"protocol\":\"HTTP\"}},{\"hosts\":[\"placeholder\"],\"port\":{\"name\":\"https\",\"number\":443,\"protocol\":\"HTTPS\"},\"tls\":{\"credentialName\":\"vcluster-tls-secret\",\"mode\":\"SIMPLE\"}}]}}},\"providerConfigRef\":{\"name\":\"default\"}}},\"name\":\"vcluster-istio-gateway\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-gateway\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.namespace\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-gateway\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.domain\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"spec.forProvider.manifest.spec.servers[0].hosts[0]\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.domain\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"spec.forProvider.manifest.spec.servers[1].hosts[0]\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"spec.forProvider.manifest.spec.servers[0].hosts[0]\",\"transforms\":[{\"string\":{\"fmt\":\"%s-vcluster.local\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"spec.forProvider.manifest.spec.servers[1].hosts[0]\",\"transforms\":[{\"string\":{\"fmt\":\"%s-vcluster.local\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"kubernetes.crossplane.io/v1alpha1\",\"kind\":\"Object\",\"spec\":{\"forProvider\":{\"manifest\":{\"apiVersion\":\"networking.istio.io/v1beta1\",\"kind\":\"VirtualService\",\"metadata\":{\"name\":\"placeholder\",\"namespace\":\"placeholder\"},\"spec\":{\"gateways\":[\"placeholder\"],\"hosts\":[\"placeholder\"],\"http\":[{\"match\":[{\"uri\":{\"prefix\":\"/\"}}],\"route\":[{\"destination\":{\"host\":\"placeholder\",\"port\":{\"number\":443}}}]}]}}},\"providerConfigRef\":{\"name\":\"default\"}}},\"name\":\"vcluster-istio-virtualservice\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-virtualservice\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.namespace\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-virtualservice\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.spec.gateways[0]\",\"transforms\":[{\"string\":{\"fmt\":\"%s-gateway\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.domain\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"spec.forProvider.manifest.spec.hosts[0]\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"spec.forProvider.manifest.spec.hosts[0]\",\"transforms\":[{\"string\":{\"fmt\":\"%s-vcluster.local\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.spec.http[0].route[0].destination.host\",\"transforms\":[{\"string\":{\"fmt\":\"%s-vcluster\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"kubernetes.crossplane.io/v1alpha1\",\"kind\":\"Object\",\"spec\":{\"forProvider\":{\"manifest\":{\"apiVersion\":\"batch/v1\",\"kind\":\"Job\",\"metadata\":{\"name\":\"placeholder\",\"namespace\":\"placeholder\"},\"spec\":{\"template\":{\"spec\":{\"containers\":[{\"command\":[\"/bin/bash\",\"-c\",\"set
      -e\\necho \\\"Waiting for vCluster to be ready...\\\"\\nsleep 60\\n\\nVCLUSTER_NAME=$(echo
      $HOSTNAME | cut -d'-' -f1-2)  # Extract from job name\\nNAMESPACE=$VCLUSTER_NAME\\n\\necho
      \\\"Creating connection secret for vCluster: $VCLUSTER_NAME in namespace: $NAMESPACE\\\"\\n\\n#
      Wait for vCluster service to be ready\\nkubectl wait --for=condition=ready pod
      -l app=vcluster -n $NAMESPACE --timeout=300s || echo \\\"Warning: Pod wait timeout\\\"\\n\\n#
      Get service account token\\nTOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\\n\\n#
      Create kubeconfig\\ncat \\u003c\\u003c EOF \\u003e /tmp/kubeconfig\\napiVersion:
      v1\\nkind: Config\\nclusters:\\n- cluster:\\n    server: https://${VCLUSTER_NAME}-vcluster.${NAMESPACE}.svc.cluster.local:443\\n
      \   insecure-skip-tls-verify: true\\n  name: ${VCLUSTER_NAME}\\ncontexts:\\n-
      context:\\n    cluster: ${VCLUSTER_NAME}\\n    user: ${VCLUSTER_NAME}-admin\\n
      \ name: ${VCLUSTER_NAME}\\ncurrent-context: ${VCLUSTER_NAME}\\nusers:\\n- name:
      ${VCLUSTER_NAME}-admin\\n  user:\\n    token: ${TOKEN}\\nEOF\\n\\n# Encode data\\nKUBECONFIG_B64=$(cat
      /tmp/kubeconfig | base64 -w 0)\\nENDPOINT_B64=$(echo -n \\\"https://${VCLUSTER_NAME}-vcluster.${NAMESPACE}.svc.cluster.local:443\\\"
      | base64 -w 0)\\nTOKEN_B64=$(echo -n ${TOKEN} | base64 -w 0)\\n\\n# Create connection
      secret\\ncat \\u003c\\u003c EOF | kubectl apply -f -\\napiVersion: v1\\nkind:
      Secret\\nmetadata:\\n  name: ${VCLUSTER_NAME}-vcluster-connection\\n  namespace:
      crossplane-system\\n  labels:\\n    crossplane.io/connection-secret: \\\"true\\\"\\n
      \   vcluster.name: \\\"${VCLUSTER_NAME}\\\"\\ntype: connection.crossplane.io/v1alpha1\\ndata:\\n
      \ kubeconfig: ${KUBECONFIG_B64}\\n  endpoint: ${ENDPOINT_B64}\\n  token: ${TOKEN_B64}\\nEOF\\n\\n#
      TODO: Add AWS Secrets Manager integration here\\n# AWS CLI commands to create/update
      AWS secret with connection details\\n# aws secretsmanager create-secret --name
      \\\"vcluster/${VCLUSTER_NAME}/connection\\\" \\\\\\n#   --secret-string \\\"{\\\\\\\"kubeconfig\\\\\\\":\\\\\\\"$(cat
      /tmp/kubeconfig | base64)\\\\\\\",\\\\\\\"endpoint\\\\\\\":\\\\\\\"https://${VCLUSTER_NAME}-vcluster.${NAMESPACE}.svc.cluster.local:443\\\\\\\"}\\\"\\n\\necho
      \\\"Connection secret created successfully: ${VCLUSTER_NAME}-vcluster-connection\\\"\\n\"],\"image\":\"bitnami/kubectl:latest\",\"name\":\"kubeconfig-extractor\"}],\"nodeSelector\":{\"eks.amazonaws.com/nodegroup\":\"socrateshlapolosa-karpenter-demo-ng-medium\"},\"restartPolicy\":\"OnFailure\",\"serviceAccountName\":\"vcluster-admin\"}}}}},\"providerConfigRef\":{\"name\":\"default\"}}},\"name\":\"vcluster-kubeconfig-job\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-kubeconfig-job\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.namespace\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-kubeconfig-job\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"kubernetes.crossplane.io/v1alpha1\",\"kind\":\"Object\",\"spec\":{\"forProvider\":{\"manifest\":{\"apiVersion\":\"batch/v1\",\"kind\":\"Job\",\"metadata\":{\"name\":\"placeholder\",\"namespace\":\"placeholder\"},\"spec\":{\"template\":{\"spec\":{\"containers\":[{\"command\":[\"/bin/sh\",\"-c\",\"set
      -e\\necho \\\"Installing Istio in vCluster...\\\"\\n\\n# Install Istio with
      minimal profile for cost optimization\\nistioctl install --set values.pilot.resources.requests.cpu=100m
      \\\\\\n  --set values.pilot.resources.requests.memory=128Mi \\\\\\n  --set values.pilot.resources.limits.cpu=500m
      \\\\\\n  --set values.pilot.resources.limits.memory=256Mi \\\\\\n  --set values.global.proxy.resources.requests.cpu=50m
      \\\\\\n  --set values.global.proxy.resources.requests.memory=64Mi \\\\\\n  --set
      values.global.proxy.resources.limits.cpu=200m \\\\\\n  --set values.global.proxy.resources.limits.memory=128Mi
      \\\\\\n  --set values.pilot.env.PILOT_ENABLE_KNATIVE_GATEWAY_API=true \\\\\\n
      \ -y\\n\\n# Wait for Istio to be ready\\nkubectl wait --for=condition=Ready
      pod -l app=istiod -n istio-system --timeout=300s\\n\\necho \\\"Istio installed
      successfully in vCluster\\\"\\n\"],\"image\":\"istio/istioctl:1.19.0\",\"name\":\"istio-installer\"}],\"nodeSelector\":{\"eks.amazonaws.com/nodegroup\":\"socrateshlapolosa-karpenter-demo-ng-medium\"},\"restartPolicy\":\"OnFailure\",\"serviceAccountName\":\"vcluster-admin\"}}}}},\"providerConfigRef\":{\"name\":\"vcluster-provider\"}}},\"name\":\"vcluster-istio\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-istio-installer\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.namespace\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-istio\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"status.atProvider.manifest.status.succeeded\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"status.components.istio.ready\",\"transforms\":[{\"map\":{\"0\":false,\"1\":true},\"type\":\"map\"}],\"type\":\"ToCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"status.components.istio.endpoint\",\"transforms\":[{\"string\":{\"fmt\":\"http://istio-ingressgateway.istio-system.%s.svc.cluster.local\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.components.istio\",\"toFieldPath\":\"metadata.labels[\\\"crossplane.io/enable\\\"]\",\"transforms\":[{\"map\":{\"false\":\"false\",\"true\":\"true\"},\"type\":\"map\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"kubernetes.crossplane.io/v1alpha1\",\"kind\":\"Object\",\"spec\":{\"forProvider\":{\"manifest\":{\"apiVersion\":\"batch/v1\",\"kind\":\"Job\",\"metadata\":{\"name\":\"placeholder\",\"namespace\":\"placeholder\"},\"spec\":{\"template\":{\"spec\":{\"containers\":[{\"command\":[\"/bin/sh\",\"-c\",\"set
      -e\\necho \\\"Installing Knative Serving in vCluster...\\\"\\n\\n# Install Knative
      Serving CRDs\\nkubectl apply -f https://github.com/knative/serving/releases/download/knative-v1.12.0/serving-crds.yaml\\n\\n#
      Wait for CRDs\\nkubectl wait --for condition=established --timeout=60s crd/services.serving.knative.dev\\n\\n#
      Install Knative Serving Core\\nkubectl apply -f https://github.com/knative/serving/releases/download/knative-v1.12.0/serving-core.yaml\\n\\n#
      Install Knative Istio Networking\\nkubectl apply -f https://github.com/knative/net-istio/releases/download/knative-v1.12.0/net-istio.yaml\\n\\n#
      Wait for Knative components\\nkubectl wait --for=condition=Ready pod -l app=controller
      -n knative-serving --timeout=300s\\nkubectl wait --for=condition=Ready pod -l
      app=activator -n knative-serving --timeout=300s\\nkubectl wait --for=condition=Ready
      pod -l app=autoscaler -n knative-serving --timeout=300s\\nkubectl wait --for=condition=Ready
      pod -l app=webhook -n knative-serving --timeout=300s\\n\\n# Apply cost-optimized
      configuration\\ncat \\u003c\\u003cEOF | kubectl apply -f -\\napiVersion: v1\\nkind:
      ConfigMap\\nmetadata:\\n  name: config-autoscaler\\n  namespace: knative-serving\\ndata:\\n
      \ enable-scale-to-zero: \\\"true\\\"\\n  scale-to-zero-grace-period: \\\"30s\\\"\\n
      \ scale-to-zero-pod-retention-period: \\\"2m\\\"\\n  min-scale: \\\"0\\\"\\n
      \ max-scale: \\\"5\\\"\\n  initial-scale: \\\"0\\\"\\n  allow-zero-initial-scale:
      \\\"true\\\"\\n  max-scale-up-rate: \\\"5.0\\\"\\n  max-scale-down-rate: \\\"2.0\\\"\\n
      \ container-concurrency-target-default: \\\"50\\\"\\n  container-concurrency-target-percentage:
      \\\"70\\\"\\n  target-burst-capacity: \\\"100\\\"\\n  activator-capacity: \\\"50\\\"\\n
      \ concurrency-state-endpoint: \\\"/health\\\"\\n---\\napiVersion: v1\\nkind:
      ConfigMap\\nmetadata:\\n  name: config-defaults\\n  namespace: knative-serving\\ndata:\\n
      \ revision-cpu-request: \\\"100m\\\"\\n  revision-memory-request: \\\"128Mi\\\"\\n
      \ revision-cpu-limit: \\\"500m\\\"\\n  revision-memory-limit: \\\"256Mi\\\"\\n
      \ container-concurrency: \\\"50\\\"\\n  revision-timeout-seconds: \\\"300\\\"\\n---\\napiVersion:
      v1\\nkind: ConfigMap\\nmetadata:\\n  name: config-network\\n  namespace: knative-serving\\ndata:\\n
      \ ingress-class: \\\"istio.ingress.networking.knative.dev\\\"\\n  domain-template:
      \\\"{{.Name}}.{{.Namespace}}.svc.cluster.local\\\"\\n  default-timeout: \\\"300s\\\"\\n
      \ max-timeout: \\\"600s\\\"\\n  default-visibility: \\\"cluster-local\\\"\\nEOF\\n\\necho
      \\\"Knative Serving installed successfully with cost optimization\\\"\\n\"],\"image\":\"bitnami/kubectl:latest\",\"name\":\"knative-installer\"}],\"nodeSelector\":{\"eks.amazonaws.com/nodegroup\":\"socrateshlapolosa-karpenter-demo-ng-medium\"},\"restartPolicy\":\"OnFailure\",\"serviceAccountName\":\"vcluster-admin\"}}}}},\"providerConfigRef\":{\"name\":\"vcluster-provider\"}}},\"name\":\"vcluster-knative-serving\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-knative-installer\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.namespace\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-knative\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"status.atProvider.manifest.status.succeeded\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"status.components.knativeServing.ready\",\"transforms\":[{\"map\":{\"0\":false,\"1\":true},\"type\":\"map\"}],\"type\":\"ToCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"status.components.knativeServing.endpoint\",\"transforms\":[{\"string\":{\"fmt\":\"http://istio-ingressgateway.istio-system.%s.svc.cluster.local\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.components.knativeServing\",\"toFieldPath\":\"metadata.labels[\\\"crossplane.io/enable\\\"]\",\"transforms\":[{\"map\":{\"false\":\"false\",\"true\":\"true\"},\"type\":\"map\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"kubernetes.crossplane.io/v1alpha1\",\"kind\":\"Object\",\"spec\":{\"forProvider\":{\"manifest\":{\"apiVersion\":\"argoproj.io/v1alpha1\",\"kind\":\"Application\",\"metadata\":{\"name\":\"placeholder\",\"namespace\":\"placeholder\"},\"spec\":{\"destination\":{\"namespace\":\"argocd\",\"server\":\"https://kubernetes.default.svc\"},\"project\":\"default\",\"source\":{\"chart\":\"argo-cd\",\"helm\":{\"values\":\"server:\\n
      \ service:\\n    type: ClusterIP\\n  ingress:\\n    enabled: false\\nconfigs:\\n
      \ params:\\n    server.insecure: true\\n\"},\"repoURL\":\"https://argoproj.github.io/argo-helm\",\"targetRevision\":\"5.46.8\"},\"syncPolicy\":{\"automated\":{\"prune\":true,\"selfHeal\":true},\"syncOptions\":[\"CreateNamespace=true\"]}}}},\"providerConfigRef\":{\"name\":\"default\"}}},\"name\":\"vcluster-argocd\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-argocd\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.namespace\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-argocd\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"status.atProvider.manifest.status.health.status\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"status.components.argoCD.ready\",\"transforms\":[{\"map\":{\"Degraded\":false,\"Healthy\":true},\"type\":\"map\"}],\"type\":\"ToCompositeFieldPath\"},{\"fromFieldPath\":\"spec.forProvider.manifest.metadata.namespace\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"status.components.argoCD.endpoint\",\"transforms\":[{\"string\":{\"fmt\":\"http://argocd-server.%s.svc.cluster.local:80\"},\"type\":\"string\"}],\"type\":\"ToCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"helm.crossplane.io/v1beta1\",\"kind\":\"Release\",\"spec\":{\"forProvider\":{\"chart\":{\"name\":\"grafana\",\"repository\":\"https://grafana.github.io/helm-charts\",\"version\":\"7.0.3\"},\"namespace\":\"placeholder\",\"skipCreateNamespace\":false,\"values\":{\"adminPassword\":\"admin123\",\"dashboardProviders\":{\"dashboardproviders.yaml\":{\"apiVersion\":1,\"providers\":[{\"disableDeletion\":false,\"editable\":true,\"folder\":\"\",\"name\":\"default\",\"options\":{\"path\":\"/var/lib/grafana/dashboards/default\"},\"orgId\":1,\"type\":\"file\"}]}},\"dashboards\":{\"default\":{\"istio-mesh\":{\"datasource\":\"Prometheus\",\"gnetId\":7639,\"revision\":173},\"istio-service\":{\"datasource\":\"Prometheus\",\"gnetId\":7636,\"revision\":173},\"istio-workload\":{\"datasource\":\"Prometheus\",\"gnetId\":7630,\"revision\":173},\"knative-serving\":{\"datasource\":\"Prometheus\",\"gnetId\":17175,\"revision\":3},\"kubernetes-cluster\":{\"datasource\":\"Prometheus\",\"gnetId\":15757,\"revision\":31},\"kubernetes-pods\":{\"datasource\":\"Prometheus\",\"gnetId\":15760,\"revision\":20}}},\"datasources\":{\"datasources.yaml\":{\"apiVersion\":1,\"datasources\":[{\"access\":\"proxy\",\"isDefault\":true,\"name\":\"Prometheus\",\"type\":\"prometheus\",\"url\":\"http://kube-prometheus-stack-prometheus:9090\"},{\"access\":\"proxy\",\"name\":\"Jaeger\",\"type\":\"jaeger\",\"url\":\"http://jaeger-query:16686\"}]}},\"persistence\":{\"enabled\":false},\"resources\":{\"limits\":{\"cpu\":\"500m\",\"memory\":\"512Mi\"},\"requests\":{\"cpu\":\"100m\",\"memory\":\"256Mi\"}},\"service\":{\"type\":\"ClusterIP\"}}},\"providerConfigRef\":{\"name\":\"vcluster-provider\"}}},\"name\":\"vcluster-grafana\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.namespace\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-grafana\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.values.datasources.datasources\\\\.yaml.datasources[0].url\",\"transforms\":[{\"string\":{\"fmt\":\"http://kube-prometheus-stack-prometheus.%s.svc.cluster.local:9090\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.values.datasources.datasources\\\\.yaml.datasources[1].url\",\"transforms\":[{\"string\":{\"fmt\":\"http://jaeger-query.%s.svc.cluster.local:16686\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"status.atProvider.state\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"status.components.grafana.ready\",\"transforms\":[{\"map\":{\"deployed\":true,\"failed\":false},\"type\":\"map\"}],\"type\":\"ToCompositeFieldPath\"},{\"fromFieldPath\":\"spec.forProvider.namespace\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"status.components.grafana.endpoint\",\"transforms\":[{\"string\":{\"fmt\":\"http://grafana.%s.svc.cluster.local:80\"},\"type\":\"string\"}],\"type\":\"ToCompositeFieldPath\"},{\"fromFieldPath\":\"spec.components.grafana\",\"toFieldPath\":\"metadata.labels[\\\"crossplane.io/enable\\\"]\",\"transforms\":[{\"map\":{\"false\":\"false\",\"true\":\"true\"},\"type\":\"map\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"helm.crossplane.io/v1beta1\",\"kind\":\"Release\",\"spec\":{\"forProvider\":{\"chart\":{\"name\":\"kube-prometheus-stack\",\"repository\":\"https://prometheus-community.github.io/helm-charts\",\"version\":\"54.0.1\"},\"namespace\":\"placeholder\",\"skipCreateNamespace\":false,\"values\":{\"alertmanager\":{\"enabled\":false},\"grafana\":{\"enabled\":false},\"prometheus\":{\"prometheusSpec\":{\"additionalScrapeConfigs\":[{\"job_name\":\"kubernetes-pods\",\"kubernetes_sd_configs\":[{\"role\":\"pod\"}],\"relabel_configs\":[{\"action\":\"keep\",\"regex\":true,\"source_labels\":[\"__meta_kubernetes_pod_annotation_prometheus_io_scrape\"]},{\"action\":\"replace\",\"regex\":\"(.+)\",\"source_labels\":[\"__meta_kubernetes_pod_annotation_prometheus_io_path\"],\"target_label\":\"__metrics_path__\"},{\"action\":\"replace\",\"regex\":\"([^:]+)(?::\\\\d+)?;(\\\\d+)\",\"replacement\":\"$1:$2\",\"source_labels\":[\"__address__\",\"__meta_kubernetes_pod_annotation_prometheus_io_port\"],\"target_label\":\"__address__\"}]},{\"job_name\":\"istio-mesh\",\"kubernetes_sd_configs\":[{\"namespaces\":{\"names\":[\"istio-system\"]},\"role\":\"endpoints\"}],\"relabel_configs\":[{\"action\":\"keep\",\"regex\":\"istio-proxy;.*\",\"source_labels\":[\"__meta_kubernetes_service_name\",\"__meta_kubernetes_endpoint_port_name\"]}]},{\"job_name\":\"knative-serving\",\"kubernetes_sd_configs\":[{\"namespaces\":{\"names\":[\"knative-serving\"]},\"role\":\"endpoints\"}],\"relabel_configs\":[{\"action\":\"keep\",\"regex\":\"(activator|autoscaler|controller|webhook)\",\"source_labels\":[\"__meta_kubernetes_service_name\"]}]}],\"resources\":{\"limits\":{\"cpu\":\"1000m\",\"memory\":\"1Gi\"},\"requests\":{\"cpu\":\"200m\",\"memory\":\"512Mi\"}}},\"service\":{\"type\":\"ClusterIP\"}}}},\"providerConfigRef\":{\"name\":\"vcluster-provider\"}}},\"name\":\"vcluster-prometheus\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.namespace\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-prometheus\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"status.atProvider.state\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"status.components.prometheus.ready\",\"transforms\":[{\"map\":{\"deployed\":true,\"failed\":false},\"type\":\"map\"}],\"type\":\"ToCompositeFieldPath\"},{\"fromFieldPath\":\"spec.forProvider.namespace\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"status.components.prometheus.endpoint\",\"transforms\":[{\"string\":{\"fmt\":\"http://kube-prometheus-stack-prometheus.%s.svc.cluster.local:9090\"},\"type\":\"string\"}],\"type\":\"ToCompositeFieldPath\"},{\"fromFieldPath\":\"spec.components.prometheus\",\"toFieldPath\":\"metadata.labels[\\\"crossplane.io/enable\\\"]\",\"transforms\":[{\"map\":{\"false\":\"false\",\"true\":\"true\"},\"type\":\"map\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"helm.crossplane.io/v1beta1\",\"kind\":\"Release\",\"spec\":{\"forProvider\":{\"chart\":{\"name\":\"jaeger\",\"repository\":\"https://jaegertracing.github.io/helm-charts\",\"version\":\"0.71.11\"},\"namespace\":\"placeholder\",\"skipCreateNamespace\":false,\"values\":{\"agent\":{\"resources\":{\"limits\":{\"cpu\":\"200m\",\"memory\":\"256Mi\"},\"requests\":{\"cpu\":\"50m\",\"memory\":\"128Mi\"}}},\"allInOne\":{\"enabled\":true,\"image\":\"jaegertracing/all-in-one:1.49\",\"options\":{\"log-level\":\"info\",\"memory.max-traces\":10000},\"resources\":{\"limits\":{\"cpu\":\"1000m\",\"memory\":\"1Gi\"},\"requests\":{\"cpu\":\"200m\",\"memory\":\"512Mi\"}}},\"collector\":{\"resources\":{\"limits\":{\"cpu\":\"500m\",\"memory\":\"512Mi\"},\"requests\":{\"cpu\":\"100m\",\"memory\":\"256Mi\"}},\"service\":{\"type\":\"ClusterIP\"}},\"query\":{\"resources\":{\"limits\":{\"cpu\":\"500m\",\"memory\":\"512Mi\"},\"requests\":{\"cpu\":\"100m\",\"memory\":\"256Mi\"}},\"service\":{\"type\":\"ClusterIP\"}}}},\"providerConfigRef\":{\"name\":\"vcluster-provider\"}}},\"name\":\"vcluster-jaeger\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.namespace\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-jaeger\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"status.atProvider.state\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"status.components.jaeger.ready\",\"transforms\":[{\"map\":{\"deployed\":true,\"failed\":false},\"type\":\"map\"}],\"type\":\"ToCompositeFieldPath\"},{\"fromFieldPath\":\"spec.forProvider.namespace\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"status.components.jaeger.endpoint\",\"transforms\":[{\"string\":{\"fmt\":\"http://jaeger-query.%s.svc.cluster.local:16686\"},\"type\":\"string\"}],\"type\":\"ToCompositeFieldPath\"},{\"fromFieldPath\":\"spec.components.jaeger\",\"toFieldPath\":\"metadata.labels[\\\"crossplane.io/enable\\\"]\",\"transforms\":[{\"map\":{\"false\":\"false\",\"true\":\"true\"},\"type\":\"map\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"helm.crossplane.io/v1beta1\",\"kind\":\"Release\",\"spec\":{\"forProvider\":{\"chart\":{\"name\":\"kiali-server\",\"repository\":\"https://kiali.org/helm-charts\",\"version\":\"1.76.0\"},\"namespace\":\"placeholder\",\"skipCreateNamespace\":false,\"values\":{\"auth\":{\"strategy\":\"anonymous\"},\"external_services\":{\"prometheus\":{\"url\":\"http://prometheus-server.monitoring.svc.cluster.local:80\"}},\"service\":{\"type\":\"ClusterIP\"}}},\"providerConfigRef\":{\"name\":\"default\"}}},\"name\":\"vcluster-kiali\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.namespace\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-kiali\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"status.atProvider.state\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"status.components.kiali.ready\",\"transforms\":[{\"map\":{\"deployed\":true,\"failed\":false},\"type\":\"map\"}],\"type\":\"ToCompositeFieldPath\"},{\"fromFieldPath\":\"spec.forProvider.namespace\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"status.components.kiali.endpoint\",\"transforms\":[{\"string\":{\"fmt\":\"http://kiali.%s.svc.cluster.local:20001\"},\"type\":\"string\"}],\"type\":\"ToCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"kubernetes.crossplane.io/v1alpha1\",\"kind\":\"Object\",\"spec\":{\"forProvider\":{\"manifest\":{\"apiVersion\":\"networking.istio.io/v1beta1\",\"kind\":\"VirtualService\",\"metadata\":{\"name\":\"placeholder\",\"namespace\":\"placeholder\"},\"spec\":{\"gateways\":[\"placeholder\"],\"hosts\":[\"placeholder\"],\"http\":[{\"match\":[{\"uri\":{\"prefix\":\"/prometheus\"}}],\"rewrite\":{\"uri\":\"/\"},\"route\":[{\"destination\":{\"host\":\"placeholder\",\"port\":{\"number\":9090}}}]}]}}},\"providerConfigRef\":{\"name\":\"vcluster-provider\"}}},\"name\":\"vcluster-prometheus-virtualservice\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-prometheus-vs\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.namespace\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-prometheus-vs\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.spec.hosts[0]\",\"transforms\":[{\"string\":{\"fmt\":\"%s-vcluster.local\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.spec.gateways[0]\",\"transforms\":[{\"string\":{\"fmt\":\"%s-gateway\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.spec.http[0].route[0].destination.host\",\"transforms\":[{\"string\":{\"fmt\":\"kube-prometheus-stack-prometheus.%s.svc.cluster.local\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.components.prometheus\",\"toFieldPath\":\"metadata.labels[\\\"crossplane.io/enable\\\"]\",\"transforms\":[{\"map\":{\"false\":\"false\",\"true\":\"true\"},\"type\":\"map\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"kubernetes.crossplane.io/v1alpha1\",\"kind\":\"Object\",\"spec\":{\"forProvider\":{\"manifest\":{\"apiVersion\":\"networking.istio.io/v1beta1\",\"kind\":\"VirtualService\",\"metadata\":{\"name\":\"placeholder\",\"namespace\":\"placeholder\"},\"spec\":{\"gateways\":[\"placeholder\"],\"hosts\":[\"placeholder\"],\"http\":[{\"match\":[{\"uri\":{\"prefix\":\"/grafana\"}}],\"rewrite\":{\"uri\":\"/\"},\"route\":[{\"destination\":{\"host\":\"placeholder\",\"port\":{\"number\":80}}}]}]}}},\"providerConfigRef\":{\"name\":\"vcluster-provider\"}}},\"name\":\"vcluster-grafana-virtualservice\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-grafana-vs\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.namespace\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-grafana-vs\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.spec.hosts[0]\",\"transforms\":[{\"string\":{\"fmt\":\"%s-vcluster.local\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.spec.gateways[0]\",\"transforms\":[{\"string\":{\"fmt\":\"%s-gateway\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.spec.http[0].route[0].destination.host\",\"transforms\":[{\"string\":{\"fmt\":\"grafana.%s.svc.cluster.local\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.components.grafana\",\"toFieldPath\":\"metadata.labels[\\\"crossplane.io/enable\\\"]\",\"transforms\":[{\"map\":{\"false\":\"false\",\"true\":\"true\"},\"type\":\"map\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"kubernetes.crossplane.io/v1alpha1\",\"kind\":\"Object\",\"spec\":{\"forProvider\":{\"manifest\":{\"apiVersion\":\"networking.istio.io/v1beta1\",\"kind\":\"VirtualService\",\"metadata\":{\"name\":\"placeholder\",\"namespace\":\"placeholder\"},\"spec\":{\"gateways\":[\"placeholder\"],\"hosts\":[\"placeholder\"],\"http\":[{\"match\":[{\"uri\":{\"prefix\":\"/jaeger\"}}],\"rewrite\":{\"uri\":\"/\"},\"route\":[{\"destination\":{\"host\":\"placeholder\",\"port\":{\"number\":16686}}}]}]}}},\"providerConfigRef\":{\"name\":\"vcluster-provider\"}}},\"name\":\"vcluster-jaeger-virtualservice\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-jaeger-vs\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.namespace\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-jaeger-vs\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.spec.hosts[0]\",\"transforms\":[{\"string\":{\"fmt\":\"%s-vcluster.local\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.spec.gateways[0]\",\"transforms\":[{\"string\":{\"fmt\":\"%s-gateway\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.spec.http[0].route[0].destination.host\",\"transforms\":[{\"string\":{\"fmt\":\"jaeger-query.%s.svc.cluster.local\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.components.jaeger\",\"toFieldPath\":\"metadata.labels[\\\"crossplane.io/enable\\\"]\",\"transforms\":[{\"map\":{\"false\":\"false\",\"true\":\"true\"},\"type\":\"map\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"kubernetes.crossplane.io/v1alpha1\",\"kind\":\"Object\",\"spec\":{\"forProvider\":{\"manifest\":{\"apiVersion\":\"networking.istio.io/v1beta1\",\"kind\":\"VirtualService\",\"metadata\":{\"name\":\"placeholder\",\"namespace\":\"placeholder\"},\"spec\":{\"gateways\":[\"placeholder\"],\"hosts\":[\"placeholder\"],\"http\":[{\"match\":[{\"uri\":{\"prefix\":\"/kiali\"}}],\"rewrite\":{\"uri\":\"/\"},\"route\":[{\"destination\":{\"host\":\"placeholder\",\"port\":{\"number\":20001}}}]}]}}},\"providerConfigRef\":{\"name\":\"vcluster-provider\"}}},\"name\":\"vcluster-kiali-virtualservice\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-kiali-vs\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.namespace\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-kiali-vs\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.spec.hosts[0]\",\"transforms\":[{\"string\":{\"fmt\":\"%s-vcluster.local\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.spec.gateways[0]\",\"transforms\":[{\"string\":{\"fmt\":\"%s-gateway\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.spec.http[0].route[0].destination.host\",\"transforms\":[{\"string\":{\"fmt\":\"kiali.%s.svc.cluster.local\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.components.kiali\",\"toFieldPath\":\"metadata.labels[\\\"crossplane.io/enable\\\"]\",\"transforms\":[{\"map\":{\"false\":\"false\",\"true\":\"true\"},\"type\":\"map\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"kubernetes.crossplane.io/v1alpha1\",\"kind\":\"Object\",\"spec\":{\"forProvider\":{\"manifest\":{\"apiVersion\":\"v1\",\"data\":{\"owner\":\"c2hsYXBvbG9zYQ==\",\"token\":\"Z2hwX1JHbWtQVFBlcmo5d0pxaTdvcndEbFo2SHlwWHlQZjA2b051Ug==\"},\"kind\":\"Secret\",\"metadata\":{\"name\":\"github-analyzer-credentials\",\"namespace\":\"oam-analyzer-system\"},\"type\":\"Opaque\"}}}},\"name\":\"vcluster-github-secret-copy\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.providerConfigRef.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-vcluster\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"kubernetes.crossplane.io/v1alpha1\",\"kind\":\"Object\",\"spec\":{\"forProvider\":{\"manifest\":{\"apiVersion\":\"v1\",\"kind\":\"Namespace\",\"metadata\":{\"labels\":{\"managed-by\":\"crossplane\",\"name\":\"oam-analyzer-system\"},\"name\":\"oam-analyzer-system\"}}}}},\"name\":\"vcluster-oam-analyzer-namespace\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.namespace\",\"transforms\":[{\"string\":{\"fmt\":\"%s\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.providerConfigRef.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-vcluster\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"kubernetes.crossplane.io/v1alpha1\",\"kind\":\"Object\",\"spec\":{\"forProvider\":{\"manifest\":{\"apiVersion\":\"v1\",\"items\":[{\"apiVersion\":\"v1\",\"kind\":\"ServiceAccount\",\"metadata\":{\"name\":\"oam-application-analyzer\",\"namespace\":\"oam-analyzer-system\"}},{\"apiVersion\":\"rbac.authorization.k8s.io/v1\",\"kind\":\"ClusterRole\",\"metadata\":{\"name\":\"oam-application-analyzer\"},\"rules\":[{\"apiGroups\":[\"core.oam.dev\"],\"resources\":[\"applications\",\"components\"],\"verbs\":[\"get\",\"list\",\"watch\",\"create\",\"update\",\"patch\"]},{\"apiGroups\":[\"platform.example.org\"],\"resources\":[\"applicationclaims\",\"appcontainerclaims\"],\"verbs\":[\"get\",\"list\",\"watch\",\"create\",\"update\",\"patch\"]},{\"apiGroups\":[\"\"],\"resources\":[\"configmaps\",\"secrets\",\"namespaces\"],\"verbs\":[\"get\",\"list\",\"watch\"]},{\"apiGroups\":[\"\"],\"resources\":[\"events\"],\"verbs\":[\"create\"]},{\"apiGroups\":[\"apiextensions.k8s.io\"],\"resources\":[\"customresourcedefinitions\"],\"verbs\":[\"get\",\"list\"]}]},{\"apiVersion\":\"rbac.authorization.k8s.io/v1\",\"kind\":\"ClusterRoleBinding\",\"metadata\":{\"name\":\"oam-application-analyzer\"},\"roleRef\":{\"apiGroup\":\"rbac.authorization.k8s.io\",\"kind\":\"ClusterRole\",\"name\":\"oam-application-analyzer\"},\"subjects\":[{\"kind\":\"ServiceAccount\",\"name\":\"oam-application-analyzer\",\"namespace\":\"oam-analyzer-system\"}]}],\"kind\":\"List\"}}}},\"name\":\"vcluster-oam-analyzer-rbac\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.providerConfigRef.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-vcluster\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"kubernetes.crossplane.io/v1alpha1\",\"kind\":\"Object\",\"spec\":{\"forProvider\":{\"manifest\":{\"apiVersion\":\"v1\",\"data\":{\"config.yaml\":\"analyzer:\\n
      \ # Enable automatic infrastructure creation\\n  autoCreateRepos: true\\n  autoCreateDatabases:
      true\\n  autoCreateCaches: true\\n  autoCreateAppContainers: true\\n  \\n  #
      Reconciliation settings\\n  reconcileInterval: \\\"30s\\\"\\n  maxRetries: 3\\n
      \ \\ninference:\\n  # Default language and framework for new services\\n  defaultLanguage:
      \\\"python\\\"\\n  defaultFramework: \\\"fastapi\\\"\\n  \\n  # Language detection
      hints\\n  languageHints:\\n    # Environment variable hints\\n    - type: \\\"env\\\"\\n
      \     key: \\\"PYTHONPATH\\\"\\n      language: \\\"python\\\"\\n      framework:
      \\\"fastapi\\\"\\n    - type: \\\"env\\\"\\n      key: \\\"JAVA_OPTS\\\"\\n
      \     language: \\\"java\\\"\\n      framework: \\\"springboot\\\"\\n    - type:
      \\\"env\\\"\\n      key: \\\"NODE_PATH\\\"\\n      language: \\\"nodejs\\\"\\n
      \     framework: \\\"express\\\"\\n      \\n    # Port-based hints\\n    - type:
      \\\"port\\\"\\n      value: \\\"8080\\\"\\n      language: \\\"java\\\"\\n      framework:
      \\\"springboot\\\"\\n    - type: \\\"port\\\"\\n      value: \\\"8000\\\"\\n
      \     language: \\\"python\\\"\\n      framework: \\\"fastapi\\\"\\n    - type:
      \\\"port\\\"\\n      value: \\\"3000\\\"\\n      language: \\\"nodejs\\\"\\n
      \     framework: \\\"express\\\"\\n      \\nrepositories:\\n  # GitHub organization
      for new repositories\\n  organization: \\\"shlapolosa\\\"\\n  \\n  # Docker
      registry for container images\\n  registry: \\\"docker.io/socrates12345\\\"\\n
      \ \\ndatabases:\\n  # Default database type\\n  defaultType: \\\"postgres\\\"\\n
      \ \\ncaches:\\n  # Default cache type\\n  defaultType: \\\"redis\\\"\\n  \\nlogging:\\n
      \ level: \\\"info\\\"\\n  format: \\\"json\\\"\\n\"},\"kind\":\"ConfigMap\",\"metadata\":{\"name\":\"oam-analyzer-config\",\"namespace\":\"oam-analyzer-system\"}}}}},\"name\":\"vcluster-oam-analyzer-config\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.providerConfigRef.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-vcluster\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.labels[\\\"github-org\\\"]\",\"transforms\":[{\"string\":{\"fmt\":\"shlapolosa\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"kubernetes.crossplane.io/v1alpha1\",\"kind\":\"Object\",\"spec\":{\"forProvider\":{\"manifest\":{\"apiVersion\":\"batch/v1\",\"kind\":\"CronJob\",\"metadata\":{\"name\":\"oam-application-analyzer\",\"namespace\":\"oam-analyzer-system\"},\"spec\":{\"failedJobsHistoryLimit\":1,\"jobTemplate\":{\"spec\":{\"template\":{\"spec\":{\"containers\":[{\"command\":[\"/bin/bash\",\"-c\",\"set
      -e\\n\\n# Install curl for GitHub API calls\\napt-get update \\u0026\\u0026
      apt-get install -y curl\\n\\necho \\\"\U0001F50D OAM Application Infrastructure
      Analyzer\\\"\\necho \\\"Time: $(date)\\\"\\necho \\\"==========================================\\\"\\n\\n#
      Function to check if a GitHub repository exists\\ncheck_github_repo() {\\n  local
      repo_name=\\\"$1\\\"\\n  local org=\\\"${GITHUB_ORG:-shlapolosa}\\\"\\n  \\n
      \ echo \\\"\U0001F50D Checking if GitHub repo exists: $org/$repo_name\\\"\\n
      \ \\n  if [ -n \\\"$GITHUB_TOKEN\\\" ]; then\\n    # Use GitHub API to check
      if repository exists\\n    local response_code=$(curl -s -o /dev/null -w \\\"%{http_code}\\\"
      \\\\\\n      -H \\\"Authorization: token $GITHUB_TOKEN\\\" \\\\\\n      -H \\\"Accept:
      application/vnd.github.v3+json\\\" \\\\\\n      \\\"https://api.github.com/repos/$org/$repo_name\\\")\\n
      \   \\n    if [ \\\"$response_code\\\" = \\\"200\\\" ]; then\\n      echo \\\"âœ…
      Repository $org/$repo_name exists\\\"\\n      return 0\\n    elif [ \\\"$response_code\\\"
      = \\\"404\\\" ]; then\\n      echo \\\"â„¹ï¸  Repository $org/$repo_name does not
      exist\\\"\\n      return 1\\n    else\\n      echo \\\"âš ï¸  API error checking
      repository (HTTP $response_code), assuming it doesn't exist\\\"\\n      return
      1\\n    fi\\n  else\\n    echo \\\"âš ï¸  No GitHub token available, assuming repo
      does not exist\\\"\\n    return 1\\n  fi\\n}\\n\\n# Function to infer language
      from component properties\\ninfer_language_framework() {\\n  local component_yaml=\\\"$1\\\"\\n
      \ local service_name=\\\"$2\\\"\\n  \\n  local language=\\\"python\\\"\\n  local
      framework=\\\"fastapi\\\"\\n  \\n  # Check environment variables for language
      hints\\n  if echo \\\"$component_yaml\\\" | grep -A 20 \\\"name: $service_name\\\"
      | grep -q \\\"JAVA_OPTS\\\\|SERVER_PORT.*8080\\\"; then\\n    language=\\\"java\\\"\\n
      \   framework=\\\"springboot\\\"\\n  elif echo \\\"$component_yaml\\\" | grep
      -A 20 \\\"name: $service_name\\\" | grep -q \\\"NODE_ENV\\\\|NODE_PATH\\\";
      then\\n    language=\\\"nodejs\\\"\\n    framework=\\\"express\\\"\\n  elif
      echo \\\"$component_yaml\\\" | grep -A 20 \\\"name: $service_name\\\" | grep
      -q \\\"PYTHONPATH\\\"; then\\n    language=\\\"python\\\"\\n    framework=\\\"fastapi\\\"\\n
      \ fi\\n  \\n  # Check image names for language hints\\n  local image_name=$(echo
      \\\"$component_yaml\\\" | grep -A 10 \\\"name: $service_name\\\" | grep \\\"image:\\\"
      | head -1 | awk '{print $2}' | tr -d '\\\"')\\n  if [[ \\\"$image_name\\\" ==
      *\\\"java\\\"* ]] || [[ \\\"$image_name\\\" == *\\\"spring\\\"* ]]; then\\n
      \   language=\\\"java\\\"\\n    framework=\\\"springboot\\\"\\n  elif [[ \\\"$image_name\\\"
      == *\\\"python\\\"* ]] || [[ \\\"$image_name\\\" == *\\\"fastapi\\\"* ]]; then\\n
      \   language=\\\"python\\\"\\n    framework=\\\"fastapi\\\"\\n  elif [[ \\\"$image_name\\\"
      == *\\\"node\\\"* ]]; then\\n    language=\\\"nodejs\\\"\\n    framework=\\\"express\\\"\\n
      \ fi\\n  \\n  # Check port numbers for additional hints\\n  local port=$(echo
      \\\"$component_yaml\\\" | grep -A 20 \\\"name: $service_name\\\" | grep -E \\\"port:|PORT\\\"
      | head -1 | grep -o '[0-9]\\\\+')\\n  if [[ \\\"$port\\\" == \\\"8080\\\" ]];
      then\\n    language=\\\"java\\\"\\n    framework=\\\"springboot\\\"\\n  elif
      [[ \\\"$port\\\" == \\\"8000\\\" ]]; then\\n    language=\\\"python\\\"\\n    framework=\\\"fastapi\\\"\\n
      \ elif [[ \\\"$port\\\" == \\\"3000\\\" ]]; then\\n    language=\\\"nodejs\\\"\\n
      \   framework=\\\"express\\\"\\n  fi\\n  \\n  echo \\\"$language,$framework\\\"\\n}\\n\\n#
      Function to detect database needs\\ndetect_database_needs() {\\n  local component_yaml=\\\"$1\\\"\\n
      \ local service_name=\\\"$2\\\"\\n  \\n  if echo \\\"$component_yaml\\\" | grep
      -A 20 \\\"name: $service_name\\\" | grep -q \\\"DATABASE_URL\\\\|DB_URL\\\\|POSTGRES\\\\|MYSQL\\\";
      then\\n    if echo \\\"$component_yaml\\\" | grep -A 20 \\\"name: $service_name\\\"
      | grep -q \\\"mysql\\\"; then\\n      echo \\\"mysql\\\"\\n    else\\n      echo
      \\\"postgres\\\"  # Default to postgres\\n    fi\\n  else\\n    echo \\\"none\\\"\\n
      \ fi\\n}\\n\\n# Function to detect cache needs\\ndetect_cache_needs() {\\n  local
      component_yaml=\\\"$1\\\"\\n  local service_name=\\\"$2\\\"\\n  \\n  if echo
      \\\"$component_yaml\\\" | grep -A 20 \\\"name: $service_name\\\" | grep -q \\\"REDIS_URL\\\\|CACHE_URL\\\";
      then\\n    echo \\\"redis\\\"\\n  else\\n    echo \\\"none\\\"\\n  fi\\n}\\n\\n#
      Function to create ApplicationClaim\\ncreate_application_claim() {\\n  local
      service_name=\\\"$1\\\"\\n  local namespace=\\\"$2\\\"\\n  local app_container=\\\"$3\\\"\\n
      \ local language=\\\"$4\\\"\\n  local framework=\\\"$5\\\"\\n  local database=\\\"$6\\\"\\n
      \ local cache=\\\"$7\\\"\\n  local source_app=\\\"$8\\\"\\n  \\n  echo \\\"\U0001F3D7ï¸
      \ Creating ApplicationClaim for: $service_name\\\"\\n  echo \\\"   Language:
      $language\\\"\\n  echo \\\"   Framework: $framework\\\"  \\n  echo \\\"   Database:
      $database\\\"\\n  echo \\\"   Cache: $cache\\\"\\n  echo \\\"   AppContainer:
      $app_container\\\"\\n  \\n  cat \\u003c\\u003cEOF | kubectl apply -f -\\napiVersion:
      platform.example.org/v1alpha1\\nkind: ApplicationClaim\\nmetadata:\\n  name:
      $service_name\\n  namespace: $namespace\\n  annotations:\\n    generated-by:
      \\\"oam-analyzer\\\"\\n    generated-at: \\\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\\\"\\n
      \   source-application: \\\"$source_app\\\"\\n    inferred-language: \\\"$language\\\"\\n
      \   inferred-framework: \\\"$framework\\\"\\n    inferred-database: \\\"$database\\\"\\n
      \   inferred-cache: \\\"$cache\\\"\\n  labels:\\n    app.oam.dev/name: \\\"$source_app\\\"\\n
      \   generated-by: \\\"oam-analyzer\\\"\\nspec:\\n  appContainer: $app_container\\n
      \ name: $service_name\\n  language: $language\\n  framework: $framework\\n  database:
      $database\\n  cache: $cache\\n  frontend: false\\n  exposeApi: false\\n  messaging:
      none\\n  apiEndpoint: /api\\nEOF\\n  \\n  if [ $? -eq 0 ]; then\\n    echo \\\"âœ…
      ApplicationClaim $service_name created successfully\\\"\\n  else\\n    echo
      \\\"âŒ Failed to create ApplicationClaim $service_name\\\"\\n  fi\\n}\\n\\n#
      Function to create AppContainerClaim\\ncreate_app_container_claim() {\\n  local
      container_name=\\\"$1\\\"\\n  local namespace=\\\"$2\\\"\\n  local source_app=\\\"$3\\\"\\n
      \ \\n  echo \\\"\U0001F3D7ï¸  Creating AppContainerClaim for: $container_name\\\"\\n
      \ \\n  cat \\u003c\\u003cEOF | kubectl apply -f -\\napiVersion: platform.example.org/v1alpha1\\nkind:
      AppContainerClaim\\nmetadata:\\n  name: $container_name\\n  namespace: $namespace\\n
      \ annotations:\\n    generated-by: \\\"oam-analyzer\\\"\\n    generated-at:
      \\\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\\\"\\n    source-application: \\\"$source_app\\\"\\n
      \ labels:\\n    generated-by: \\\"oam-analyzer\\\"\\nspec:\\n  name: $container_name\\n
      \ description: \\\"Auto-generated AppContainer for OAM Application: $source_app\\\"\\n
      \ gitHubOrg: \\\"${GITHUB_ORG:-shlapolosa}\\\"\\n  dockerRegistry: \\\"${DOCKER_REGISTRY:-docker.io/socrates12345}\\\"\\n
      \ enableObservability: true\\n  enableSecurity: true\\nEOF\\n  \\n  if [ $?
      -eq 0 ]; then\\n    echo \\\"âœ… AppContainerClaim $container_name created successfully\\\"\\n
      \ else\\n    echo \\\"âŒ Failed to create AppContainerClaim $container_name\\\"\\n
      \ fi\\n}\\n\\n# Function to analyze OAM application\\nanalyze_oam_application()
      {\\n  local app_name=\\\"$1\\\"\\n  local app_namespace=\\\"$2\\\"\\n  \\n  echo
      \\\"\\\"\\n  echo \\\"\U0001F4CB Analyzing OAM Application: $app_name in namespace:
      $app_namespace\\\"\\n  echo \\\"==================================================================\\\"\\n
      \ \\n  # Get the application YAML\\n  local app_yaml=$(kubectl get application.core.oam.dev
      \\\"$app_name\\\" -n \\\"$app_namespace\\\" -o yaml 2\\u003e/dev/null)\\n  if
      [ $? -ne 0 ]; then\\n    echo \\\"âŒ Failed to get application $app_name\\\"\\n
      \   return 1\\n  fi\\n  \\n  # Check if already processed (has our annotation)\\n
      \ if echo \\\"$app_yaml\\\" | grep -q \\\"processed-by.*oam-analyzer\\\"; then\\n
      \   echo \\\"âœ… Application $app_name already processed by analyzer\\\"\\n    return
      0\\n  fi\\n  \\n  # Extract components\\n  local components=$(echo \\\"$app_yaml\\\"
      | grep -A 1000 \\\"components:\\\" | grep -E \\\"^  - name:\\\" | awk '{print
      $3}')\\n  \\n  if [ -z \\\"$components\\\" ]; then\\n    echo \\\"â„¹ï¸  No components
      found in application $app_name\\\"\\n    return 0\\n  fi\\n  \\n  echo \\\"\U0001F4E6
      Found components:\\\"\\n  echo \\\"$components\\\" | sed 's/^/   - /'\\n  \\n
      \ # Check/create AppContainer\\n  local app_container_name=\\\"$app_name\\\"\\n
      \ if ! kubectl get appcontainerclaim \\\"$app_container_name\\\" -n \\\"$app_namespace\\\"
      \\u003e/dev/null 2\\u003e\\u00261; then\\n    create_app_container_claim \\\"$app_container_name\\\"
      \\\"$app_namespace\\\" \\\"$app_name\\\"\\n  else\\n    echo \\\"âœ… AppContainerClaim
      $app_container_name already exists\\\"\\n  fi\\n  \\n  # Process each component\\n
      \ while read -r component; do\\n    if [ -n \\\"$component\\\" ]; then\\n      echo
      \\\"\\\"\\n      echo \\\"\U0001F50D Processing component: $component\\\"\\n
      \     echo \\\"----------------------------------------\\\"\\n      \\n      #
      Get component type (first occurrence after component name)\\n      local component_type=$(echo
      \\\"$app_yaml\\\" | grep -A 10 \\\"name: $component\\\" | grep \\\"type:\\\"
      | head -1 | awk '{print $2}')\\n      echo \\\"\U0001F4CB Component type: $component_type\\\"\\n
      \     \\n      # Only process workload components (webservice is our primary
      workload type)\\n      if [[ \\\"$component_type\\\" == \\\"knative-service\\\"
      ]] || [[ \\\"$component_type\\\" == \\\"webservice\\\" ]] || [[ \\\"$component_type\\\"
      == \\\"webservice-fixed\\\" ]]; then\\n        \\n        # Check if ApplicationClaim
      already exists\\n        if kubectl get applicationclaim \\\"$component\\\"
      -n \\\"$app_namespace\\\" \\u003e/dev/null 2\\u003e\\u00261; then\\n          echo
      \\\"âœ… ApplicationClaim for $component already exists\\\"\\n        else\\n          #
      Check if GitHub repo exists (in production, this would use GitHub API)\\n          if
      ! check_github_repo \\\"$component\\\"; then\\n            echo \\\"\U0001F50D
      Repository does not exist, creating ApplicationClaim...\\\"\\n            \\n
      \           # Infer language and framework\\n            local lang_fw=$(infer_language_framework
      \\\"$app_yaml\\\" \\\"$component\\\")\\n            local language=$(echo \\\"$lang_fw\\\"
      | cut -d',' -f1)\\n            local framework=$(echo \\\"$lang_fw\\\" | cut
      -d',' -f2)\\n            \\n            # Detect infrastructure needs\\n            local
      database=$(detect_database_needs \\\"$app_yaml\\\" \\\"$component\\\")\\n            local
      cache=$(detect_cache_needs \\\"$app_yaml\\\" \\\"$component\\\")\\n            \\n
      \           # Create the ApplicationClaim\\n            create_application_claim
      \\\"$component\\\" \\\"$app_namespace\\\" \\\"$app_container_name\\\" \\\"$language\\\"
      \\\"$framework\\\" \\\"$database\\\" \\\"$cache\\\" \\\"$app_name\\\"\\n          else\\n
      \           echo \\\"âœ… Repository for $component already exists\\\"\\n          fi\\n
      \       fi\\n      else\\n        echo \\\"â„¹ï¸  Component $component is infrastructure/config
      (type: $component_type), skipping ApplicationClaim creation\\\"\\n      fi\\n
      \   fi\\n  done \\u003c\\u003c\\u003c \\\"$components\\\"\\n  \\n  # Mark application
      as processed\\n  echo \\\"\\\"\\n  echo \\\"\U0001F4DD Marking application $app_name
      as processed...\\\"\\n  kubectl annotate application.core.oam.dev \\\"$app_name\\\"
      -n \\\"$app_namespace\\\" processed-by=oam-analyzer processed-at=\\\"$(date
      -u +%Y-%m-%dT%H:%M:%SZ)\\\" --overwrite\\n  \\n  echo \\\"âœ… Analysis complete
      for application: $app_name\\\"\\n}\\n\\n# Main execution\\necho \\\"\U0001F680
      Starting OAM Application monitoring cycle...\\\"\\n\\n# Check prerequisites\\nif
      ! kubectl version --client \\u003e/dev/null 2\\u003e\\u00261; then\\n  echo
      \\\"âŒ kubectl not available\\\"\\n  exit 1\\nfi\\n\\n# Check cluster access\\nif
      ! kubectl get namespaces \\u003e/dev/null 2\\u003e\\u00261; then\\n  echo \\\"âŒ
      Cannot access Kubernetes cluster\\\"\\n  exit 1\\nfi\\n\\n# Check for OAM CRDs\\nif
      ! kubectl get crd applications.core.oam.dev \\u003e/dev/null 2\\u003e\\u00261;
      then\\n  echo \\\"âš ï¸  OAM Application CRD not found, skipping analysis\\\"\\n
      \ exit 0\\nfi\\n\\n# Check for Platform CRDs\\nif ! kubectl get crd applicationclaims.platform.example.org
      \\u003e/dev/null 2\\u003e\\u00261; then\\n  echo \\\"âš ï¸  ApplicationClaim CRD
      not found, skipping analysis\\\"\\n  exit 0\\nfi\\n\\necho \\\"âœ… Prerequisites
      checked\\\"\\n\\n# Find all OAM Applications\\necho \\\"\\\"\\necho \\\"\U0001F50D
      Scanning for OAM Applications...\\\"\\n\\napplications=$(kubectl get applications.core.oam.dev
      --all-namespaces --no-headers 2\\u003e/dev/null | awk '{print $1 \\\" \\\" $2}')\\n\\nif
      [ -z \\\"$applications\\\" ]; then\\n  echo \\\"â„¹ï¸  No OAM Applications found\\\"\\n
      \ exit 0\\nfi\\n\\necho \\\"\U0001F4CB Found OAM Applications:\\\"\\necho \\\"$applications\\\"
      | sed 's/^/   /'\\n\\n# Process each application\\nwhile read -r namespace name;
      do\\n  if [ -n \\\"$namespace\\\" ] \\u0026\\u0026 [ -n \\\"$name\\\" ]; then\\n
      \   analyze_oam_application \\\"$name\\\" \\\"$namespace\\\"\\n  fi\\ndone \\u003c\\u003c\\u003c
      \\\"$applications\\\"\\n\\necho \\\"\\\"\\necho \\\"\U0001F389 OAM Application
      monitoring cycle completed!\\\"\\necho \\\"Time: $(date)\\\"\\n\"],\"env\":[{\"name\":\"GITHUB_ORG\",\"valueFrom\":{\"secretKeyRef\":{\"key\":\"owner\",\"name\":\"github-analyzer-credentials\"}}},{\"name\":\"GITHUB_TOKEN\",\"valueFrom\":{\"secretKeyRef\":{\"key\":\"token\",\"name\":\"github-analyzer-credentials\"}}},{\"name\":\"DOCKER_REGISTRY\",\"value\":\"docker.io/socrates12345\"}],\"image\":\"bitnami/kubectl:latest\",\"name\":\"analyzer\",\"resources\":{\"limits\":{\"cpu\":\"500m\",\"memory\":\"512Mi\"},\"requests\":{\"cpu\":\"100m\",\"memory\":\"256Mi\"}}}],\"restartPolicy\":\"OnFailure\",\"serviceAccountName\":\"oam-application-analyzer\"}}}},\"schedule\":\"*/2
      * * * *\",\"successfulJobsHistoryLimit\":3}}}}},\"name\":\"vcluster-oam-analyzer-cronjob\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.providerConfigRef.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-vcluster\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.spec.jobTemplate.spec.template.spec.containers[0].env[0].value\",\"transforms\":[{\"string\":{\"fmt\":\"shlapolosa\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"kubernetes.crossplane.io/v1alpha1\",\"kind\":\"Object\",\"spec\":{\"forProvider\":{\"manifest\":{\"apiVersion\":\"networking.istio.io/v1beta1\",\"kind\":\"VirtualService\",\"metadata\":{\"name\":\"placeholder\",\"namespace\":\"placeholder\"},\"spec\":{\"gateways\":[\"placeholder\"],\"hosts\":[\"placeholder\"],\"http\":[{\"match\":[{\"uri\":{\"prefix\":\"/argocd\"}}],\"rewrite\":{\"uri\":\"/\"},\"route\":[{\"destination\":{\"host\":\"placeholder\",\"port\":{\"number\":80}}}]}]}}},\"providerConfigRef\":{\"name\":\"vcluster-provider\"}}},\"name\":\"vcluster-argocd-virtualservice\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-argocd-vs\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.metadata.namespace\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-argocd-vs\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.spec.hosts[0]\",\"transforms\":[{\"string\":{\"fmt\":\"%s-vcluster.local\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.spec.gateways[0]\",\"transforms\":[{\"string\":{\"fmt\":\"%s-gateway\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.manifest.spec.http[0].route[0].destination.host\",\"transforms\":[{\"string\":{\"fmt\":\"argocd-server.argocd.svc.cluster.local\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.components.argoCD\",\"toFieldPath\":\"metadata.labels[\\\"crossplane.io/enable\\\"]\",\"transforms\":[{\"map\":{\"false\":\"false\",\"true\":\"true\"},\"type\":\"map\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"apigatewayv2.aws.upbound.io/v1beta1\",\"kind\":\"API\",\"spec\":{\"forProvider\":{\"corsConfiguration\":[{\"allowCredentials\":false,\"allowHeaders\":[\"*\"],\"allowMethods\":[\"*\"],\"allowOrigins\":[\"*\"],\"exposeHeaders\":[\"*\"],\"maxAge\":86400}],\"description\":\"API
      Gateway for vCluster applications\",\"name\":\"placeholder\",\"protocolType\":\"HTTP\",\"tags\":{\"Environment\":\"vcluster\",\"ManagedBy\":\"crossplane\"}},\"providerConfigRef\":{\"name\":\"default\"}}},\"name\":\"vcluster-aws-api-gateway\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-api-gateway\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-api-gateway\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.tags.VCluster\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"status.atProvider.id\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"status.apiGateway.id\",\"type\":\"ToCompositeFieldPath\"},{\"fromFieldPath\":\"status.atProvider.apiEndpoint\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"status.apiGateway.endpoint\",\"type\":\"ToCompositeFieldPath\"},{\"fromFieldPath\":\"spec.components.apiGateway\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"spec.forProvider.tags.ComponentEnabled\",\"transforms\":[{\"convert\":{\"toType\":\"string\"},\"type\":\"convert\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"apigatewayv2.aws.upbound.io/v1beta1\",\"kind\":\"VPCLink\",\"spec\":{\"forProvider\":{\"name\":\"placeholder\",\"subnetIds\":[],\"tags\":{\"Environment\":\"vcluster\",\"Instructions\":\"Configure
      subnetIds via EnvironmentConfig or manual override\",\"ManagedBy\":\"crossplane\"}},\"providerConfigRef\":{\"name\":\"default\"}}},\"name\":\"vcluster-vpc-link\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-vpc-link\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-vpc-link\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.tags.VCluster\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"vpc.privateSubnetIds\",\"policy\":{\"fromFieldPath\":\"Required\"},\"toFieldPath\":\"spec.forProvider.subnetIds\",\"type\":\"FromEnvironmentFieldPath\"},{\"fromFieldPath\":\"status.atProvider.id\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"status.apiGateway.vpcLinkId\",\"type\":\"ToCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"apigatewayv2.aws.upbound.io/v1beta1\",\"kind\":\"Integration\",\"spec\":{\"forProvider\":{\"apiId\":\"placeholder\",\"connectionId\":\"placeholder\",\"connectionType\":\"VPC_LINK\",\"integrationMethod\":\"ANY\",\"integrationType\":\"HTTP_PROXY\",\"integrationUri\":\"placeholder\",\"payloadFormatVersion\":\"1.0\",\"timeoutMilliseconds\":29000},\"providerConfigRef\":{\"name\":\"default\"}}},\"name\":\"vcluster-api-integration\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-api-integration\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"status.apiGateway.id\",\"policy\":{\"fromFieldPath\":\"Required\"},\"toFieldPath\":\"spec.forProvider.apiId\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"status.apiGateway.vpcLinkId\",\"policy\":{\"fromFieldPath\":\"Required\"},\"toFieldPath\":\"spec.forProvider.connectionId\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.integrationUri\",\"transforms\":[{\"string\":{\"fmt\":\"http://%s-gateway.istio-system.svc.cluster.local\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"apigatewayv2.aws.upbound.io/v1beta1\",\"kind\":\"Route\",\"spec\":{\"forProvider\":{\"apiId\":\"placeholder\",\"routeKey\":\"ANY
      /{proxy+}\",\"target\":\"placeholder\"},\"providerConfigRef\":{\"name\":\"default\"}}},\"name\":\"vcluster-api-route\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-api-route\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"status.apiGateway.id\",\"policy\":{\"fromFieldPath\":\"Required\"},\"toFieldPath\":\"spec.forProvider.apiId\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.target\",\"transforms\":[{\"string\":{\"fmt\":\"integrations/%s-api-integration\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"}]},{\"base\":{\"apiVersion\":\"apigatewayv2.aws.upbound.io/v1beta1\",\"kind\":\"Stage\",\"spec\":{\"forProvider\":{\"apiId\":\"placeholder\",\"autoDeploy\":true,\"description\":\"Production
      stage for vCluster API Gateway\",\"name\":\"prod\",\"tags\":{\"Environment\":\"vcluster\",\"ManagedBy\":\"crossplane\"}},\"providerConfigRef\":{\"name\":\"default\"}}},\"name\":\"vcluster-api-stage\",\"patches\":[{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"metadata.name\",\"transforms\":[{\"string\":{\"fmt\":\"%s-api-stage\"},\"type\":\"string\"}],\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"status.apiGateway.id\",\"policy\":{\"fromFieldPath\":\"Required\"},\"toFieldPath\":\"spec.forProvider.apiId\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"spec.name\",\"toFieldPath\":\"spec.forProvider.tags.VCluster\",\"type\":\"FromCompositeFieldPath\"},{\"fromFieldPath\":\"status.atProvider.invokeUrl\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"status.apiGateway.endpoint\",\"type\":\"ToCompositeFieldPath\"},{\"fromFieldPath\":\"spec.forProvider.name\",\"policy\":{\"fromFieldPath\":\"Optional\"},\"toFieldPath\":\"status.apiGateway.stage\",\"type\":\"ToCompositeFieldPath\"}]}],\"writeConnectionSecretsToNamespace\":\"crossplane-system\"}}\n"
  creationTimestamp: "2025-07-10T14:44:57Z"
  generation: 2
  labels:
    crossplane.io/xrd: xvclusterenvironmentclaims.platform.example.org
    provider: helm-kubernetes
  name: vcluster-environment-claim-composition
  resourceVersion: "6555226"
  uid: bd136fd4-a44d-4300-ad45-29de34cac827
spec:
  compositeTypeRef:
    apiVersion: platform.example.org/v1alpha1
    kind: XVClusterEnvironmentClaim
  mode: Resources
  publishConnectionDetailsWithStoreConfigRef:
    name: default
  resources:
  - base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Namespace
            metadata:
              labels:
                vcluster.loft.sh/namespace: "true"
              name: placeholder
        providerConfigRef:
          name: default
    name: vcluster-namespace
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-namespace'
          type: Format
        type: string
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: helm.crossplane.io/v1beta1
      kind: Release
      spec:
        forProvider:
          chart:
            name: vcluster
            repository: https://charts.loft.sh
            version: 0.15.0
          namespace: placeholder
          skipCreateNamespace: true
          values:
            controlPlane:
              statefulSet:
                resources:
                  limits:
                    cpu: 1000m
                    memory: 2Gi
                  requests:
                    cpu: 200m
                    memory: 512Mi
            networking:
              advanced:
                proxyKubelets:
                  byHostname: false
                  byIP: false
            nodeSelector:
              eks.amazonaws.com/nodegroup: socrateshlapolosa-karpenter-demo-ng-medium
            rbac:
              clusterRole:
                create: true
            service:
              type: ClusterIP
            sync:
              fromHost:
                csiDrivers:
                  enabled: false
                csiStorageCapacities:
                  enabled: false
                nodes:
                  enabled: true
                  selector:
                    all: true
              toHost:
                persistentVolumes:
                  enabled: true
                priorityClasses:
                  enabled: true
                storageClasses:
                  enabled: true
        providerConfigRef:
          name: default
    name: vcluster-helm-release
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.namespace
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-vcluster'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.nameOverride
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.fullnameOverride
      transforms:
      - string:
          fmt: '%s-vcluster'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: status.atProvider.state
      policy:
        fromFieldPath: Optional
      toFieldPath: status.ready
      transforms:
      - map:
          deployed: true
          failed: false
        type: map
      type: ToCompositeFieldPath
    - fromFieldPath: spec.forProvider.namespace
      policy:
        fromFieldPath: Optional
      toFieldPath: status.clusterEndpoint.direct
      transforms:
      - string:
          fmt: https://%s-vcluster.%s.svc.cluster.local:443
          type: Format
        type: string
      type: ToCompositeFieldPath
    - fromFieldPath: metadata.name
      policy:
        fromFieldPath: Optional
      toFieldPath: status.adminCredentials.kubeconfig
      transforms:
      - string:
          fmt: 'Secret: %s-vcluster-connection in crossplane-system namespace'
          type: Format
        type: string
      type: ToCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: helm.crossplane.io/v1beta1
      kind: Release
      spec:
        forProvider:
          chart:
            name: crossplane
            repository: https://charts.crossplane.io/stable
            version: 1.14.0
          namespace: crossplane-system
          skipCreateNamespace: false
          values:
            args:
            - --debug
            - --enable-composition-revisions
            - --enable-environment-configs
            image:
              tag: v1.14.0
            metrics:
              enabled: true
            resourcesCrossplane:
              limits:
                cpu: 500m
                memory: 1Gi
              requests:
                cpu: 200m
                memory: 512Mi
            webhooks:
              enabled: true
        providerConfigRef:
          name: vcluster-provider
    name: vcluster-crossplane-install
    patches:
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-crossplane'
          type: Format
        type: string
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: apiextensions.crossplane.io/v1
            kind: CompositeResourceDefinition
            metadata:
              name: xappcontainerclaims.platform.example.org
            spec:
              claimNames:
                kind: AppContainerClaim
                plural: appcontainerclaims
              group: platform.example.org
              names:
                kind: XAppContainerClaim
                plural: xappcontainerclaims
              versions:
              - name: v1alpha1
                referenceable: true
                schema:
                  openAPIV3Schema:
                    properties:
                      spec:
                        description: AppContainerClaim specification for creating
                          application container infrastructure
                        properties:
                          description:
                            default: CLAUDE.md-compliant application container
                            description: Description of the application container
                            type: string
                          dockerRegistry:
                            default: docker.io/socrates12345
                            description: Docker registry for container images
                            type: string
                          enableObservability:
                            default: true
                            description: Whether to enable observability stack (Prometheus,
                              Grafana, Jaeger)
                            type: boolean
                          enableSecurity:
                            default: true
                            description: Whether to enable security scanning and policies
                            type: boolean
                          gitHubOrg:
                            default: socrates12345
                            description: GitHub organization where repositories will
                              be created
                            type: string
                          name:
                            description: Name of the application container (must be
                              DNS-1123 compliant)
                            maxLength: 63
                            pattern: ^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
                            type: string
                        required:
                        - name
                        type: object
                      status:
                        description: AppContainerClaim status
                        properties:
                          gitopsRepository:
                            description: GitOps repository information
                            properties:
                              branch:
                                description: Default branch name
                                type: string
                              cloneUrl:
                                description: Git clone URL
                                type: string
                              url:
                                description: GitOps repository URL
                                type: string
                            type: object
                          ready:
                            description: Indicates whether the app container is ready
                            type: boolean
                          sourceRepository:
                            description: Source repository information
                            properties:
                              branch:
                                description: Default branch name
                                type: string
                              cloneUrl:
                                description: Git clone URL
                                type: string
                              url:
                                description: Source repository URL
                                type: string
                            type: object
                        type: object
                    type: object
                served: true
        providerConfigRef:
          name: vcluster-provider
    name: vcluster-app-container-claim-xrd
    patches:
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-app-container-xrd'
          type: Format
        type: string
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: apiextensions.crossplane.io/v1
            kind: CompositeResourceDefinition
            metadata:
              name: xapplicationclaims.platform.example.org
            spec:
              claimNames:
                kind: ApplicationClaim
                plural: applicationclaims
              group: platform.example.org
              names:
                kind: XApplicationClaim
                plural: xapplicationclaims
              versions:
              - name: v1alpha1
                referenceable: true
                schema:
                  openAPIV3Schema:
                    properties:
                      spec:
                        description: ApplicationClaim specification
                        properties:
                          appContainer:
                            default: health-service-idp
                            description: Name of the AppContainer this microservice
                              belongs to
                            maxLength: 63
                            pattern: ^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
                            type: string
                          cache:
                            default: none
                            description: Cache type to provision for the application
                            enum:
                            - redis
                            - none
                            type: string
                          database:
                            default: none
                            description: Database type to provision for the application
                            enum:
                            - postgres
                            - none
                            type: string
                          exposeApi:
                            default: false
                            description: Whether to expose the API via AWS API Gateway
                            type: boolean
                          framework:
                            description: Application framework to use
                            enum:
                            - fastapi
                            - springboot
                            type: string
                          hasFrontend:
                            default: false
                            description: Whether the application includes a frontend
                              component
                            type: boolean
                          language:
                            description: Programming language for the application
                            enum:
                            - python
                            - java
                            type: string
                          name:
                            description: Name of the microservice (must be DNS-1123
                              compliant)
                            maxLength: 63
                            pattern: ^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
                            type: string
                        required:
                        - name
                        - language
                        - framework
                        type: object
                      status:
                        description: ApplicationClaim status
                        properties:
                          application:
                            description: Deployed application information
                            properties:
                              apiGatewayEndpoint:
                                description: AWS API Gateway endpoint if exposeApi
                                  is true
                                type: string
                              endpoint:
                                description: Application endpoint URL
                                type: string
                              knativeService:
                                description: Knative service name
                                type: string
                            type: object
                          ready:
                            description: Indicates whether the application is ready
                              and deployed
                            type: boolean
                          repository:
                            description: GitHub repository information
                            properties:
                              branch:
                                description: Default branch name
                                type: string
                              cloneUrl:
                                description: Git clone URL
                                type: string
                              url:
                                description: GitHub repository URL
                                type: string
                            type: object
                        type: object
                    type: object
                served: true
        providerConfigRef:
          name: vcluster-provider
    name: vcluster-application-claim-xrd
    patches:
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-app-claim-xrd'
          type: Format
        type: string
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: crossplane-system
            spec:
              template:
                spec:
                  containers:
                  - command:
                    - /bin/sh
                    - -c
                    - "set -e\necho \"Installing Crossplane Compositions in vCluster...\"\n\n#
                      Note: In a production environment, these compositions would
                      be\n# stored in a Git repository and applied via GitOps.\n#
                      For now, we're embedding them directly in the installer.\n\necho
                      \"âœ… AppContainerClaim and ApplicationClaim Compositions would
                      be installed here\"\necho \"\U0001F4CB TODO: Copy full compositions
                      from host cluster or Git repository\"\necho \"\U0001F527 For
                      now, vCluster will use the XRDs for API definitions\"\necho
                      \"\U0001F680 Users can apply compositions manually or via GitOps
                      after vCluster creation\"\n"
                    image: bitnami/kubectl:latest
                    name: composition-installer
                  nodeSelector:
                    eks.amazonaws.com/nodegroup: socrateshlapolosa-karpenter-demo-ng-medium
                  restartPolicy: OnFailure
                  serviceAccountName: crossplane-installer
        providerConfigRef:
          name: kubernetes-provider
    name: vcluster-composition-installer
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - string:
          fmt: '%s-composition-installer'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-composition-installer'
          type: Format
        type: string
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: crossplane-system
            spec:
              template:
                spec:
                  containers:
                  - command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      echo "Installing Crossplane Providers in vCluster..."

                      # Install GitHub Provider
                      kubectl apply -f - <<EOF
                      apiVersion: pkg.crossplane.io/v1
                      kind: Provider
                      metadata:
                        name: provider-github
                      spec:
                        package: xpkg.upbound.io/crossplane-contrib/provider-github:v0.7.0
                      ---
                      apiVersion: pkg.crossplane.io/v1
                      kind: Provider
                      metadata:
                        name: provider-kubernetes
                      spec:
                        package: xpkg.upbound.io/crossplane-contrib/provider-kubernetes:v0.10.0
                      ---
                      apiVersion: pkg.crossplane.io/v1
                      kind: Provider
                      metadata:
                        name: provider-helm
                      spec:
                        package: xpkg.upbound.io/crossplane-contrib/provider-helm:v0.16.0
                      EOF

                      # Wait for providers to be healthy
                      echo "Waiting for providers to be healthy..."
                      kubectl wait --for=condition=Healthy provider/provider-github --timeout=300s || true
                      kubectl wait --for=condition=Healthy provider/provider-kubernetes --timeout=300s || true
                      kubectl wait --for=condition=Healthy provider/provider-helm --timeout=300s || true

                      echo "Crossplane Providers installed successfully"
                    image: bitnami/kubectl:latest
                    name: provider-installer
                  nodeSelector:
                    eks.amazonaws.com/nodegroup: socrateshlapolosa-karpenter-demo-ng-medium
                  restartPolicy: OnFailure
                  serviceAccountName: crossplane-installer
        providerConfigRef:
          name: kubernetes-provider
    name: vcluster-crossplane-providers
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - string:
          fmt: '%s-provider-installer'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-provider-installer'
          type: Format
        type: string
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: ServiceAccount
            metadata:
              name: vcluster-admin
              namespace: placeholder
        providerConfigRef:
          name: default
    name: vcluster-admin-sa
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-admin-sa'
          type: Format
        type: string
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRoleBinding
            metadata:
              name: placeholder
            roleRef:
              apiGroup: rbac.authorization.k8s.io
              kind: ClusterRole
              name: cluster-admin
            subjects:
            - kind: ServiceAccount
              name: vcluster-admin
              namespace: placeholder
        providerConfigRef:
          name: default
    name: vcluster-admin-crb
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - string:
          fmt: '%s-admin-crb'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.subjects[0].namespace
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-admin-crb'
          type: Format
        type: string
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: networking.istio.io/v1beta1
            kind: Gateway
            metadata:
              name: placeholder
              namespace: placeholder
            spec:
              selector:
                istio: ingressgateway
              servers:
              - hosts:
                - placeholder
                port:
                  name: http
                  number: 80
                  protocol: HTTP
              - hosts:
                - placeholder
                port:
                  name: https
                  number: 443
                  protocol: HTTPS
                tls:
                  credentialName: vcluster-tls-secret
                  mode: SIMPLE
        providerConfigRef:
          name: default
    name: vcluster-istio-gateway
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - string:
          fmt: '%s-gateway'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-gateway'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.domain
      policy:
        fromFieldPath: Optional
      toFieldPath: spec.forProvider.manifest.spec.servers[0].hosts[0]
      type: FromCompositeFieldPath
    - fromFieldPath: spec.domain
      policy:
        fromFieldPath: Optional
      toFieldPath: spec.forProvider.manifest.spec.servers[1].hosts[0]
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      policy:
        fromFieldPath: Optional
      toFieldPath: spec.forProvider.manifest.spec.servers[0].hosts[0]
      transforms:
      - string:
          fmt: '%s-vcluster.local'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      policy:
        fromFieldPath: Optional
      toFieldPath: spec.forProvider.manifest.spec.servers[1].hosts[0]
      transforms:
      - string:
          fmt: '%s-vcluster.local'
          type: Format
        type: string
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: networking.istio.io/v1beta1
            kind: VirtualService
            metadata:
              name: placeholder
              namespace: placeholder
            spec:
              gateways:
              - placeholder
              hosts:
              - placeholder
              http:
              - match:
                - uri:
                    prefix: /
                route:
                - destination:
                    host: placeholder
                    port:
                      number: 443
        providerConfigRef:
          name: default
    name: vcluster-istio-virtualservice
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - string:
          fmt: '%s-virtualservice'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-virtualservice'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.gateways[0]
      transforms:
      - string:
          fmt: '%s-gateway'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.domain
      policy:
        fromFieldPath: Optional
      toFieldPath: spec.forProvider.manifest.spec.hosts[0]
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      policy:
        fromFieldPath: Optional
      toFieldPath: spec.forProvider.manifest.spec.hosts[0]
      transforms:
      - string:
          fmt: '%s-vcluster.local'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.http[0].route[0].destination.host
      transforms:
      - string:
          fmt: '%s-vcluster'
          type: Format
        type: string
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: placeholder
            spec:
              template:
                spec:
                  containers:
                  - command:
                    - /bin/bash
                    - -c
                    - |
                      set -e
                      echo "Waiting for vCluster to be ready..."
                      sleep 60

                      VCLUSTER_NAME=$(echo $HOSTNAME | cut -d'-' -f1-2)  # Extract from job name
                      NAMESPACE=$VCLUSTER_NAME

                      echo "Creating connection secret for vCluster: $VCLUSTER_NAME in namespace: $NAMESPACE"

                      # Wait for vCluster service to be ready
                      kubectl wait --for=condition=ready pod -l app=vcluster -n $NAMESPACE --timeout=300s || echo "Warning: Pod wait timeout"

                      # Get service account token
                      TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)

                      # Create kubeconfig
                      cat << EOF > /tmp/kubeconfig
                      apiVersion: v1
                      kind: Config
                      clusters:
                      - cluster:
                          server: https://${VCLUSTER_NAME}-vcluster.${NAMESPACE}.svc.cluster.local:443
                          insecure-skip-tls-verify: true
                        name: ${VCLUSTER_NAME}
                      contexts:
                      - context:
                          cluster: ${VCLUSTER_NAME}
                          user: ${VCLUSTER_NAME}-admin
                        name: ${VCLUSTER_NAME}
                      current-context: ${VCLUSTER_NAME}
                      users:
                      - name: ${VCLUSTER_NAME}-admin
                        user:
                          token: ${TOKEN}
                      EOF

                      # Encode data
                      KUBECONFIG_B64=$(cat /tmp/kubeconfig | base64 -w 0)
                      ENDPOINT_B64=$(echo -n "https://${VCLUSTER_NAME}-vcluster.${NAMESPACE}.svc.cluster.local:443" | base64 -w 0)
                      TOKEN_B64=$(echo -n ${TOKEN} | base64 -w 0)

                      # Create connection secret
                      cat << EOF | kubectl apply -f -
                      apiVersion: v1
                      kind: Secret
                      metadata:
                        name: ${VCLUSTER_NAME}-vcluster-connection
                        namespace: crossplane-system
                        labels:
                          crossplane.io/connection-secret: "true"
                          vcluster.name: "${VCLUSTER_NAME}"
                      type: connection.crossplane.io/v1alpha1
                      data:
                        kubeconfig: ${KUBECONFIG_B64}
                        endpoint: ${ENDPOINT_B64}
                        token: ${TOKEN_B64}
                      EOF

                      # TODO: Add AWS Secrets Manager integration here
                      # AWS CLI commands to create/update AWS secret with connection details
                      # aws secretsmanager create-secret --name "vcluster/${VCLUSTER_NAME}/connection" \
                      #   --secret-string "{\"kubeconfig\":\"$(cat /tmp/kubeconfig | base64)\",\"endpoint\":\"https://${VCLUSTER_NAME}-vcluster.${NAMESPACE}.svc.cluster.local:443\"}"

                      echo "Connection secret created successfully: ${VCLUSTER_NAME}-vcluster-connection"
                    image: bitnami/kubectl:latest
                    name: kubeconfig-extractor
                  nodeSelector:
                    eks.amazonaws.com/nodegroup: socrateshlapolosa-karpenter-demo-ng-medium
                  restartPolicy: OnFailure
                  serviceAccountName: vcluster-admin
        providerConfigRef:
          name: default
    name: vcluster-kubeconfig-job
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - string:
          fmt: '%s-kubeconfig-job'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-kubeconfig-job'
          type: Format
        type: string
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: placeholder
            spec:
              template:
                spec:
                  containers:
                  - command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      echo "Installing Istio in vCluster..."

                      # Install Istio with minimal profile for cost optimization
                      istioctl install --set values.pilot.resources.requests.cpu=100m \
                        --set values.pilot.resources.requests.memory=128Mi \
                        --set values.pilot.resources.limits.cpu=500m \
                        --set values.pilot.resources.limits.memory=256Mi \
                        --set values.global.proxy.resources.requests.cpu=50m \
                        --set values.global.proxy.resources.requests.memory=64Mi \
                        --set values.global.proxy.resources.limits.cpu=200m \
                        --set values.global.proxy.resources.limits.memory=128Mi \
                        --set values.pilot.env.PILOT_ENABLE_KNATIVE_GATEWAY_API=true \
                        -y

                      # Wait for Istio to be ready
                      kubectl wait --for=condition=Ready pod -l app=istiod -n istio-system --timeout=300s

                      echo "Istio installed successfully in vCluster"
                    image: istio/istioctl:1.19.0
                    name: istio-installer
                  nodeSelector:
                    eks.amazonaws.com/nodegroup: socrateshlapolosa-karpenter-demo-ng-medium
                  restartPolicy: OnFailure
                  serviceAccountName: vcluster-admin
        providerConfigRef:
          name: vcluster-provider
    name: vcluster-istio
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - string:
          fmt: '%s-istio-installer'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-istio'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: status.atProvider.manifest.status.succeeded
      policy:
        fromFieldPath: Optional
      toFieldPath: status.components.istio.ready
      transforms:
      - map:
          "0": false
          "1": true
        type: map
      type: ToCompositeFieldPath
    - fromFieldPath: spec.name
      policy:
        fromFieldPath: Optional
      toFieldPath: status.components.istio.endpoint
      transforms:
      - string:
          fmt: http://istio-ingressgateway.istio-system.%s.svc.cluster.local
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.components.istio
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - map:
          "false": "false"
          "true": "true"
        type: map
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: placeholder
            spec:
              template:
                spec:
                  containers:
                  - command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      echo "Installing Knative Serving in vCluster..."

                      # Install Knative Serving CRDs
                      kubectl apply -f https://github.com/knative/serving/releases/download/knative-v1.12.0/serving-crds.yaml

                      # Wait for CRDs
                      kubectl wait --for condition=established --timeout=60s crd/services.serving.knative.dev

                      # Install Knative Serving Core
                      kubectl apply -f https://github.com/knative/serving/releases/download/knative-v1.12.0/serving-core.yaml

                      # Install Knative Istio Networking
                      kubectl apply -f https://github.com/knative/net-istio/releases/download/knative-v1.12.0/net-istio.yaml

                      # Wait for Knative components
                      kubectl wait --for=condition=Ready pod -l app=controller -n knative-serving --timeout=300s
                      kubectl wait --for=condition=Ready pod -l app=activator -n knative-serving --timeout=300s
                      kubectl wait --for=condition=Ready pod -l app=autoscaler -n knative-serving --timeout=300s
                      kubectl wait --for=condition=Ready pod -l app=webhook -n knative-serving --timeout=300s

                      # Apply cost-optimized configuration
                      cat <<EOF | kubectl apply -f -
                      apiVersion: v1
                      kind: ConfigMap
                      metadata:
                        name: config-autoscaler
                        namespace: knative-serving
                      data:
                        enable-scale-to-zero: "true"
                        scale-to-zero-grace-period: "30s"
                        scale-to-zero-pod-retention-period: "2m"
                        min-scale: "0"
                        max-scale: "5"
                        initial-scale: "0"
                        allow-zero-initial-scale: "true"
                        max-scale-up-rate: "5.0"
                        max-scale-down-rate: "2.0"
                        container-concurrency-target-default: "50"
                        container-concurrency-target-percentage: "70"
                        target-burst-capacity: "100"
                        activator-capacity: "50"
                        concurrency-state-endpoint: "/health"
                      ---
                      apiVersion: v1
                      kind: ConfigMap
                      metadata:
                        name: config-defaults
                        namespace: knative-serving
                      data:
                        revision-cpu-request: "100m"
                        revision-memory-request: "128Mi"
                        revision-cpu-limit: "500m"
                        revision-memory-limit: "256Mi"
                        container-concurrency: "50"
                        revision-timeout-seconds: "300"
                      ---
                      apiVersion: v1
                      kind: ConfigMap
                      metadata:
                        name: config-network
                        namespace: knative-serving
                      data:
                        ingress-class: "istio.ingress.networking.knative.dev"
                        domain-template: "{{.Name}}.{{.Namespace}}.svc.cluster.local"
                        default-timeout: "300s"
                        max-timeout: "600s"
                        default-visibility: "cluster-local"
                      EOF

                      echo "Knative Serving installed successfully with cost optimization"
                    image: bitnami/kubectl:latest
                    name: knative-installer
                  nodeSelector:
                    eks.amazonaws.com/nodegroup: socrateshlapolosa-karpenter-demo-ng-medium
                  restartPolicy: OnFailure
                  serviceAccountName: vcluster-admin
        providerConfigRef:
          name: vcluster-provider
    name: vcluster-knative-serving
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - string:
          fmt: '%s-knative-installer'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-knative'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: status.atProvider.manifest.status.succeeded
      policy:
        fromFieldPath: Optional
      toFieldPath: status.components.knativeServing.ready
      transforms:
      - map:
          "0": false
          "1": true
        type: map
      type: ToCompositeFieldPath
    - fromFieldPath: spec.name
      policy:
        fromFieldPath: Optional
      toFieldPath: status.components.knativeServing.endpoint
      transforms:
      - string:
          fmt: http://istio-ingressgateway.istio-system.%s.svc.cluster.local
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.components.knativeServing
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - map:
          "false": "false"
          "true": "true"
        type: map
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: argoproj.io/v1alpha1
            kind: Application
            metadata:
              name: placeholder
              namespace: placeholder
            spec:
              destination:
                namespace: argocd
                server: https://kubernetes.default.svc
              project: default
              source:
                chart: argo-cd
                helm:
                  values: |
                    server:
                      service:
                        type: ClusterIP
                      ingress:
                        enabled: false
                    configs:
                      params:
                        server.insecure: true
                repoURL: https://argoproj.github.io/argo-helm
                targetRevision: 5.46.8
              syncPolicy:
                automated:
                  prune: true
                  selfHeal: true
                syncOptions:
                - CreateNamespace=true
        providerConfigRef:
          name: default
    name: vcluster-argocd
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - string:
          fmt: '%s-argocd'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-argocd'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: status.atProvider.manifest.status.health.status
      policy:
        fromFieldPath: Optional
      toFieldPath: status.components.argoCD.ready
      transforms:
      - map:
          Degraded: false
          Healthy: true
        type: map
      type: ToCompositeFieldPath
    - fromFieldPath: spec.forProvider.manifest.metadata.namespace
      policy:
        fromFieldPath: Optional
      toFieldPath: status.components.argoCD.endpoint
      transforms:
      - string:
          fmt: http://argocd-server.%s.svc.cluster.local:80
          type: Format
        type: string
      type: ToCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: helm.crossplane.io/v1beta1
      kind: Release
      spec:
        forProvider:
          chart:
            name: grafana
            repository: https://grafana.github.io/helm-charts
            version: 7.0.3
          namespace: placeholder
          skipCreateNamespace: false
          values:
            adminPassword: admin123
            dashboardProviders:
              dashboardproviders.yaml:
                apiVersion: 1
                providers:
                - disableDeletion: false
                  editable: true
                  folder: ""
                  name: default
                  options:
                    path: /var/lib/grafana/dashboards/default
                  orgId: 1
                  type: file
            dashboards:
              default:
                istio-mesh:
                  datasource: Prometheus
                  gnetId: 7639
                  revision: 173
                istio-service:
                  datasource: Prometheus
                  gnetId: 7636
                  revision: 173
                istio-workload:
                  datasource: Prometheus
                  gnetId: 7630
                  revision: 173
                knative-serving:
                  datasource: Prometheus
                  gnetId: 17175
                  revision: 3
                kubernetes-cluster:
                  datasource: Prometheus
                  gnetId: 15757
                  revision: 31
                kubernetes-pods:
                  datasource: Prometheus
                  gnetId: 15760
                  revision: 20
            datasources:
              datasources.yaml:
                apiVersion: 1
                datasources:
                - access: proxy
                  isDefault: true
                  name: Prometheus
                  type: prometheus
                  url: http://kube-prometheus-stack-prometheus:9090
                - access: proxy
                  name: Jaeger
                  type: jaeger
                  url: http://jaeger-query:16686
            persistence:
              enabled: false
            resources:
              limits:
                cpu: 500m
                memory: 512Mi
              requests:
                cpu: 100m
                memory: 256Mi
            service:
              type: ClusterIP
        providerConfigRef:
          name: vcluster-provider
    name: vcluster-grafana
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.namespace
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-grafana'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.datasources.datasources\.yaml.datasources[0].url
      transforms:
      - string:
          fmt: http://kube-prometheus-stack-prometheus.%s.svc.cluster.local:9090
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.datasources.datasources\.yaml.datasources[1].url
      transforms:
      - string:
          fmt: http://jaeger-query.%s.svc.cluster.local:16686
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: status.atProvider.state
      policy:
        fromFieldPath: Optional
      toFieldPath: status.components.grafana.ready
      transforms:
      - map:
          deployed: true
          failed: false
        type: map
      type: ToCompositeFieldPath
    - fromFieldPath: spec.forProvider.namespace
      policy:
        fromFieldPath: Optional
      toFieldPath: status.components.grafana.endpoint
      transforms:
      - string:
          fmt: http://grafana.%s.svc.cluster.local:80
          type: Format
        type: string
      type: ToCompositeFieldPath
    - fromFieldPath: spec.components.grafana
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - map:
          "false": "false"
          "true": "true"
        type: map
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: helm.crossplane.io/v1beta1
      kind: Release
      spec:
        forProvider:
          chart:
            name: kube-prometheus-stack
            repository: https://prometheus-community.github.io/helm-charts
            version: 54.0.1
          namespace: placeholder
          skipCreateNamespace: false
          values:
            alertmanager:
              enabled: false
            grafana:
              enabled: false
            prometheus:
              prometheusSpec:
                additionalScrapeConfigs:
                - job_name: kubernetes-pods
                  kubernetes_sd_configs:
                  - role: pod
                  relabel_configs:
                  - action: keep
                    regex: true
                    source_labels:
                    - __meta_kubernetes_pod_annotation_prometheus_io_scrape
                  - action: replace
                    regex: (.+)
                    source_labels:
                    - __meta_kubernetes_pod_annotation_prometheus_io_path
                    target_label: __metrics_path__
                  - action: replace
                    regex: ([^:]+)(?::\d+)?;(\d+)
                    replacement: $1:$2
                    source_labels:
                    - __address__
                    - __meta_kubernetes_pod_annotation_prometheus_io_port
                    target_label: __address__
                - job_name: istio-mesh
                  kubernetes_sd_configs:
                  - namespaces:
                      names:
                      - istio-system
                    role: endpoints
                  relabel_configs:
                  - action: keep
                    regex: istio-proxy;.*
                    source_labels:
                    - __meta_kubernetes_service_name
                    - __meta_kubernetes_endpoint_port_name
                - job_name: knative-serving
                  kubernetes_sd_configs:
                  - namespaces:
                      names:
                      - knative-serving
                    role: endpoints
                  relabel_configs:
                  - action: keep
                    regex: (activator|autoscaler|controller|webhook)
                    source_labels:
                    - __meta_kubernetes_service_name
                resources:
                  limits:
                    cpu: 1000m
                    memory: 1Gi
                  requests:
                    cpu: 200m
                    memory: 512Mi
              service:
                type: ClusterIP
        providerConfigRef:
          name: vcluster-provider
    name: vcluster-prometheus
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.namespace
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-prometheus'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: status.atProvider.state
      policy:
        fromFieldPath: Optional
      toFieldPath: status.components.prometheus.ready
      transforms:
      - map:
          deployed: true
          failed: false
        type: map
      type: ToCompositeFieldPath
    - fromFieldPath: spec.forProvider.namespace
      policy:
        fromFieldPath: Optional
      toFieldPath: status.components.prometheus.endpoint
      transforms:
      - string:
          fmt: http://kube-prometheus-stack-prometheus.%s.svc.cluster.local:9090
          type: Format
        type: string
      type: ToCompositeFieldPath
    - fromFieldPath: spec.components.prometheus
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - map:
          "false": "false"
          "true": "true"
        type: map
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: helm.crossplane.io/v1beta1
      kind: Release
      spec:
        forProvider:
          chart:
            name: jaeger
            repository: https://jaegertracing.github.io/helm-charts
            version: 0.71.11
          namespace: placeholder
          skipCreateNamespace: false
          values:
            agent:
              resources:
                limits:
                  cpu: 200m
                  memory: 256Mi
                requests:
                  cpu: 50m
                  memory: 128Mi
            allInOne:
              enabled: true
              image: jaegertracing/all-in-one:1.49
              options:
                log-level: info
                memory.max-traces: 10000
              resources:
                limits:
                  cpu: 1000m
                  memory: 1Gi
                requests:
                  cpu: 200m
                  memory: 512Mi
            collector:
              resources:
                limits:
                  cpu: 500m
                  memory: 512Mi
                requests:
                  cpu: 100m
                  memory: 256Mi
              service:
                type: ClusterIP
            query:
              resources:
                limits:
                  cpu: 500m
                  memory: 512Mi
                requests:
                  cpu: 100m
                  memory: 256Mi
              service:
                type: ClusterIP
        providerConfigRef:
          name: vcluster-provider
    name: vcluster-jaeger
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.namespace
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-jaeger'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: status.atProvider.state
      policy:
        fromFieldPath: Optional
      toFieldPath: status.components.jaeger.ready
      transforms:
      - map:
          deployed: true
          failed: false
        type: map
      type: ToCompositeFieldPath
    - fromFieldPath: spec.forProvider.namespace
      policy:
        fromFieldPath: Optional
      toFieldPath: status.components.jaeger.endpoint
      transforms:
      - string:
          fmt: http://jaeger-query.%s.svc.cluster.local:16686
          type: Format
        type: string
      type: ToCompositeFieldPath
    - fromFieldPath: spec.components.jaeger
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - map:
          "false": "false"
          "true": "true"
        type: map
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: helm.crossplane.io/v1beta1
      kind: Release
      spec:
        forProvider:
          chart:
            name: kiali-server
            repository: https://kiali.org/helm-charts
            version: 1.76.0
          namespace: placeholder
          skipCreateNamespace: false
          values:
            auth:
              strategy: anonymous
            external_services:
              prometheus:
                url: http://prometheus-server.monitoring.svc.cluster.local:80
            service:
              type: ClusterIP
        providerConfigRef:
          name: default
    name: vcluster-kiali
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.namespace
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-kiali'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: status.atProvider.state
      policy:
        fromFieldPath: Optional
      toFieldPath: status.components.kiali.ready
      transforms:
      - map:
          deployed: true
          failed: false
        type: map
      type: ToCompositeFieldPath
    - fromFieldPath: spec.forProvider.namespace
      policy:
        fromFieldPath: Optional
      toFieldPath: status.components.kiali.endpoint
      transforms:
      - string:
          fmt: http://kiali.%s.svc.cluster.local:20001
          type: Format
        type: string
      type: ToCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: networking.istio.io/v1beta1
            kind: VirtualService
            metadata:
              name: placeholder
              namespace: placeholder
            spec:
              gateways:
              - placeholder
              hosts:
              - placeholder
              http:
              - match:
                - uri:
                    prefix: /prometheus
                rewrite:
                  uri: /
                route:
                - destination:
                    host: placeholder
                    port:
                      number: 9090
        providerConfigRef:
          name: vcluster-provider
    name: vcluster-prometheus-virtualservice
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - string:
          fmt: '%s-prometheus-vs'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-prometheus-vs'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.hosts[0]
      transforms:
      - string:
          fmt: '%s-vcluster.local'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.gateways[0]
      transforms:
      - string:
          fmt: '%s-gateway'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.http[0].route[0].destination.host
      transforms:
      - string:
          fmt: kube-prometheus-stack-prometheus.%s.svc.cluster.local
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.components.prometheus
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - map:
          "false": "false"
          "true": "true"
        type: map
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: networking.istio.io/v1beta1
            kind: VirtualService
            metadata:
              name: placeholder
              namespace: placeholder
            spec:
              gateways:
              - placeholder
              hosts:
              - placeholder
              http:
              - match:
                - uri:
                    prefix: /grafana
                rewrite:
                  uri: /
                route:
                - destination:
                    host: placeholder
                    port:
                      number: 80
        providerConfigRef:
          name: vcluster-provider
    name: vcluster-grafana-virtualservice
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - string:
          fmt: '%s-grafana-vs'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-grafana-vs'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.hosts[0]
      transforms:
      - string:
          fmt: '%s-vcluster.local'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.gateways[0]
      transforms:
      - string:
          fmt: '%s-gateway'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.http[0].route[0].destination.host
      transforms:
      - string:
          fmt: grafana.%s.svc.cluster.local
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.components.grafana
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - map:
          "false": "false"
          "true": "true"
        type: map
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: networking.istio.io/v1beta1
            kind: VirtualService
            metadata:
              name: placeholder
              namespace: placeholder
            spec:
              gateways:
              - placeholder
              hosts:
              - placeholder
              http:
              - match:
                - uri:
                    prefix: /jaeger
                rewrite:
                  uri: /
                route:
                - destination:
                    host: placeholder
                    port:
                      number: 16686
        providerConfigRef:
          name: vcluster-provider
    name: vcluster-jaeger-virtualservice
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - string:
          fmt: '%s-jaeger-vs'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-jaeger-vs'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.hosts[0]
      transforms:
      - string:
          fmt: '%s-vcluster.local'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.gateways[0]
      transforms:
      - string:
          fmt: '%s-gateway'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.http[0].route[0].destination.host
      transforms:
      - string:
          fmt: jaeger-query.%s.svc.cluster.local
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.components.jaeger
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - map:
          "false": "false"
          "true": "true"
        type: map
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: networking.istio.io/v1beta1
            kind: VirtualService
            metadata:
              name: placeholder
              namespace: placeholder
            spec:
              gateways:
              - placeholder
              hosts:
              - placeholder
              http:
              - match:
                - uri:
                    prefix: /kiali
                rewrite:
                  uri: /
                route:
                - destination:
                    host: placeholder
                    port:
                      number: 20001
        providerConfigRef:
          name: vcluster-provider
    name: vcluster-kiali-virtualservice
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - string:
          fmt: '%s-kiali-vs'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-kiali-vs'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.hosts[0]
      transforms:
      - string:
          fmt: '%s-vcluster.local'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.gateways[0]
      transforms:
      - string:
          fmt: '%s-gateway'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.http[0].route[0].destination.host
      transforms:
      - string:
          fmt: kiali.%s.svc.cluster.local
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.components.kiali
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - map:
          "false": "false"
          "true": "true"
        type: map
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            data:
              owner: c2hsYXBvbG9zYQ==
              token: Z2hwX1JHbWtQVFBlcmo5d0pxaTdvcndEbFo2SHlwWHlQZjA2b051Ug==
            kind: Secret
            metadata:
              name: github-analyzer-credentials
              namespace: oam-analyzer-system
            type: Opaque
    name: vcluster-github-secret-copy
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.providerConfigRef.name
      transforms:
      - string:
          fmt: '%s-vcluster'
          type: Format
        type: string
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Namespace
            metadata:
              labels:
                managed-by: crossplane
                name: oam-analyzer-system
              name: oam-analyzer-system
    name: vcluster-oam-analyzer-namespace
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      transforms:
      - string:
          fmt: '%s'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.providerConfigRef.name
      transforms:
      - string:
          fmt: '%s-vcluster'
          type: Format
        type: string
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            items:
            - apiVersion: v1
              kind: ServiceAccount
              metadata:
                name: oam-application-analyzer
                namespace: oam-analyzer-system
            - apiVersion: rbac.authorization.k8s.io/v1
              kind: ClusterRole
              metadata:
                name: oam-application-analyzer
              rules:
              - apiGroups:
                - core.oam.dev
                resources:
                - applications
                - components
                verbs:
                - get
                - list
                - watch
                - create
                - update
                - patch
              - apiGroups:
                - platform.example.org
                resources:
                - applicationclaims
                - appcontainerclaims
                verbs:
                - get
                - list
                - watch
                - create
                - update
                - patch
              - apiGroups:
                - ""
                resources:
                - configmaps
                - secrets
                - namespaces
                verbs:
                - get
                - list
                - watch
              - apiGroups:
                - ""
                resources:
                - events
                verbs:
                - create
              - apiGroups:
                - apiextensions.k8s.io
                resources:
                - customresourcedefinitions
                verbs:
                - get
                - list
            - apiVersion: rbac.authorization.k8s.io/v1
              kind: ClusterRoleBinding
              metadata:
                name: oam-application-analyzer
              roleRef:
                apiGroup: rbac.authorization.k8s.io
                kind: ClusterRole
                name: oam-application-analyzer
              subjects:
              - kind: ServiceAccount
                name: oam-application-analyzer
                namespace: oam-analyzer-system
            kind: List
    name: vcluster-oam-analyzer-rbac
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.providerConfigRef.name
      transforms:
      - string:
          fmt: '%s-vcluster'
          type: Format
        type: string
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            data:
              config.yaml: "analyzer:\n  # Enable automatic infrastructure creation\n
                \ autoCreateRepos: true\n  autoCreateDatabases: true\n  autoCreateCaches:
                true\n  autoCreateAppContainers: true\n  \n  # Reconciliation settings\n
                \ reconcileInterval: \"30s\"\n  maxRetries: 3\n  \ninference:\n  #
                Default language and framework for new services\n  defaultLanguage:
                \"python\"\n  defaultFramework: \"fastapi\"\n  \n  # Language detection
                hints\n  languageHints:\n    # Environment variable hints\n    - type:
                \"env\"\n      key: \"PYTHONPATH\"\n      language: \"python\"\n      framework:
                \"fastapi\"\n    - type: \"env\"\n      key: \"JAVA_OPTS\"\n      language:
                \"java\"\n      framework: \"springboot\"\n    - type: \"env\"\n      key:
                \"NODE_PATH\"\n      language: \"nodejs\"\n      framework: \"express\"\n
                \     \n    # Port-based hints\n    - type: \"port\"\n      value:
                \"8080\"\n      language: \"java\"\n      framework: \"springboot\"\n
                \   - type: \"port\"\n      value: \"8000\"\n      language: \"python\"\n
                \     framework: \"fastapi\"\n    - type: \"port\"\n      value: \"3000\"\n
                \     language: \"nodejs\"\n      framework: \"express\"\n      \nrepositories:\n
                \ # GitHub organization for new repositories\n  organization: \"shlapolosa\"\n
                \ \n  # Docker registry for container images\n  registry: \"docker.io/socrates12345\"\n
                \ \ndatabases:\n  # Default database type\n  defaultType: \"postgres\"\n
                \ \ncaches:\n  # Default cache type\n  defaultType: \"redis\"\n  \nlogging:\n
                \ level: \"info\"\n  format: \"json\"\n"
            kind: ConfigMap
            metadata:
              name: oam-analyzer-config
              namespace: oam-analyzer-system
    name: vcluster-oam-analyzer-config
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.providerConfigRef.name
      transforms:
      - string:
          fmt: '%s-vcluster'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.labels["github-org"]
      transforms:
      - string:
          fmt: socrates12345
          type: Format
        type: string
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: CronJob
            metadata:
              name: oam-application-analyzer
              namespace: oam-analyzer-system
            spec:
              failedJobsHistoryLimit: 1
              jobTemplate:
                spec:
                  template:
                    spec:
                      containers:
                      - command:
                        - /bin/bash
                        - -c
                        - "set -e\n\n# Install curl for GitHub API calls\napt-get
                          update && apt-get install -y curl\n\necho \"\U0001F50D OAM
                          Application Infrastructure Analyzer\"\necho \"Time: $(date)\"\necho
                          \"==========================================\"\n\n# Function
                          to check if a GitHub repository exists\ncheck_github_repo()
                          {\n  local repo_name=\"$1\"\n  local org=\"${GITHUB_ORG:-shlapolosa}\"\n
                          \ \n  echo \"\U0001F50D Checking if GitHub repo exists:
                          $org/$repo_name\"\n  \n  if [ -n \"$GITHUB_TOKEN\" ]; then\n
                          \   # Use GitHub API to check if repository exists\n    local
                          response_code=$(curl -s -o /dev/null -w \"%{http_code}\"
                          \\\n      -H \"Authorization: token $GITHUB_TOKEN\" \\\n
                          \     -H \"Accept: application/vnd.github.v3+json\" \\\n
                          \     \"https://api.github.com/repos/$org/$repo_name\")\n
                          \   \n    if [ \"$response_code\" = \"200\" ]; then\n      echo
                          \"âœ… Repository $org/$repo_name exists\"\n      return 0\n
                          \   elif [ \"$response_code\" = \"404\" ]; then\n      echo
                          \"â„¹ï¸  Repository $org/$repo_name does not exist\"\n      return
                          1\n    else\n      echo \"âš ï¸  API error checking repository
                          (HTTP $response_code), assuming it doesn't exist\"\n      return
                          1\n    fi\n  else\n    echo \"âš ï¸  No GitHub token available,
                          assuming repo does not exist\"\n    return 1\n  fi\n}\n\n#
                          Function to infer language from component properties\ninfer_language_framework()
                          {\n  local component_yaml=\"$1\"\n  local service_name=\"$2\"\n
                          \ \n  local language=\"python\"\n  local framework=\"fastapi\"\n
                          \ \n  # Check environment variables for language hints\n
                          \ if echo \"$component_yaml\" | grep -A 20 \"name: $service_name\"
                          | grep -q \"JAVA_OPTS\\|SERVER_PORT.*8080\"; then\n    language=\"java\"\n
                          \   framework=\"springboot\"\n  elif echo \"$component_yaml\"
                          | grep -A 20 \"name: $service_name\" | grep -q \"NODE_ENV\\|NODE_PATH\";
                          then\n    language=\"nodejs\"\n    framework=\"express\"\n
                          \ elif echo \"$component_yaml\" | grep -A 20 \"name: $service_name\"
                          | grep -q \"PYTHONPATH\"; then\n    language=\"python\"\n
                          \   framework=\"fastapi\"\n  fi\n  \n  # Check image names
                          for language hints\n  local image_name=$(echo \"$component_yaml\"
                          | grep -A 10 \"name: $service_name\" | grep \"image:\" |
                          head -1 | awk '{print $2}' | tr -d '\"')\n  if [[ \"$image_name\"
                          == *\"java\"* ]] || [[ \"$image_name\" == *\"spring\"* ]];
                          then\n    language=\"java\"\n    framework=\"springboot\"\n
                          \ elif [[ \"$image_name\" == *\"python\"* ]] || [[ \"$image_name\"
                          == *\"fastapi\"* ]]; then\n    language=\"python\"\n    framework=\"fastapi\"\n
                          \ elif [[ \"$image_name\" == *\"node\"* ]]; then\n    language=\"nodejs\"\n
                          \   framework=\"express\"\n  fi\n  \n  # Check port numbers
                          for additional hints\n  local port=$(echo \"$component_yaml\"
                          | grep -A 20 \"name: $service_name\" | grep -E \"port:|PORT\"
                          | head -1 | grep -o '[0-9]\\+')\n  if [[ \"$port\" == \"8080\"
                          ]]; then\n    language=\"java\"\n    framework=\"springboot\"\n
                          \ elif [[ \"$port\" == \"8000\" ]]; then\n    language=\"python\"\n
                          \   framework=\"fastapi\"\n  elif [[ \"$port\" == \"3000\"
                          ]]; then\n    language=\"nodejs\"\n    framework=\"express\"\n
                          \ fi\n  \n  echo \"$language,$framework\"\n}\n\n# Function
                          to detect database needs\ndetect_database_needs() {\n  local
                          component_yaml=\"$1\"\n  local service_name=\"$2\"\n  \n
                          \ if echo \"$component_yaml\" | grep -A 20 \"name: $service_name\"
                          | grep -q \"DATABASE_URL\\|DB_URL\\|POSTGRES\\|MYSQL\";
                          then\n    if echo \"$component_yaml\" | grep -A 20 \"name:
                          $service_name\" | grep -q \"mysql\"; then\n      echo \"mysql\"\n
                          \   else\n      echo \"postgres\"  # Default to postgres\n
                          \   fi\n  else\n    echo \"none\"\n  fi\n}\n\n# Function
                          to detect cache needs\ndetect_cache_needs() {\n  local component_yaml=\"$1\"\n
                          \ local service_name=\"$2\"\n  \n  if echo \"$component_yaml\"
                          | grep -A 20 \"name: $service_name\" | grep -q \"REDIS_URL\\|CACHE_URL\";
                          then\n    echo \"redis\"\n  else\n    echo \"none\"\n  fi\n}\n\n#
                          Function to create ApplicationClaim\ncreate_application_claim()
                          {\n  local service_name=\"$1\"\n  local namespace=\"$2\"\n
                          \ local app_container=\"$3\"\n  local language=\"$4\"\n
                          \ local framework=\"$5\"\n  local database=\"$6\"\n  local
                          cache=\"$7\"\n  local source_app=\"$8\"\n  \n  echo \"\U0001F3D7ï¸
                          \ Creating ApplicationClaim for: $service_name\"\n  echo
                          \"   Language: $language\"\n  echo \"   Framework: $framework\"
                          \ \n  echo \"   Database: $database\"\n  echo \"   Cache:
                          $cache\"\n  echo \"   AppContainer: $app_container\"\n  \n
                          \ cat <<EOF | kubectl apply -f -\napiVersion: platform.example.org/v1alpha1\nkind:
                          ApplicationClaim\nmetadata:\n  name: $service_name\n  namespace:
                          $namespace\n  annotations:\n    generated-by: \"oam-analyzer\"\n
                          \   generated-at: \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"\n    source-application:
                          \"$source_app\"\n    inferred-language: \"$language\"\n
                          \   inferred-framework: \"$framework\"\n    inferred-database:
                          \"$database\"\n    inferred-cache: \"$cache\"\n  labels:\n
                          \   app.oam.dev/name: \"$source_app\"\n    generated-by:
                          \"oam-analyzer\"\nspec:\n  appContainer: $app_container\n
                          \ name: $service_name\n  language: $language\n  framework:
                          $framework\n  database: $database\n  cache: $cache\n  frontend:
                          false\n  exposeApi: false\n  messaging: none\n  apiEndpoint:
                          /api\nEOF\n  \n  if [ $? -eq 0 ]; then\n    echo \"âœ… ApplicationClaim
                          $service_name created successfully\"\n  else\n    echo \"âŒ
                          Failed to create ApplicationClaim $service_name\"\n  fi\n}\n\n#
                          Function to create AppContainerClaim\ncreate_app_container_claim()
                          {\n  local container_name=\"$1\"\n  local namespace=\"$2\"\n
                          \ local source_app=\"$3\"\n  \n  echo \"\U0001F3D7ï¸  Creating
                          AppContainerClaim for: $container_name\"\n  \n  cat <<EOF
                          | kubectl apply -f -\napiVersion: platform.example.org/v1alpha1\nkind:
                          AppContainerClaim\nmetadata:\n  name: $container_name\n
                          \ namespace: $namespace\n  annotations:\n    generated-by:
                          \"oam-analyzer\"\n    generated-at: \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"\n
                          \   source-application: \"$source_app\"\n  labels:\n    generated-by:
                          \"oam-analyzer\"\nspec:\n  name: $container_name\n  description:
                          \"Auto-generated AppContainer for OAM Application: $source_app\"\n
                          \ gitHubOrg: \"${GITHUB_ORG:-shlapolosa}\"\n  dockerRegistry:
                          \"${DOCKER_REGISTRY:-docker.io/socrates12345}\"\n  enableObservability:
                          true\n  enableSecurity: true\nEOF\n  \n  if [ $? -eq 0 ];
                          then\n    echo \"âœ… AppContainerClaim $container_name created
                          successfully\"\n  else\n    echo \"âŒ Failed to create AppContainerClaim
                          $container_name\"\n  fi\n}\n\n# Function to analyze OAM
                          application\nanalyze_oam_application() {\n  local app_name=\"$1\"\n
                          \ local app_namespace=\"$2\"\n  \n  echo \"\"\n  echo \"\U0001F4CB
                          Analyzing OAM Application: $app_name in namespace: $app_namespace\"\n
                          \ echo \"==================================================================\"\n
                          \ \n  # Get the application YAML\n  local app_yaml=$(kubectl
                          get application.core.oam.dev \"$app_name\" -n \"$app_namespace\"
                          -o yaml 2>/dev/null)\n  if [ $? -ne 0 ]; then\n    echo
                          \"âŒ Failed to get application $app_name\"\n    return 1\n
                          \ fi\n  \n  # Check if already processed (has our annotation)\n
                          \ if echo \"$app_yaml\" | grep -q \"processed-by.*oam-analyzer\";
                          then\n    echo \"âœ… Application $app_name already processed
                          by analyzer\"\n    return 0\n  fi\n  \n  # Extract components\n
                          \ local components=$(echo \"$app_yaml\" | grep -A 1000 \"components:\"
                          | grep -E \"^  - name:\" | awk '{print $3}')\n  \n  if [
                          -z \"$components\" ]; then\n    echo \"â„¹ï¸  No components
                          found in application $app_name\"\n    return 0\n  fi\n  \n
                          \ echo \"\U0001F4E6 Found components:\"\n  echo \"$components\"
                          | sed 's/^/   - /'\n  \n  # Check/create AppContainer\n
                          \ local app_container_name=\"$app_name\"\n  if ! kubectl
                          get appcontainerclaim \"$app_container_name\" -n \"$app_namespace\"
                          >/dev/null 2>&1; then\n    create_app_container_claim \"$app_container_name\"
                          \"$app_namespace\" \"$app_name\"\n  else\n    echo \"âœ… AppContainerClaim
                          $app_container_name already exists\"\n  fi\n  \n  # Process
                          each component\n  while read -r component; do\n    if [
                          -n \"$component\" ]; then\n      echo \"\"\n      echo \"\U0001F50D
                          Processing component: $component\"\n      echo \"----------------------------------------\"\n
                          \     \n      # Get component type (first occurrence after
                          component name)\n      local component_type=$(echo \"$app_yaml\"
                          | grep -A 10 \"name: $component\" | grep \"type:\" | head
                          -1 | awk '{print $2}')\n      echo \"\U0001F4CB Component
                          type: $component_type\"\n      \n      # Only process workload
                          components (webservice is our primary workload type)\n      if
                          [[ \"$component_type\" == \"knative-service\" ]] || [[ \"$component_type\"
                          == \"webservice\" ]] || [[ \"$component_type\" == \"webservice-fixed\"
                          ]]; then\n        \n        # Check if ApplicationClaim
                          already exists\n        if kubectl get applicationclaim
                          \"$component\" -n \"$app_namespace\" >/dev/null 2>&1; then\n
                          \         echo \"âœ… ApplicationClaim for $component already
                          exists\"\n        else\n          # Check if GitHub repo
                          exists (in production, this would use GitHub API)\n          if
                          ! check_github_repo \"$component\"; then\n            echo
                          \"\U0001F50D Repository does not exist, creating ApplicationClaim...\"\n
                          \           \n            # Infer language and framework\n
                          \           local lang_fw=$(infer_language_framework \"$app_yaml\"
                          \"$component\")\n            local language=$(echo \"$lang_fw\"
                          | cut -d',' -f1)\n            local framework=$(echo \"$lang_fw\"
                          | cut -d',' -f2)\n            \n            # Detect infrastructure
                          needs\n            local database=$(detect_database_needs
                          \"$app_yaml\" \"$component\")\n            local cache=$(detect_cache_needs
                          \"$app_yaml\" \"$component\")\n            \n            #
                          Create the ApplicationClaim\n            create_application_claim
                          \"$component\" \"$app_namespace\" \"$app_container_name\"
                          \"$language\" \"$framework\" \"$database\" \"$cache\" \"$app_name\"\n
                          \         else\n            echo \"âœ… Repository for $component
                          already exists\"\n          fi\n        fi\n      else\n
                          \       echo \"â„¹ï¸  Component $component is infrastructure/config
                          (type: $component_type), skipping ApplicationClaim creation\"\n
                          \     fi\n    fi\n  done <<< \"$components\"\n  \n  # Mark
                          application as processed\n  echo \"\"\n  echo \"\U0001F4DD
                          Marking application $app_name as processed...\"\n  kubectl
                          annotate application.core.oam.dev \"$app_name\" -n \"$app_namespace\"
                          processed-by=oam-analyzer processed-at=\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
                          --overwrite\n  \n  echo \"âœ… Analysis complete for application:
                          $app_name\"\n}\n\n# Main execution\necho \"\U0001F680 Starting
                          OAM Application monitoring cycle...\"\n\n# Check prerequisites\nif
                          ! kubectl version --client >/dev/null 2>&1; then\n  echo
                          \"âŒ kubectl not available\"\n  exit 1\nfi\n\n# Check cluster
                          access\nif ! kubectl get namespaces >/dev/null 2>&1; then\n
                          \ echo \"âŒ Cannot access Kubernetes cluster\"\n  exit 1\nfi\n\n#
                          Check for OAM CRDs\nif ! kubectl get crd applications.core.oam.dev
                          >/dev/null 2>&1; then\n  echo \"âš ï¸  OAM Application CRD
                          not found, skipping analysis\"\n  exit 0\nfi\n\n# Check
                          for Platform CRDs\nif ! kubectl get crd applicationclaims.platform.example.org
                          >/dev/null 2>&1; then\n  echo \"âš ï¸  ApplicationClaim CRD
                          not found, skipping analysis\"\n  exit 0\nfi\n\necho \"âœ…
                          Prerequisites checked\"\n\n# Find all OAM Applications\necho
                          \"\"\necho \"\U0001F50D Scanning for OAM Applications...\"\n\napplications=$(kubectl
                          get applications.core.oam.dev --all-namespaces --no-headers
                          2>/dev/null | awk '{print $1 \" \" $2}')\n\nif [ -z \"$applications\"
                          ]; then\n  echo \"â„¹ï¸  No OAM Applications found\"\n  exit
                          0\nfi\n\necho \"\U0001F4CB Found OAM Applications:\"\necho
                          \"$applications\" | sed 's/^/   /'\n\n# Process each application\nwhile
                          read -r namespace name; do\n  if [ -n \"$namespace\" ] &&
                          [ -n \"$name\" ]; then\n    analyze_oam_application \"$name\"
                          \"$namespace\"\n  fi\ndone <<< \"$applications\"\n\necho
                          \"\"\necho \"\U0001F389 OAM Application monitoring cycle
                          completed!\"\necho \"Time: $(date)\"\n"
                        env:
                        - name: GITHUB_ORG
                          valueFrom:
                            secretKeyRef:
                              key: owner
                              name: github-analyzer-credentials
                        - name: GITHUB_TOKEN
                          valueFrom:
                            secretKeyRef:
                              key: token
                              name: github-analyzer-credentials
                        - name: DOCKER_REGISTRY
                          value: docker.io/socrates12345
                        image: bitnami/kubectl:latest
                        name: analyzer
                        resources:
                          limits:
                            cpu: 500m
                            memory: 512Mi
                          requests:
                            cpu: 100m
                            memory: 256Mi
                      restartPolicy: OnFailure
                      serviceAccountName: oam-application-analyzer
              schedule: '*/2 * * * *'
              successfulJobsHistoryLimit: 3
    name: vcluster-oam-analyzer-cronjob
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.providerConfigRef.name
      transforms:
      - string:
          fmt: '%s-vcluster'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.jobTemplate.spec.template.spec.containers[0].env[0].value
      transforms:
      - string:
          fmt: socrates12345
          type: Format
        type: string
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: networking.istio.io/v1beta1
            kind: VirtualService
            metadata:
              name: placeholder
              namespace: placeholder
            spec:
              gateways:
              - placeholder
              hosts:
              - placeholder
              http:
              - match:
                - uri:
                    prefix: /argocd
                rewrite:
                  uri: /
                route:
                - destination:
                    host: placeholder
                    port:
                      number: 80
        providerConfigRef:
          name: vcluster-provider
    name: vcluster-argocd-virtualservice
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - string:
          fmt: '%s-argocd-vs'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-argocd-vs'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.hosts[0]
      transforms:
      - string:
          fmt: '%s-vcluster.local'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.gateways[0]
      transforms:
      - string:
          fmt: '%s-gateway'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.http[0].route[0].destination.host
      transforms:
      - string:
          fmt: argocd-server.argocd.svc.cluster.local
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.components.argoCD
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - map:
          "false": "false"
          "true": "true"
        type: map
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: apigatewayv2.aws.upbound.io/v1beta1
      kind: API
      spec:
        forProvider:
          corsConfiguration:
          - allowCredentials: false
            allowHeaders:
            - '*'
            allowMethods:
            - '*'
            allowOrigins:
            - '*'
            exposeHeaders:
            - '*'
            maxAge: 86400
          description: API Gateway for vCluster applications
          name: placeholder
          protocolType: HTTP
          tags:
            Environment: vcluster
            ManagedBy: crossplane
        providerConfigRef:
          name: default
    name: vcluster-aws-api-gateway
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.name
      transforms:
      - string:
          fmt: '%s-api-gateway'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-api-gateway'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.tags.VCluster
      type: FromCompositeFieldPath
    - fromFieldPath: status.atProvider.id
      policy:
        fromFieldPath: Optional
      toFieldPath: status.apiGateway.id
      type: ToCompositeFieldPath
    - fromFieldPath: status.atProvider.apiEndpoint
      policy:
        fromFieldPath: Optional
      toFieldPath: status.apiGateway.endpoint
      type: ToCompositeFieldPath
    - fromFieldPath: spec.components.apiGateway
      policy:
        fromFieldPath: Optional
      toFieldPath: spec.forProvider.tags.ComponentEnabled
      transforms:
      - convert:
          toType: string
        type: convert
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: apigatewayv2.aws.upbound.io/v1beta1
      kind: VPCLink
      spec:
        forProvider:
          name: placeholder
          subnetIds: []
          tags:
            Environment: vcluster
            Instructions: Configure subnetIds via EnvironmentConfig or manual override
            ManagedBy: crossplane
        providerConfigRef:
          name: default
    name: vcluster-vpc-link
    patches:
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.name
      transforms:
      - string:
          fmt: '%s-vpc-link'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-vpc-link'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.tags.VCluster
      type: FromCompositeFieldPath
    - fromFieldPath: vpc.privateSubnetIds
      policy:
        fromFieldPath: Required
      toFieldPath: spec.forProvider.subnetIds
      type: FromEnvironmentFieldPath
    - fromFieldPath: status.atProvider.id
      policy:
        fromFieldPath: Optional
      toFieldPath: status.apiGateway.vpcLinkId
      type: ToCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: apigatewayv2.aws.upbound.io/v1beta1
      kind: Integration
      spec:
        forProvider:
          apiId: placeholder
          connectionId: placeholder
          connectionType: VPC_LINK
          integrationMethod: ANY
          integrationType: HTTP_PROXY
          integrationUri: placeholder
          payloadFormatVersion: "1.0"
          timeoutMilliseconds: 29000
        providerConfigRef:
          name: default
    name: vcluster-api-integration
    patches:
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-api-integration'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: status.apiGateway.id
      policy:
        fromFieldPath: Required
      toFieldPath: spec.forProvider.apiId
      type: FromCompositeFieldPath
    - fromFieldPath: status.apiGateway.vpcLinkId
      policy:
        fromFieldPath: Required
      toFieldPath: spec.forProvider.connectionId
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.integrationUri
      transforms:
      - string:
          fmt: http://%s-gateway.istio-system.svc.cluster.local
          type: Format
        type: string
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: apigatewayv2.aws.upbound.io/v1beta1
      kind: Route
      spec:
        forProvider:
          apiId: placeholder
          routeKey: ANY /{proxy+}
          target: placeholder
        providerConfigRef:
          name: default
    name: vcluster-api-route
    patches:
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-api-route'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: status.apiGateway.id
      policy:
        fromFieldPath: Required
      toFieldPath: spec.forProvider.apiId
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.target
      transforms:
      - string:
          fmt: integrations/%s-api-integration
          type: Format
        type: string
      type: FromCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  - base:
      apiVersion: apigatewayv2.aws.upbound.io/v1beta1
      kind: Stage
      spec:
        forProvider:
          apiId: placeholder
          autoDeploy: true
          description: Production stage for vCluster API Gateway
          name: prod
          tags:
            Environment: vcluster
            ManagedBy: crossplane
        providerConfigRef:
          name: default
    name: vcluster-api-stage
    patches:
    - fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - string:
          fmt: '%s-api-stage'
          type: Format
        type: string
      type: FromCompositeFieldPath
    - fromFieldPath: status.apiGateway.id
      policy:
        fromFieldPath: Required
      toFieldPath: spec.forProvider.apiId
      type: FromCompositeFieldPath
    - fromFieldPath: spec.name
      toFieldPath: spec.forProvider.tags.VCluster
      type: FromCompositeFieldPath
    - fromFieldPath: status.atProvider.invokeUrl
      policy:
        fromFieldPath: Optional
      toFieldPath: status.apiGateway.endpoint
      type: ToCompositeFieldPath
    - fromFieldPath: spec.forProvider.name
      policy:
        fromFieldPath: Optional
      toFieldPath: status.apiGateway.stage
      type: ToCompositeFieldPath
    readinessChecks:
    - matchCondition:
        status: "True"
        type: Ready
      type: MatchCondition
  writeConnectionSecretsToNamespace: crossplane-system
