# Agent Common Library v1.1.0

Shared base classes and utilities for all agent microservices with **real-time streaming capabilities**.

## 🆕 What's New in v1.1.0

- **Real-time Agent Support**: New `RealtimeAgent` base class with Kafka, MQTT, and WebSocket integration
- **Platform Secret Loading**: Automatic secret injection from realtime platform components
- **WebSocket Management**: Built-in WebSocket connection management and broadcasting
- **Streaming Endpoints**: Server-sent events and real-time API endpoints
- **Enhanced Configuration**: Extended `AgentConfig` with real-time platform settings

## 📦 Installation

```bash
pip install agent-common
```

### Optional Dependencies

```bash
# For Snowflake integration
pip install agent-common[snowflake]

# For monitoring and metrics
pip install agent-common[monitoring]

# For testing
pip install agent-common[testing]
```

## 🚀 Quick Start

### Standard Agent (Existing)

```python
from agent_common import BaseMicroserviceAgent, create_agent_app

class MyAgent(BaseMicroserviceAgent):
    def _create_processor(self):
        # Your processor implementation
        pass
    
    def _get_supported_task_types(self):
        return ["analyze", "process"]

# Create FastAPI app
app = create_agent_app(
    MyAgent,
    "my-agent-service",
    "My agent service",
    [{"path": "/analyze", "task_type": "analyze"}]
)
```

### Real-time Agent (New)

```python
from agent_common import RealtimeAgent, create_realtime_agent_app, AgentConfig

class MyRealtimeAgent(RealtimeAgent):
    def _create_processor(self):
        # Your processor implementation
        pass
    
    def _get_supported_task_types(self):
        return ["analyze", "process"]

# Create real-time FastAPI app
app = create_realtime_agent_app(
    MyRealtimeAgent,
    "my-realtime-agent",
    "My real-time agent service", 
    endpoints=[{"path": "/analyze", "task_type": "analyze"}],
    websocket_endpoints=[{"path": "/ws/custom", "auto_subscribe": ["events"]}]
)
```

## 🏗️ Architecture

### Component Overview

```
agent-common/
├── Core Classes
│   ├── BaseMicroserviceAgent    # Standard agent base class
│   ├── RealtimeAgent           # Real-time enabled agent 
│   └── AgentConfig             # Configuration management
├── Real-time Features
│   ├── WebSocketManager        # WebSocket connection management
│   ├── PlatformSecretLoader    # Automatic secret loading
│   └── Streaming Models        # Real-time data models
└── FastAPI Factories
    ├── create_agent_app        # Standard FastAPI factory
    └── create_realtime_agent_app # Real-time FastAPI factory
```

### Real-time Platform Integration

The library automatically integrates with realtime platform components deployed via OAM:

```yaml
# OAM Application using realtime platform
- name: my-service
  type: webservice
  properties:
    realtime: "my-platform"  # References realtime-platform component
    websocket: true
    streaming:
      enabled: true
      topics: ["events", "data"]
```

## 📚 Configuration

### Environment Variables

When using realtime platform integration, these variables are automatically injected:

```bash
# Platform reference
REALTIME_PLATFORM=my-platform

# Kafka settings (auto-injected from secrets)
KAFKA_BOOTSTRAP_SERVERS=my-platform-kafka:9092
KAFKA_SCHEMA_REGISTRY_URL=http://my-platform-kafka:8081

# MQTT settings (auto-injected from secrets)
MQTT_HOST=my-platform-mqtt
MQTT_PORT=1883
MQTT_USER=realtime-user
MQTT_PASSWORD=<auto-generated>

# Database settings (auto-injected from secrets)
DB_HOST=my-platform-postgres
DB_NAME=myplatform
DB_USER=realtime
DB_PASSWORD=<auto-generated>

# Analytics settings (auto-injected from secrets)
METABASE_URL=http://my-platform-metabase:3000
LENSES_URL=http://my-platform-lenses-hq:9991
```

### Manual Configuration

```python
from agent_common import AgentConfig

config = AgentConfig(
    agent_type=AgentType.BUSINESS_ANALYST,
    implementation_type=ImplementationType.ANTHROPIC,
    service_name="my-service",
    
    # Real-time platform settings
    realtime_platform="my-platform",
    websocket_enabled=True,
    streaming_topics=["events", "notifications"],
    streaming_consumer_group="my-service-group",
    
    # Connection settings (usually auto-loaded from secrets)
    kafka_bootstrap_servers="localhost:9092",
    mqtt_host="localhost",
    mqtt_port=1883
)
```

## 🔧 Real-time Agent Features

### 1. Event Handling

```python
from agent_common import RealtimeAgent, RealtimeEvent, EventType

class MyRealtimeAgent(RealtimeAgent):
    async def initialize(self):
        await super().initialize()
        
        # Register event handlers
        self.register_event_handler(EventType.DATA_PROCESSED, self.handle_data_event)
        self.register_message_handler("health_data", self.handle_health_data)
    
    async def handle_data_event(self, event: RealtimeEvent):
        print(f"Received event: {event.event_type}")
        
        # Broadcast to WebSocket clients
        await self._broadcast_websocket(WebSocketMessage(
            message_type="data_update",
            payload=event.data
        ))
    
    async def handle_health_data(self, message):
        # Process incoming health data from MQTT/Kafka
        processed_data = await self.process_health_reading(message)
        
        # Send to Kafka topic
        await self.send_kafka_message("processed_health", processed_data)
```

### 2. WebSocket Integration

```python
# WebSocket endpoint automatically available at /ws
# Custom endpoints can be added:

app = create_realtime_agent_app(
    MyRealtimeAgent,
    "health-agent",
    "Health data processing agent",
    endpoints=[...],
    websocket_endpoints=[
        {
            "path": "/ws/health",
            "auto_subscribe": ["health_events", "alerts"]
        },
        {
            "path": "/ws/monitoring", 
            "auto_subscribe": ["system_metrics"]
        }
    ]
)
```

### 3. Streaming Data Processing

```python
class HealthDataAgent(RealtimeAgent):
    async def initialize(self):
        await super().initialize()
        
        # Register handlers for different data types
        self.register_message_handler("blood_pressure", self.process_blood_pressure)
        self.register_message_handler("heart_rate", self.process_heart_rate)
    
    async def process_blood_pressure(self, data):
        # Validate and process blood pressure reading
        if data["systolic"] > 140:
            alert = RealtimeEvent(
                event_type=EventType.ALERT_TRIGGERED,
                source_service=self.name,
                data={"type": "high_blood_pressure", "reading": data}
            )
            await self._emit_event(alert)
```

## 🔌 Platform Secret Integration

The library automatically loads secrets from the realtime platform:

```python
from agent_common import load_realtime_platform_secrets, configure_agent_from_secrets

# Automatic secret loading
secrets = await load_realtime_platform_secrets("my-platform")
config = configure_agent_from_secrets(base_config, secrets)

# Manual secret loading
loader = PlatformSecretLoader("my-platform")
kafka_secrets = await loader._load_kafka_secrets("my-platform")
```

Secret naming follows the pattern: `{platform-name}-{service-type}-secret`

- `my-platform-kafka-secret`
- `my-platform-mqtt-secret`  
- `my-platform-db-secret`
- `my-platform-metabase-secret`
- `my-platform-lenses-secret`

## 🌐 WebSocket API

### Client-Side Usage

```javascript
// Connect to WebSocket
const ws = new WebSocket('ws://localhost:8080/ws');

// Subscribe to topics
ws.send(JSON.stringify({
    message_type: "subscribe",
    payload: { topic: "health_events" }
}));

// Send agent request
ws.send(JSON.stringify({
    message_type: "agent_request",
    payload: {
        query: "Analyze this health data",
        task_type: "analyze_health",
        parameters: { patient_id: "12345" }
    }
}));

// Handle responses
ws.onmessage = (event) => {
    const message = JSON.parse(event.data);
    console.log(`Received: ${message.message_type}`, message.payload);
};
```

### WebSocket Message Types

- `subscribe`/`unsubscribe` - Topic subscription management
- `agent_request` - Send task to agent via WebSocket
- `ping`/`pong` - Connection health checks
- `realtime_event` - Real-time events from agents
- `broadcast` - Messages broadcast to all connections

## 📊 Server-Sent Events (SSE)

```javascript
// Stream real-time events
const eventSource = new EventSource('/stream/events');
eventSource.onmessage = (event) => {
    const data = JSON.parse(event.data);
    console.log('Real-time update:', data);
};

// Stream specific topics
const topicStream = new EventSource('/stream/topic/health_data');
```

## 🔍 Monitoring & Health Checks

### Enhanced Health Endpoints

```bash
# Standard health check
GET /health
{
  "status": "healthy",
  "service": "my-agent",
  "realtime_enabled": true,
  "websocket_enabled": true,
  "connections": 5,
  "message_count": 1234,
  "error_count": 0
}

# Detailed real-time status
GET /realtime/status
{
  "agent_type": "business-analyst", 
  "realtime_enabled": true,
  "connections": [...],
  "active_streams": ["events", "data"],
  "message_count": 1234
}

# WebSocket connection stats
GET /realtime/connections
{
  "total_connections": 5,
  "total_topics": 3,
  "topics": {
    "events": 3,
    "health_data": 2
  }
}
```

## 🧪 Testing

### Unit Testing

```python
import pytest
from agent_common import RealtimeAgent, RealtimeEvent, EventType

@pytest.mark.asyncio
async def test_realtime_agent():
    config = AgentConfig(...)
    agent = MyRealtimeAgent("test", "test-agent", "Test agent", config)
    
    await agent.initialize()
    
    # Test event handling
    event = RealtimeEvent(
        event_type=EventType.DATA_PROCESSED,
        source_service="test",
        data={"test": "data"}
    )
    
    await agent._emit_event(event)
    
    await agent.cleanup()
```

### Integration Testing

```python
@pytest.mark.asyncio
async def test_websocket_integration():
    # Test WebSocket functionality
    from fastapi.testclient import TestClient
    from agent_common import create_realtime_agent_app
    
    app = create_realtime_agent_app(MyRealtimeAgent, ...)
    client = TestClient(app)
    
    with client.websocket_connect("/ws") as websocket:
        # Test subscription
        websocket.send_json({
            "message_type": "subscribe",
            "payload": {"topic": "test"}
        })
        
        response = websocket.receive_json()
        assert response["message_type"] == "subscription_confirmed"
```

## 🔄 Migration Guide

### From Standard Agent to Real-time Agent

1. **Update base class:**
   ```python
   # Before
   class MyAgent(BaseMicroserviceAgent):
   
   # After  
   class MyAgent(RealtimeAgent):
   ```

2. **Update FastAPI factory:**
   ```python
   # Before
   app = create_agent_app(MyAgent, ...)
   
   # After
   app = create_realtime_agent_app(MyAgent, ...)
   ```

3. **Add real-time configuration:**
   ```python
   # Add to your agent initialization
   config = AgentConfig(
       realtime_platform="my-platform",
       websocket_enabled=True,
       streaming_topics=["events"]
   )
   ```

4. **Update dependencies:**
   ```bash
   pip install agent-common>=1.1.0
   ```

## 🎯 Examples

### Health Data Processing Agent

```python
from agent_common import (
    RealtimeAgent, create_realtime_agent_app, AgentConfig,
    RealtimeEvent, EventType, HealthDataModel
)

class HealthProcessingAgent(RealtimeAgent):
    async def initialize(self):
        await super().initialize()
        
        # Register handlers
        self.register_message_handler("blood_pressure", self.process_blood_pressure)
        self.register_event_handler(EventType.ALERT_TRIGGERED, self.handle_alert)
    
    async def process_blood_pressure(self, data):
        # Process blood pressure reading
        reading = HealthDataModel(**data)
        
        # Check for alerts
        if reading.value["systolic"] > 140:
            alert = RealtimeEvent(
                event_type=EventType.ALERT_TRIGGERED,
                source_service=self.name,
                data={"alert": "high_blood_pressure", "reading": reading.dict()}
            )
            await self._emit_event(alert)
    
    async def handle_alert(self, event: RealtimeEvent):
        # Send alert to monitoring system
        await self.send_kafka_message("health_alerts", event.data)

# Create app
ENDPOINTS = [
    {"path": "/analyze-health", "task_type": "analyze_health"},
    {"path": "/process-vitals", "task_type": "process_vitals"}
]

WEBSOCKET_ENDPOINTS = [
    {"path": "/ws/health", "auto_subscribe": ["health_events", "alerts"]}
]

app = create_realtime_agent_app(
    HealthProcessingAgent,
    "health-processing-agent",
    "Real-time health data processing agent",
    endpoints=ENDPOINTS,
    websocket_endpoints=WEBSOCKET_ENDPOINTS
)
```

## 📖 API Reference

### Classes

- **`RealtimeAgent`** - Base class for real-time enabled agents
- **`AgentConfig`** - Enhanced configuration with real-time settings  
- **`WebSocketConnectionManager`** - WebSocket connection management
- **`PlatformSecretLoader`** - Automatic secret loading from platform

### Models

- **`RealtimeEvent`** - Real-time event data structure
- **`WebSocketMessage`** - WebSocket message format
- **`AgentRealtimeStatus`** - Real-time status information
- **`HealthDataModel`** - Health data streaming model

### Functions

- **`create_realtime_agent_app()`** - Create real-time FastAPI application
- **`load_realtime_platform_secrets()`** - Load platform secrets
- **`configure_agent_from_secrets()`** - Auto-configure from secrets

## 🤝 Contributing

1. Install development dependencies:
   ```bash
   pip install agent-common[testing]
   ```

2. Run tests:
   ```bash
   pytest tests/
   ```

3. Follow the existing patterns for real-time functionality

## 📄 License

MIT License - see LICENSE file for details.

---

For more examples and detailed documentation, see the [health-service-idp platform documentation](../../docs/).