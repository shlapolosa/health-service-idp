note, this system is for architects (users) but emplys architects (agents) as the actors within the system to do the work. so reference to 
  business analyst. project manager, business architect, application architect, infrustructure architect and so on, is in context of agents who do the work. use 
  the term user to refer to architect using the application specifically. samples bellow are also just examples and not implimentation. solution 
  should deploy kubevela application using knative which is configured with istio and deployed using argocd, which must still be added to the 
  cluster. only want a single ingress .please create a project definition file for the following requirements:
  given a kubernetes cluster with vcluster and knative already installed and configured on aws as per vcluster-knative.sh and vcluster.yaml file, 
  we need to develop the followig: 

  given these raw requirements:

it should be a visual architecture maintanance tool that allows users to create, view, update an architecture using natural language. the changes must propegate through all layers of the architecture and ultimately bring about code changes. it caters for architect who need to design, decide or inform on architecutre and likewise product owners who need to make financial decisions and strategic directions.
it is a web based solution with a streamlit front end. it is driven by a chat interface. the frontend has hamburger that allows you to create a new architecture or switch to another architecture. the center pane has embedded html architecture as attached. this allows user to see all aspects of the archtecture. the bottom pane is the chat interface where user can perform the 3 main tasks through natural language. when designing, you will capture your requests, then the system will go decide what changes are needed at every layer of the architecture, it will then update the html desing in gray and allow you to approve the changes. once approved they will then be executed. if asking for information, that will just be returned in a structured way across the architecture. when asking for decisions, again an assessment of the current and to be will be done across all layers and aspects. the architecture will then be updated with the various options on the same diagrams, user will then select best option and it will be executed.
looking to use agentic framework that allows creation of the following agents (please suggest more if needed) with the following capabilities:

the system will have the following agents.

Business Analyst: ability format and structure the requirements, articulate organisational scope, active, pasive structural elements, behaviour and relations. outputs requirements. also able to take the completed architecture and create a project requirements document as output.
Business Architect: ability to get current architecture (which will be html) from repository, assess strategic, motivational and business layer impact. has access to diagraming tools to make changes to the design. access to industry capability maps e.g bizbok. output is the updated design with to-be changes in grey, till they are approved, then in color
Application architect: access to the latest design, which might have changes to the layers above. he must also have access to reference architectures (aws, azure, kubernetes, mlops, integration, data, front end etc), should asses impact of changes and update design with application layer changes reqiured or informational output.
Infrustructure architect/devops: should have access to the latest desing and changes to the layers above. should also have access to browse cloud native techniques, references and tools. should then make changes to the architecture based on requirements as well as any changes to operations and support.
project manager: ability to access latest design and update implimentation layer
accountant: access latest design and do and update costing.
Solution architect: able to get latest design and update solution architecture, should have access to the latest reference architectures, patterns and tooling. their output is the updated solution architecture
developer: able to take the user stories and impliment the necessary changes in code. output is working, tested software using best practice methodologies and tools.
in general, architects look for standards, reference architectures, guidlines, patterns and trade-offs. solution architects look to desing cattering for non-functional as well. they are interested in specific technology to impliments
developer acess stories and output code
business analyst define requirements as input to the process and user stories after all architects have done their parts.
requiest fist get to business analyst who will then push the requirements down the layers. if requirements dont impact a lyer, then push down without any changes for the next role to do their part. all agents can work sequentially, but need framework to govern their work. they also need mcp to access new knowledge. mcp servers for context7, taskmaster, github, diagraming, web searching, terminal manipulation, cloud manipulation, kubernetes.

do the architecture and give the output as a markdonw file as per these instructions:   ## Expected Output Structure  The framework implementation should produce a markdown file structured as follows:  ### Visual Representation Standards                                                                                                                      All diagrams must use **Archimate notation** with standardized coloring:                                                                                 - **Purple (#CC99FF)**: Strategy elements (octagons)                                                                                                     - **Yellow (#FFFF99)**: Business layer (circles)                                                                                                         - **Light Brown (#E6CC99)**: Passive structures (rectangles)                                                                                             - **Blue (#99CCFF)**: Application layer (rounded rectangles)                                                                                             - **Orange (#FFCC99)**: Implementation (sharp rectangles)   ### 1. Requirements Analysis 1.1 **Raw Requirements**   - Unprocessed natural language requirements from the requirements as they are without any changes.   - Business needs and pain points in original form    1.2 **Business Analysis Output**   - Requirements structured using Subject-Action-Object format   - Clear mapping of actors to capabilities and behaviors    ### 2. Business Architecture    ### Standards & Guardrails    - **Standards**: Relevant industry standards   - **Guardrails**: Implementation constraints   - **Trade-offs**: Architectural decisions    2.1 **Business Architecture Elements**   - Structural elements (actors, roles, collaborations)   - Behavioral elements (processes, functions, events)   - Passive elements (objects, contracts)   - Relationship types (assignment, realization, serving)    2.2 **Business Component Diagram**   - Visual representation using Archimate notation:     - Octagons for actors     - Circles for roles     - Rectangles for processes/objects   - Show key relationships between elements    2.3 **Capability Mapping** (Required)                                                                                                                    - Level 1-3 capability hierarchy                                                                                                                         - PlantUML or Mermaid syntax diagram                                                                                                                     - Must show parent-child relationships   ### 3. Application Architecture    ### Standards & Guardrails     - **Standards**: Relevant industry standards  and reference architectures (just reference them)  - **Guardrails**: Implementation constraints   - **Trade-offs**: Architectural decisions    3.1 **Business→Application Mapping Table**   - Realization and serving relationships   - All application elements listed (even unmapped ones)   - Clear traceability between layers    3.2 **Application Component Diagram**   - Visual representation using Archimate notation:     - Circles for components     - Rectangles for services/functions   - Show data flows and dependencies    ### 4. Platform/Infrastructure    ### Standards & Guardrails     - **Standards**: Relevant industry standards   - **Guardrails**: Implementation constraints   - **Trade-offs**: Architectural decisions    4.1 **Application→Platform Mapping**   - Deployment and hosting relationships   - Storage and network requirements    4.2 **Platform Diagram**   - Node and storage system relationships   - Infrastructure capabilities    ### 5. Implementation   5.1 **Workpackets List**   - Discrete units of implementation work   - Owner, inputs, outputs for each    5.2 **Risks & Concerns**   - Identified risks with impact levels   - Mitigation strategies    ### 6. Governance   - Cost centers and budget tracking   - Compliance controls and verification    ### 7. KubeVela Mapping   7.1 **Application→KubeVela Table**   - Component type mappings   - Workload specifications    7.2 **KubeVela Descriptor**   - Complete application configuration   - Traits and policies    ### 8. OpenAPI Specification   - Consolidated ingress operations   - Action mappings from business processes     **Note**: All enterprise architecture sections must use Archimate naming principles, avoiding technology-specific language.