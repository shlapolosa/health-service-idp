apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: app-container-claim-composition
  labels:
    crossplane.io/xrd: xappcontainerclaims.platform.example.org
    provider: github-kubernetes-helm
spec:
  writeConnectionSecretsToNamespace: crossplane-system
  compositeTypeRef:
    apiVersion: platform.example.org/v1alpha1
    kind: XAppContainerClaim
  resources:
  
  # Create Source Repository (microservices container)
  - name: source-repository
    base:
      apiVersion: repo.github.upbound.io/v1alpha1
      kind: Repository
      spec:
        forProvider:
          name: placeholder
          description: "CLAUDE.md-compliant microservices container"
          private: false
          autoInit: true
          gitIgnoreTemplate: "Python"
          licenseTemplate: mit
          topics: ["microservices", "crossplane", "claude-compliant", "app-container"]
        providerConfigRef:
          name: github-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.name
    - type: FromCompositeFieldPath
      fromFieldPath: spec.description
      toFieldPath: spec.forProvider.description
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-source-repo"
    - type: ToCompositeFieldPath
      fromFieldPath: status.atProvider.htmlUrl
      toFieldPath: status.sourceRepository.url
      policy:
        fromFieldPath: Optional
    - type: ToCompositeFieldPath
      fromFieldPath: status.atProvider.httpCloneUrl
      toFieldPath: status.sourceRepository.cloneUrl
      policy:
        fromFieldPath: Optional
    - type: ToCompositeFieldPath
      fromFieldPath: status.atProvider.defaultBranch
      toFieldPath: status.sourceRepository.branch
      policy:
        fromFieldPath: Optional

  # Create GitOps Repository
  - name: gitops-repository
    base:
      apiVersion: repo.github.upbound.io/v1alpha1
      kind: Repository
      spec:
        forProvider:
          name: placeholder
          description: "GitOps repository for app container deployment manifests"
          private: false
          autoInit: true
          gitIgnoreTemplate: "Go"
          licenseTemplate: mit
          topics: ["gitops", "argocd", "oam", "kubernetes"]
        providerConfigRef:
          name: github-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.name
      transforms:
      - type: string
        string:
          fmt: "%s-gitops"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-gitops-repo"
    - type: ToCompositeFieldPath
      fromFieldPath: status.atProvider.htmlUrl
      toFieldPath: status.gitopsRepository.url
      policy:
        fromFieldPath: Optional
    - type: ToCompositeFieldPath
      fromFieldPath: status.atProvider.httpCloneUrl
      toFieldPath: status.gitopsRepository.cloneUrl
      policy:
        fromFieldPath: Optional
    - type: ToCompositeFieldPath
      fromFieldPath: status.atProvider.defaultBranch
      toFieldPath: status.gitopsRepository.branch
      policy:
        fromFieldPath: Optional

  # Setup Source Repository Structure
  - name: source-repo-setup
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: default
            spec:
              template:
                spec:
                  serviceAccountName: crossplane-github-provider
                  restartPolicy: OnFailure
                  containers:
                  - name: source-repo-setup
                    image: alpine/git:latest
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      echo "Setting up source repository structure for $APP_NAME..."
                      
                      TEMP_DIR="/tmp/repo-$APP_NAME"
                      mkdir -p $TEMP_DIR
                      cd $TEMP_DIR
                      
                      # Clone the repository
                      git clone $SOURCE_CLONE_URL .
                      
                      # Configure git with authentication for push
                      git config user.name "AppContainer Setup"
                      git config user.email "appcontainer@platform.local"
                      git remote set-url origin "https://${GITHUB_TOKEN}@github.com/${GITHUB_REPO}.git"
                      
                      # Create microservices container structure
                      mkdir -p microservices
                      mkdir -p shared-libs/common
                      mkdir -p .github/workflows
                      mkdir -p .github/scripts
                      
                      # Copy the version manager script
                      cat > .github/scripts/version-manager.sh << 'EOF'
                      #!/bin/bash
                      set -e
                      
                      # Semantic Versioning Manager for GitOps
                      # Generates semantic versions with commit SHA for container tagging
                      
                      SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
                      PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
                      
                      # Default values
                      MAJOR_VERSION=1
                      MINOR_VERSION=1
                      BASE_VERSION_FILE="$PROJECT_ROOT/.version"
                      
                      # Read base version from file if it exists
                      if [ -f "$BASE_VERSION_FILE" ]; then
                          BASE_VERSION=$(cat "$BASE_VERSION_FILE")
                          MAJOR_VERSION=$(echo "$BASE_VERSION" | cut -d. -f1)
                          MINOR_VERSION=$(echo "$BASE_VERSION" | cut -d. -f2)
                      fi
                      
                      # Function to get commit count for patch version
                      get_patch_version() {
                          git rev-list --count HEAD 2>/dev/null || echo "0"
                      }
                      
                      # Function to get short commit SHA
                      get_commit_sha() {
                          git rev-parse --short=7 HEAD 2>/dev/null || echo "unknown"
                      }
                      
                      # Function to get branch name (sanitized for container tags)
                      get_branch_name() {
                          local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")
                          # Sanitize branch name for container registry
                          echo "$branch" | sed 's/[^a-zA-Z0-9._-]/-/g' | tr '[:upper:]' '[:lower:]'
                      }
                      
                      # Function to check if this is a release branch
                      is_release_branch() {
                          local branch=$(get_branch_name)
                          [[ "$branch" == "main" || "$branch" == "master" || "$branch" =~ ^release/.* ]]
                      }
                      
                      # Function to generate semantic version
                      generate_semantic_version() {
                          local service_name="$1"
                          local commit_sha=$(get_commit_sha)
                          
                          # Use major.minor.sha format for Docker compatibility
                          local semver="$MAJOR_VERSION.$MINOR_VERSION.$commit_sha"
                          
                          echo "$semver"
                      }
                      
                      # Function to generate container tags
                      generate_container_tags() {
                          local service_name="$1"
                          local registry="${2:-docker.io/socrates12345}"
                          local commit_sha=$(get_commit_sha)
                          local branch=$(get_branch_name)
                          local semver=$(generate_semantic_version "$service_name")
                          
                          # Base image name
                          local image_base="$registry/$service_name"
                          
                          # Generate multiple tags
                          local tags=()
                          
                          # 1. Full semantic version tag
                          tags+=("$image_base:$semver")
                          
                          # 2. Short SHA tag
                          tags+=("$image_base:$commit_sha")
                          
                          # 3. Branch-specific tag
                          tags+=("$image_base:$branch-$commit_sha")
                          
                          # 4. Latest tag for main/master branch
                          if is_release_branch; then
                              tags+=("$image_base:latest")
                              tags+=("$image_base:$MAJOR_VERSION")
                              tags+=("$image_base:$MAJOR_VERSION.$MINOR_VERSION")
                          fi
                          
                          # 5. Development tag for feature branches
                          if [[ "$branch" == "develop" ]]; then
                              tags+=("$image_base:develop")
                          fi
                          
                          # Return as comma-separated string
                          IFS=','
                          echo "${tags[*]}"
                      }
                      
                      # Main function
                      main() {
                          local command="$1"
                          local service_name="$2"
                          local registry="${3:-docker.io/socrates12345}"
                          
                          case "$command" in
                              "version")
                                  generate_semantic_version "$service_name"
                                  ;;
                              "tags")
                                  generate_container_tags "$service_name" "$registry"
                                  ;;
                              "help"|*)
                                  cat << HELP_EOF
                      Usage: $0 <command> [service_name] [registry]
                      
                      Commands:
                        version <service>           Generate semantic version
                        tags <service> [registry]   Generate container tags
                        help                        Show this help
                      
                      Examples:
                        $0 version accommodation-service
                        $0 tags accommodation-service
                      HELP_EOF
                                  ;;
                          esac
                      }
                      
                      # Run main function with all arguments
                      main "$@"
                      EOF
                      
                      # Make version manager executable
                      chmod +x .github/scripts/version-manager.sh
                      
                      # Create .version file
                      echo "1.1" > .version
                      
                      # Copy the comprehensive GitOps workflow from template
                      wget -q -O .github/workflows/comprehensive-gitops.yml https://raw.githubusercontent.com/shlapolosa/health-service-idp/main/crossplane/templates/comprehensive-gitops-template.yml || {
                        echo "Failed to download workflow template, using fallback..."
                        # Fallback: minimal workflow if template download fails
                        cat > .github/workflows/comprehensive-gitops.yml << 'FALLBACK_EOF'
                      name: Comprehensive GitOps Pipeline
                      on:
                        push:
                          branches: [ main ]
                          paths: [ 'microservices/**' ]
                      env:
                        REGISTRY: docker.io
                        REGISTRY_USERNAME: socrates12345
                        GITOPS_REPO: APP_NAME_PLACEHOLDER-gitops
                      jobs:
                        minimal-deploy:
                          runs-on: ubuntu-latest
                          steps:
                            - uses: actions/checkout@v4
                            - name: Build and deploy
                              run: echo "Minimal deployment pipeline activated"
                      FALLBACK_EOF
                      }
                      
                      # Substitute app name in the workflow  
                      sed -i "s/APP_NAME_PLACEHOLDER/$APP_NAME/g" .github/workflows/comprehensive-gitops.yml
                      
                      # Replace placeholders in workflow file
                      
                      # Create shared library structure
                      cat > shared-libs/common/README.md << EOF
                      # Common Shared Library
                      
                      This directory contains shared code and utilities used across all microservices in this app container.
                      
                      ## Structure
                      - `src/` - Shared source code
                      - `tests/` - Shared tests
                      - `docs/` - Shared documentation
                      EOF
                      
                      # Create microservices README
                      cat > microservices/README.md << EOF
                      # Microservices
                      
                      This directory contains all microservices for the application container.
                      Each subdirectory represents a single microservice following CLAUDE.md standards.
                      
                      ## Adding New Microservices
                      
                      Use ApplicationClaim to add new microservices:
                      
                      ```yaml
                      apiVersion: platform.example.org/v1alpha1
                      kind: ApplicationClaim
                      metadata:
                        name: my-service
                      spec:
                        appContainer: $APP_NAME
                        name: my-service
                        language: python
                        framework: fastapi
                        database: postgres
                        cache: redis
                      ```
                      
                      ## Current Services
                      
                      - (Services will be listed here as they are added)
                      EOF
                      
                      # Create main README
                      cat > README.md << EOF
                      # $APP_NAME Application Container
                      
                      CLAUDE.md-compliant microservices application container with GitOps deployment.
                      
                      ## Architecture
                      
                      This application container follows the CLAUDE.md development methodology:
                      
                      - **Microservices**: Each service in `microservices/` follows Onion Architecture
                      - **Shared Libraries**: Common code in `shared-libs/`
                      - **GitOps**: Automated deployment via companion GitOps repository
                      - **CI/CD**: Automatic building and deployment of changed services
                      
                      ## Structure
                      
                      ```
                      $APP_NAME/
                      ├── microservices/          # Individual microservices
                      ├── shared-libs/           # Shared libraries and utilities  
                      ├── .github/workflows/     # CI/CD pipelines
                      └── README.md              # This file
                      ```
                      
                      ## Development Workflow
                      
                      1. Create microservices using ApplicationClaim in your vCluster
                      2. CI/CD automatically detects changes in `microservices/`
                      3. Changed services are built and deployed via GitOps
                      4. Monitor deployments in ArgoCD
                      
                      ## Adding New Services
                      
                      Edit the OAM Application in the GitOps repository:
                      
                      ```yaml
                      # File: oam/application.yaml
                      apiVersion: core.oam.dev/v1beta1
                      kind: Application
                      metadata:
                        name: $APP_NAME
                      spec:
                        components:
                        - name: my-service
                          type: microservice-with-db
                          properties:
                            language: python
                            framework: fastapi
                            database: postgres
                            cache: redis
                      ```
                      
                      ## GitOps Repository
                      
                      Deployment manifests are managed in the companion GitOps repository:
                      `$GITOPS_CLONE_URL`
                      EOF
                      
                      # Commit and push
                      git config user.name "AppContainer Setup"
                      git config user.email "appcontainer@platform.local"
                      git add .
                      git commit -m "Initialize CLAUDE.md-compliant app container structure
                      
                      - Add microservices directory structure
                      - Add comprehensive GitOps CI/CD pipeline
                      - Add shared libraries framework
                      - Add documentation and examples
                      - Follow CLAUDE.md development methodology"
                      git push
                      
                      echo "Source repository structure created successfully"
                    env:
                    - name: APP_NAME
                      value: placeholder
                    - name: SOURCE_CLONE_URL
                      value: placeholder
                    - name: GITOPS_CLONE_URL
                      value: placeholder
                    - name: DOCKER_REGISTRY_USER
                      value: placeholder
                    - name: GITHUB_TOKEN
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: token
                    - name: GITHUB_REPO
                      value: placeholder
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-source-setup"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
    - type: CombineFromComposite
      combine:
        variables:
        - fromFieldPath: spec.gitHubOrg
        - fromFieldPath: spec.name
        strategy: string
        string:
          fmt: "https://github.com/%s/%s.git"
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
    - type: CombineFromComposite
      combine:
        variables:
        - fromFieldPath: spec.gitHubOrg
        - fromFieldPath: spec.name
        strategy: string
        string:
          fmt: "https://github.com/%s/%s-gitops.git"
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].value
      policy:
        fromFieldPath: Required
    - type: FromCompositeFieldPath
      fromFieldPath: spec.gitHubOrg
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[3].value
    - type: CombineFromComposite
      combine:
        variables:
        - fromFieldPath: spec.gitHubOrg
        - fromFieldPath: spec.name
        strategy: string
        string:
          fmt: "%s/%s"
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[5].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-source-setup"

  # Setup GitOps Repository Structure 
  - name: gitops-repo-setup
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: default
            spec:
              template:
                spec:
                  serviceAccountName: crossplane-github-provider
                  restartPolicy: OnFailure
                  containers:
                  - name: gitops-repo-setup
                    image: alpine/git:latest
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      echo "Setting up GitOps repository structure for $APP_NAME..."
                      
                      TEMP_DIR="/tmp/gitops-$APP_NAME"
                      mkdir -p $TEMP_DIR
                      cd $TEMP_DIR
                      
                      # Clone the GitOps repository
                      git clone $GITOPS_CLONE_URL .
                      
                      # Configure git with authentication for push
                      git config user.name "GitOps Setup"
                      git config user.email "gitops@platform.local"
                      git remote set-url origin "https://${GITHUB_TOKEN}@github.com/${GITHUB_REPO}-gitops.git"
                      
                      # Create GitOps structure matching OAM-DRIVEN-DEVELOPMENT-GUIDE.md
                      mkdir -p apps
                      mkdir -p apps/environments/{dev,staging,production}
                      mkdir -p oam/applications
                      mkdir -p oam/components  
                      mkdir -p oam/workflows
                      mkdir -p manifests
                      mkdir -p .github/workflows
                      
                      # Create blank OAM Application template
                      cat > oam/applications/application.yaml << EOF
                      apiVersion: core.oam.dev/v1beta1
                      kind: Application
                      metadata:
                        name: $APP_NAME
                        namespace: $APP_NAME
                      spec:
                        components:
                        - name: $APP_NAME
                          type: webservice
                          properties:
                            name: $APP_NAME
                            language: python
                            framework: fastapi
                            database: postgres
                            cache: redis
                            appContainer: $APP_NAME
                            exposeApi: true
                        # Add your components here using the following types:
                        # - microservice-with-db: Full-featured microservice with database and cache
                        # - react-frontend: React TypeScript frontend with Material-UI
                        # - static-site: Static website hosting
                        # - kafka-service: Event streaming service
                        # - data-pipeline: ETL and data processing workflows
                        # 
                        # Example:
                        # components:
                        # - name: api-backend
                        #   type: microservice-with-db
                        #   properties:
                        #     language: python
                        #     framework: fastapi
                        #     database: postgres
                        #     cache: redis
                        #     exposeApi: true
                        # - name: web-frontend
                        #   type: react-frontend
                        #   properties:
                        #     framework: react
                        #     styling: material-ui
                        #     apiEndpoint: /api
                        
                        # Workflow configuration for proper component ordering
                        workflow:
                          steps:
                          - name: provision-infrastructure
                            type: create-crossplane-claims
                            timeout: 15m
                          - name: wait-for-infrastructure
                            type: wait-for-claims
                            timeout: 10m
                            dependsOn: ["provision-infrastructure"]
                          - name: deploy-applications
                            type: create-crossplane-claims
                            timeout: 10m
                            dependsOn: ["wait-for-infrastructure"]
                          - name: validate-deployment
                            type: wait-for-claims
                            timeout: 5m
                            dependsOn: ["deploy-applications"]
                          
                          # Failure handling
                          onFailure:
                            steps:
                            - name: cleanup-resources
                              type: cleanup-failed-claims
                              timeout: 5m
                        
                        # Policies for execution order
                        policies:
                        - name: execution-order
                          type: crossplane-execution-order
                          properties:
                            phases: ["infrastructure", "application"]
                            phaseDelay: "30s"
                            parallelWithinPhase: true
                        
                        # Traits for automatic workflow execution
                        traits:
                        - type: crossplane-workflow
                          properties:
                            enabled: true
                            timeout: "30m"
                            retries: 3
                            cleanupOnFailure: true
                      EOF
                      
                      # Create workflow templates directory
                      cat > oam/workflows/README.md << EOF
                      # OAM Workflows
                      
                      This directory contains KubeVela workflow definitions for managing application lifecycle.
                      
                      ## Available Workflows
                      
                      - `crossplane-integration.yaml` - Handles OAM → Crossplane ApplicationClaim creation
                      - `dependency-management.yaml` - Manages component dependencies and ordering
                      - `failure-recovery.yaml` - Handles failure scenarios and cleanup
                      
                      ## Usage
                      
                      Workflows are automatically triggered when OAM Applications are created or updated.
                      The system handles:
                      
                      1. **Infrastructure Provisioning**: Databases, caches, messaging systems
                      2. **Application Deployment**: Microservices, frontends, static sites
                      3. **Pipeline Orchestration**: Data processing workflows
                      4. **Dependency Management**: Proper ordering and readiness checks
                      5. **Failure Recovery**: Cleanup and retry mechanisms
                      EOF
                      
                      # Create components directory with examples
                      cat > oam/components/README.md << EOF
                      # OAM Components
                      
                      This directory contains generated OAM Component definitions created by ApplicationClaims.
                      
                      ## Generated Components
                      
                      When you add components to `oam/applications/application.yaml`, the system automatically:
                      
                      1. Creates ApplicationClaims in the vCluster
                      2. Generates OAM Component definitions here
                      3. Creates Kubernetes manifests in `../manifests/`
                      4. Updates ArgoCD applications for deployment
                      
                      ## Component Types
                      
                      - **microservice-with-db**: Full-featured microservice with database and cache
                      - **react-frontend**: React TypeScript frontend with Material-UI
                      - **static-site**: Static website hosting
                      - **kafka-service**: Event streaming service
                      - **data-pipeline**: ETL and data processing workflows
                      
                      ## Example Generated Component
                      
                      ```yaml
                      apiVersion: core.oam.dev/v1beta1
                      kind: Component
                      metadata:
                        name: user-service
                        namespace: $APP_NAME
                      spec:
                        workload:
                          apiVersion: serving.knative.dev/v1
                          kind: Service
                          metadata:
                            name: user-service
                          spec:
                            template:
                              spec:
                                containers:
                                - name: user-service
                                  image: docker.io/socrates12345/user-service:latest
                        parameters:
                        - name: image
                          fieldPaths: ["spec.template.spec.containers[0].image"]
                      ```
                      EOF
                      
                      # Create OAM Application ArgoCD Application
                      cat > apps/oam-application.yaml << EOF
                      apiVersion: argoproj.io/v1alpha1
                      kind: Application
                      metadata:
                        name: $APP_NAME-oam-app
                        namespace: argocd
                        finalizers:
                          - resources-finalizer.argocd.argoproj.io
                        annotations:
                          argocd.argoproj.io/sync-wave: "1"
                          notifications.argoproj.io/subscribe.on-sync-succeeded.slack: "deployments"
                      spec:
                        project: default
                        source:
                          repoURL: $GITOPS_CLONE_URL
                          targetRevision: HEAD
                          path: oam/applications
                        destination:
                          server: https://kubernetes.default.svc
                          namespace: $APP_NAME
                        syncPolicy:
                          automated:
                            prune: true
                            selfHeal: true
                          syncOptions:
                            - CreateNamespace=true
                            - RespectIgnoreDifferences=true
                          retry:
                            limit: 5
                            backoff:
                              duration: 5s
                              factor: 2
                              maxDuration: 3m
                        # Watch for changes in OAM Application
                        info:
                        - name: Description
                          value: OAM Application that drives Crossplane ApplicationClaim creation
                        - name: Workflow
                          value: Automatically creates ApplicationClaims when OAM components are added
                      EOF
                      
                      # Create ArgoCD Application for OAM Applications
                      cat > apps/oam-application.yaml << EOF
                      apiVersion: argoproj.io/v1alpha1
                      kind: Application
                      metadata:
                        name: $APP_NAME-oam-application
                        namespace: argocd
                        annotations:
                          argocd.argoproj.io/sync-wave: "2"
                      spec:
                        project: default
                        source:
                          repoURL: $GITOPS_CLONE_URL
                          targetRevision: HEAD
                          path: oam/applications
                        destination:
                          server: https://kubernetes.default.svc
                          namespace: vela-system
                        syncPolicy:
                          automated:
                            prune: true
                            selfHeal: true
                          syncOptions:
                            - CreateNamespace=true
                            - ServerSideApply=true
                      EOF
                      
                      # Create App of Apps ArgoCD Application
                      cat > apps/app-of-apps.yaml << EOF
                      apiVersion: argoproj.io/v1alpha1
                      kind: Application
                      metadata:
                        name: $APP_NAME-app-of-apps
                        namespace: argocd
                        finalizers:
                          - resources-finalizer.argocd.argoproj.io
                      spec:
                        project: default
                        source:
                          repoURL: $GITOPS_CLONE_URL
                          targetRevision: HEAD
                          path: apps
                        destination:
                          server: https://kubernetes.default.svc
                          namespace: $APP_NAME
                        syncPolicy:
                          automated:
                            prune: true
                            selfHeal: true
                          syncOptions:
                            - CreateNamespace=true
                      EOF
                      
                      # Create ApplicationSet for microservices
                      
                      # Create GitOps update workflow from template
                      cat > .github/workflows/deployment-update.yml << EOF
                      name: GitOps Deployment Update
                      
                      on:
                        repository_dispatch:
                          types: [update-deployments, simple-update]
                      
                      permissions:
                        contents: write
                      
                      jobs:
                        update-manifests:
                          runs-on: ubuntu-latest
                          steps:
                            - name: Checkout GitOps repository
                              uses: actions/checkout@v4
                              with:
                                token: ${{ secrets.GITHUB_TOKEN }}
                      
                            - name: Update deployment manifests
                              run: |
                                echo "🚀 Processing GitOps deployment update..."
                                
                                # Extract dispatch payload
                                SERVICES="${{ github.event.client_payload.services }}"
                                VERSION_INFO="${{ github.event.client_payload.version_info }}"
                                SOURCE_COMMIT="${{ github.event.client_payload.source_commit }}"
                                REGISTRY="${{ github.event.client_payload.registry }}"
                                WORKFLOW_RUN="${{ github.event.client_payload.workflow_run }}"
                                
                                echo "Services to update: $SERVICES"
                                echo "Version info: $VERSION_INFO" 
                                echo "Source commit: $SOURCE_COMMIT"
                                echo "Registry: $REGISTRY"
                                
                                # Handle different event types
                                if [ "${{ github.event.action }}" = "simple-update" ]; then
                                  echo "📋 Processing simple-update event"
                                  COMMIT_SHA="${{ github.event.client_payload.commit_sha }}"
                                else
                                  echo "📋 Processing update-deployments event"
                                  # Parse deployments from payload
                                  DEPLOYMENTS='${{ toJson(github.event.client_payload.deployments) }}'
                                  echo "Deployments: $DEPLOYMENTS"
                                fi
                                
                                # Update each service's manifest
                                IFS=',' read -ra SERVICE_ARRAY <<< "$SERVICES"
                                
                                for service in "${SERVICE_ARRAY[@]}"; do
                                  echo "🔄 Updating $service manifest..."
                                  
                                  if [ "${{ github.event.action }}" = "simple-update" ]; then
                                    # Simple update: construct image from registry and commit
                                    NEW_IMAGE="${REGISTRY}/$service:$COMMIT_SHA"
                                  else
                                    # Complex update: extract from deployments JSON
                                    echo "🔍 Parsing deployments JSON for service: $service"
                                    echo "Raw deployments: $DEPLOYMENTS"
                                    
                                    # Parse the JSON string (it comes as a string, not object)
                                    DEPLOYMENTS_PARSED=$(echo "$DEPLOYMENTS" | jq -r '. // empty')
                                    if [ "$DEPLOYMENTS_PARSED" = "null" ] || [ -z "$DEPLOYMENTS_PARSED" ]; then
                                      # Try parsing as raw string
                                      DEPLOYMENTS_PARSED="$DEPLOYMENTS"
                                    fi
                                    
                                    NEW_IMAGE=$(echo "$DEPLOYMENTS_PARSED" | jq -r ".\"$service\".image // empty")
                                    COMMIT_SHA=$(echo "$DEPLOYMENTS_PARSED" | jq -r ".\"$service\".commit // empty")
                                    
                                    echo "Extracted - Image: $NEW_IMAGE, Commit: $COMMIT_SHA"
                                    
                                    if [ -z "$NEW_IMAGE" ] || [ "$NEW_IMAGE" = "null" ]; then
                                      echo "⚠️ No image found for service $service in deployments payload"
                                      echo "Available keys in deployments:"
                                      echo "$DEPLOYMENTS_PARSED" | jq -r 'keys[]?' 2>/dev/null || echo "Failed to parse keys"
                                      continue
                                    fi
                                  fi
                                  
                                  echo "📝 Updating $service to image: $NEW_IMAGE"
                                  
                                  # Find OAM application file - project-specific path
                                  OAM_FILE="oam/applications/${service}.yaml"
                                  if [ ! -f "$OAM_FILE" ]; then
                                    # Try other possible locations specific to this project
                                    OAM_FILE=$(find oam -name "*${service}*.yaml" | head -1)
                                  fi
                                  
                                  if [ -f "$OAM_FILE" ]; then
                                    echo "📄 Updating manifest: $OAM_FILE"
                                    
                                    # Update the image in the OAM file
                                    sed -i "s|image: .*/$service:.*|image: $NEW_IMAGE|g" "$OAM_FILE"
                                    
                                    # Update version labels if they exist
                                    if [ ! -z "$COMMIT_SHA" ]; then
                                      sed -i "s|version: .*|version: $COMMIT_SHA|g" "$OAM_FILE"
                                    fi
                                    
                                    echo "✅ Updated $service manifest successfully"
                                  else
                                    echo "⚠️ Warning: Could not find OAM file for $service"
                                    echo "Available OAM files:"
                                    find oam -name "*.yaml" -type f 2>/dev/null || echo "No OAM files found"
                                  fi
                                done
                      
                            - name: Commit and push changes
                              run: |
                                # Configure git
                                git config user.name "GitOps Bot"
                                git config user.email "gitops-bot@github.com"
                                
                                # Check if there are changes
                                if git diff --quiet; then
                                  echo "ℹ️ No changes detected in GitOps manifests"
                                else
                                  echo "📋 Changes detected:"
                                  git diff --name-only
                                  
                                  # Show what changed
                                  echo "📝 Detailed changes:"
                                  git diff
                                  
                                  # Commit changes
                                  git add .
                                  git commit -m "chore: update service deployments from source commit ${{ github.event.client_payload.source_commit }}
                      
                                  Services updated: ${{ github.event.client_payload.services }}
                                  Source workflow: ${{ github.event.client_payload.workflow_run }}
                                  Triggered by: repository_dispatch
                                  
                                  Updated images:
                                  $(echo '${{ toJson(github.event.client_payload.deployments) }}' | jq -r 'to_entries[] | "- \(.key): \(.value.image)"' 2>/dev/null || echo "- Services: ${{ github.event.client_payload.services }}")"
                                  
                                  git push
                                  
                                  echo "✅ GitOps manifests updated and pushed successfully!"
                                  echo "🔄 ArgoCD will now detect and deploy the changes"
                                fi
                      
                            - name: Summary
                              run: |
                                echo "## 🎯 GitOps Deployment Update Complete" >> $GITHUB_STEP_SUMMARY
                                echo "" >> $GITHUB_STEP_SUMMARY
                                echo "**Services Updated:** ${{ github.event.client_payload.services }}" >> $GITHUB_STEP_SUMMARY
                                echo "**Source Commit:** \`${{ github.event.client_payload.source_commit }}\`" >> $GITHUB_STEP_SUMMARY
                                echo "**Registry:** ${{ github.event.client_payload.registry }}" >> $GITHUB_STEP_SUMMARY
                                echo "" >> $GITHUB_STEP_SUMMARY
                                echo "🚀 **Next Steps:** ArgoCD will detect manifest changes and deploy to cluster" >> $GITHUB_STEP_SUMMARY
                      EOF
                      
                      # Create README
                      cat > README.md << EOF
                      # $APP_NAME GitOps Repository
                      
                      This repository contains the GitOps deployment manifests for the $APP_NAME application container.
                      
                      ## Structure
                      
                      ```
                      $APP_NAME-gitops/
                      ├── apps/                    # ArgoCD Applications
                      │   ├── app-of-apps.yaml    # Main App of Apps
                      │   └── environments/       # Environment-specific configs
                      ├── oam/                     # OAM Applications and Components
                      │   ├── applications/        # OAM Applications (edit here)
                      │   ├── components/          # Generated OAM Components
                      │   └── workflows/           # Workflow definitions
                      ├── manifests/               # Kubernetes manifests per service
                      │   ├── service-1/          # Each microservice directory
                      │   └── service-2/
                      └── .github/workflows/       # GitOps automation
                      ```
                      
                      ## Deployment Flow
                      
                      1. Source repository CI/CD builds and pushes images
                      2. Source CI/CD sends repository_dispatch to this repo
                      3. GitOps workflow updates manifest files with new image tags
                      4. ArgoCD detects changes and deploys to cluster
                      
                      ## ArgoCD Applications
                      
                      - **App of Apps**: `$APP_NAME-app-of-apps` - Main application managing all microservices
                      - **ApplicationSet**: Automatically creates ArgoCD apps for each service in `manifests/`
                      
                      ## Adding New Services
                      
                      When ApplicationClaim creates a new microservice, it automatically:
                      1. Creates a directory in `manifests/[service-name]/`
                      2. Generates Knative service and OAM component manifests
                      3. Updates the ApplicationSet to include the new service
                      EOF
                      
                      # Commit and push
                      git config user.name "GitOps Setup"
                      git config user.email "gitops@platform.local"
                      git add .
                      git commit -m "Initialize GitOps repository structure
                      
                      - Add ArgoCD App of Apps pattern
                      - Add ApplicationSet for microservices
                      - Add GitOps update automation
                      - Add environment structure
                      - Add OAM and manifests directories"
                      git push
                      
                      echo "GitOps repository structure created successfully"
                    env:
                    - name: APP_NAME
                      value: placeholder
                    - name: GITOPS_CLONE_URL
                      value: placeholder
                    - name: GITHUB_TOKEN
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: token
                    - name: GITHUB_REPO
                      value: placeholder
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-gitops-setup"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
    - type: CombineFromComposite
      combine:
        variables:
        - fromFieldPath: spec.gitHubOrg
        - fromFieldPath: spec.name
        strategy: string
        string:
          fmt: "https://github.com/%s/%s-gitops.git"
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
      policy:
        fromFieldPath: Required
    - type: CombineFromComposite
      combine:
        variables:
        - fromFieldPath: spec.gitHubOrg
        - fromFieldPath: spec.name
        strategy: string
        string:
          fmt: "%s/%s"
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[3].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-gitops-setup"

  # Setup Repository Secrets and Variables
  - name: repository-secrets-setup
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder-secrets-setup
              namespace: default
            spec:
              template:
                spec:
                  restartPolicy: Never
                  containers:
                  - name: setup
                    image: python:3.11-slim
                    command:
                    - /bin/sh
                    - -c
                    - |
                      # Install required packages
                      apt-get update && apt-get install -y curl jq git
                      pip install pynacl requests
                      
                      echo "Setting up repository secrets and variables..."
                      
                      # Set repository variables for GitHub Actions
                      echo "Creating repository variables..."
                      curl -X PATCH \
                        -H "Authorization: token ${GITHUB_TOKEN}" \
                        -H "Accept: application/vnd.github.v3+json" \
                        "https://api.github.com/repos/${GITHUB_REPO}/actions/variables/DOCKER_REGISTRY_USER" \
                        -d '{"name":"DOCKER_REGISTRY_USER","value":"socrates12345"}' || \
                      curl -X POST \
                        -H "Authorization: token ${GITHUB_TOKEN}" \
                        -H "Accept: application/vnd.github.v3+json" \
                        "https://api.github.com/repos/${GITHUB_REPO}/actions/variables" \
                        -d '{"name":"DOCKER_REGISTRY_USER","value":"socrates12345"}'
                      
                      curl -X PATCH \
                        -H "Authorization: token ${GITHUB_TOKEN}" \
                        -H "Accept: application/vnd.github.v3+json" \
                        "https://api.github.com/repos/${GITHUB_REPO}/actions/variables/APP_NAME" \
                        -d "{\"name\":\"APP_NAME\",\"value\":\"${APP_NAME}\"}" || \
                      curl -X POST \
                        -H "Authorization: token ${GITHUB_TOKEN}" \
                        -H "Accept: application/vnd.github.v3+json" \
                        "https://api.github.com/repos/${GITHUB_REPO}/actions/variables" \
                        -d "{\"name\":\"APP_NAME\",\"value\":\"${APP_NAME}\"}"
                      
                      # Get public key for secret encryption
                      echo "Creating repository secrets..."
                      PUBLIC_KEY_DATA=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" \
                        "https://api.github.com/repos/${GITHUB_REPO}/actions/secrets/public-key")
                      
                      PUBLIC_KEY=$(echo "$PUBLIC_KEY_DATA" | jq -r .key)
                      KEY_ID=$(echo "$PUBLIC_KEY_DATA" | jq -r .key_id)
                      
                      # Create Python script to properly encrypt secrets
                      cat > encrypt_secret.py << 'EOF'
                      import base64
                      import sys
                      from nacl import encoding, public
                      
                      def encrypt_secret(public_key_b64, secret_value):
                          """Encrypt a secret using GitHub's public key"""
                          public_key = public.PublicKey(public_key_b64.encode("utf-8"), encoding.Base64Encoder())
                          sealed_box = public.SealedBox(public_key)
                          encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
                          return base64.b64encode(encrypted).decode("utf-8")
                      
                      if __name__ == "__main__":
                          public_key = sys.argv[1]
                          secret_value = sys.argv[2]
                          print(encrypt_secret(public_key, secret_value))
                      EOF
                      
                      # Create PERSONAL_ACCESS_TOKEN secret with proper encryption
                      ENCRYPTED_TOKEN=$(python encrypt_secret.py "$PUBLIC_KEY" "$GITHUB_TOKEN")
                      curl -X PUT \
                        -H "Authorization: token ${GITHUB_TOKEN}" \
                        -H "Accept: application/vnd.github.v3+json" \
                        "https://api.github.com/repos/${GITHUB_REPO}/actions/secrets/PERSONAL_ACCESS_TOKEN" \
                        -d "{\"encrypted_value\":\"$ENCRYPTED_TOKEN\",\"key_id\":\"$KEY_ID\"}"
                      
                      # Create DOCKER_PASSWORD secret with proper encryption
                      ENCRYPTED_PASSWORD=$(python encrypt_secret.py "$PUBLIC_KEY" "$DOCKER_PASSWORD")
                      curl -X PUT \
                        -H "Authorization: token ${GITHUB_TOKEN}" \
                        -H "Accept: application/vnd.github.v3+json" \
                        "https://api.github.com/repos/${GITHUB_REPO}/actions/secrets/DOCKER_PASSWORD" \
                        -d "{\"encrypted_value\":\"$ENCRYPTED_PASSWORD\",\"key_id\":\"$KEY_ID\"}"
                      
                      echo "Repository setup completed successfully!"
                    env:
                    - name: GITHUB_TOKEN
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: token
                    - name: DOCKER_PASSWORD
                      valueFrom:
                        secretKeyRef:
                          name: docker-credentials
                          key: password
                    - name: GITHUB_REPO
                      value: placeholder
                    - name: APP_NAME
                      value: placeholder
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-secrets-setup"
    - type: CombineFromComposite
      combine:
        variables:
        - fromFieldPath: spec.gitHubOrg
        - fromFieldPath: spec.name
        strategy: string
        string:
          fmt: "%s/%s"
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[3].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-secrets-setup"