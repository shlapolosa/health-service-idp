---
# Secret Injector Composition for Cross-Component Discovery and Injection
# This composition creates a Job that discovers realtime platform secrets and injects them into webservice deployments
apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: secret-injector-composition
  labels:
    crossplane.io/xrd: xsecretinjectors.platform.example.org
    provider: kubernetes
    component-type: secret-management
spec:
  writeConnectionSecretsToNamespace: crossplane-system
  compositeTypeRef:
    apiVersion: platform.example.org/v1alpha1
    kind: XSecretInjector
  resources:

  # Secret Discovery and Injection Job
  - name: secret-injector-job
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: placeholder
              labels:
                app.kubernetes.io/name: "secret-injector"
                app.kubernetes.io/component: "secret-management"
                app.kubernetes.io/managed-by: "crossplane"
              annotations:
                description: "Cross-component secret discovery and injection"
                secret-injector.platform.example.org/version: "v1.0"
            spec:
              template:
                spec:
                  serviceAccountName: secret-injector-sa
                  restartPolicy: OnFailure
                  containers:
                  - name: secret-injector
                    image: bitnami/kubectl:latest
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      echo "üîç Secret Injector: Discovering realtime platform secrets..."
                      echo "Target webservice: $WEBSERVICE_NAME"
                      echo "Realtime platform: $REALTIME_PLATFORM_NAME"
                      echo "Namespace: $TARGET_NAMESPACE"
                      
                      # Standardized secret naming pattern: {platform-name}-{service}-secret
                      KAFKA_SECRET="${REALTIME_PLATFORM_NAME}-kafka-secret"
                      MQTT_SECRET="${REALTIME_PLATFORM_NAME}-mqtt-secret"
                      DB_SECRET="${REALTIME_PLATFORM_NAME}-db-secret"
                      METABASE_SECRET="${REALTIME_PLATFORM_NAME}-metabase-secret"
                      LENSES_SECRET="${REALTIME_PLATFORM_NAME}-lenses-secret"
                      
                      echo "üìã Expected secret names:"
                      echo "  Kafka: $KAFKA_SECRET"
                      echo "  MQTT: $MQTT_SECRET" 
                      echo "  Database: $DB_SECRET"
                      echo "  Metabase: $METABASE_SECRET"
                      echo "  Lenses: $LENSES_SECRET"
                      
                      # Discover available secrets
                      DISCOVERED_SECRETS=""
                      SECRET_COUNT=0
                      
                      echo "üîé Discovering available secrets..."
                      for SECRET in $KAFKA_SECRET $MQTT_SECRET $DB_SECRET $METABASE_SECRET $LENSES_SECRET; do
                        if kubectl get secret "$SECRET" -n "$TARGET_NAMESPACE" --ignore-not-found 2>/dev/null | grep -q "$SECRET"; then
                          echo "‚úÖ Found: $SECRET"
                          DISCOVERED_SECRETS="$DISCOVERED_SECRETS $SECRET"
                          SECRET_COUNT=$((SECRET_COUNT + 1))
                          
                          # Add discoverability labels
                          kubectl label secret "$SECRET" -n "$TARGET_NAMESPACE" \
                            "app.kubernetes.io/discoverable=true" \
                            "realtime.platform.example.org/name=$REALTIME_PLATFORM_NAME" \
                            "webservice.example.org/injectable=true" \
                            --overwrite 2>/dev/null || echo "Warning: Could not label $SECRET"
                        else
                          echo "‚ùå Missing: $SECRET"
                        fi
                      done
                      
                      echo "üìä Discovery Summary:"
                      echo "  Total secrets found: $SECRET_COUNT"
                      echo "  Discovered secrets: $DISCOVERED_SECRETS"
                      
                      if [ $SECRET_COUNT -eq 0 ]; then
                        echo "‚ö†Ô∏è No secrets discovered for realtime platform: $REALTIME_PLATFORM_NAME"
                        echo "   Ensure the realtime platform is deployed and secrets are created"
                        exit 0
                      fi
                      
                      # Find target webservice (Knative Service)
                      echo "üéØ Looking for webservice: $WEBSERVICE_NAME"
                      
                      if ! kubectl get ksvc "$WEBSERVICE_NAME" -n "$TARGET_NAMESPACE" --ignore-not-found 2>/dev/null | grep -q "$WEBSERVICE_NAME"; then
                        echo "‚ö†Ô∏è Webservice not found: $WEBSERVICE_NAME"
                        echo "   The webservice may not be deployed yet. Secrets are labeled for future injection."
                        exit 0
                      fi
                      
                      echo "‚úÖ Found webservice: $WEBSERVICE_NAME"
                      
                      # Create or update integration secret for the webservice
                      INTEGRATION_SECRET="${WEBSERVICE_NAME}-${REALTIME_PLATFORM_NAME}-integration"
                      
                      echo "üîß Creating integration secret: $INTEGRATION_SECRET"
                      
                      cat <<EOF | kubectl apply -f -
                      apiVersion: v1
                      kind: Secret
                      metadata:
                        name: $INTEGRATION_SECRET
                        namespace: $TARGET_NAMESPACE
                        labels:
                          app.kubernetes.io/managed-by: "secret-injector"
                          app.kubernetes.io/component: "secret-integration"
                          realtime.platform.example.org/integration: "$REALTIME_PLATFORM_NAME"
                          webservice.example.org/target: "$WEBSERVICE_NAME"
                        annotations:
                          secret-injector.platform.example.org/discovery-timestamp: "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
                          secret-injector.platform.example.org/secret-count: "$SECRET_COUNT"
                          secret-injector.platform.example.org/discovered-secrets: "$DISCOVERED_SECRETS"
                      type: Opaque
                      stringData:
                        REALTIME_PLATFORM_NAME: "$REALTIME_PLATFORM_NAME"
                        WEBSERVICE_NAME: "$WEBSERVICE_NAME"
                        INTEGRATION_ENABLED: "true"
                        SECRET_DISCOVERY_PATTERN: "${REALTIME_PLATFORM_NAME}-*-secret"
                        DISCOVERED_SECRET_COUNT: "$SECRET_COUNT"
                      EOF
                      
                      # Annotate the webservice for integration status
                      echo "üìù Updating webservice annotations..."
                      
                      kubectl annotate ksvc "$WEBSERVICE_NAME" -n "$TARGET_NAMESPACE" \
                        "realtime.platform.example.org/integration=$REALTIME_PLATFORM_NAME" \
                        "secret-injector.platform.example.org/secrets-injected=true" \
                        "secret-injector.platform.example.org/injection-timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                        "secret-injector.platform.example.org/secret-count=$SECRET_COUNT" \
                        --overwrite 2>/dev/null || echo "Warning: Could not annotate webservice"
                      
                      echo "‚úÖ Secret injection completed successfully!"
                      echo "üìä Integration Summary:"
                      echo "   Webservice: $WEBSERVICE_NAME"
                      echo "   Realtime Platform: $REALTIME_PLATFORM_NAME"
                      echo "   Secrets Available: $SECRET_COUNT"
                      echo "   Integration Secret: $INTEGRATION_SECRET"
                      echo "   Status: Ready for use"
                      
                      # Validation check
                      echo "üîç Validation: Checking integration status..."
                      if kubectl get secret "$INTEGRATION_SECRET" -n "$TARGET_NAMESPACE" >/dev/null 2>&1; then
                        echo "‚úÖ Integration secret created successfully"
                      else
                        echo "‚ùå Integration secret creation failed"
                        exit 1
                      fi
                      
                      echo "üéâ Secret injection process completed!"
                    env:
                    - name: WEBSERVICE_NAME
                      value: "placeholder"
                    - name: REALTIME_PLATFORM_NAME
                      value: "placeholder"
                    - name: TARGET_NAMESPACE
                      value: "placeholder"
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.webserviceName
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-secret-injector"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.namespace
      toFieldPath: spec.forProvider.manifest.metadata.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.webserviceName
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtimePlatformName
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.namespace
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.webserviceName
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-secret-injector"

  # ServiceAccount for secret injection operations
  - name: secret-injector-serviceaccount
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: ServiceAccount
            metadata:
              name: secret-injector-sa
              namespace: placeholder
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.namespace
      toFieldPath: spec.forProvider.manifest.metadata.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.namespace
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-secret-injector-sa"

  # ClusterRole for secret injection operations
  - name: secret-injector-clusterrole
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRole
            metadata:
              name: secret-injector-role
            rules:
            - apiGroups: [""]
              resources: ["secrets"]
              verbs: ["get", "list", "create", "update", "patch", "label"]
            - apiGroups: ["serving.knative.dev"]
              resources: ["services"]
              verbs: ["get", "list", "annotate", "patch"]
            - apiGroups: [""]
              resources: ["configmaps"]
              verbs: ["get", "list"]
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.webserviceName
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-secret-injector-role"

  # ClusterRoleBinding for secret injection operations
  - name: secret-injector-clusterrolebinding
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRoleBinding
            metadata:
              name: secret-injector-binding
            roleRef:
              apiGroup: rbac.authorization.k8s.io
              kind: ClusterRole
              name: secret-injector-role
            subjects:
            - kind: ServiceAccount
              name: secret-injector-sa
              namespace: placeholder
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.webserviceName
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-secret-injector-binding"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.webserviceName
      toFieldPath: spec.forProvider.manifest.roleRef.name
      transforms:
      - type: string
        string:
          fmt: "%s-secret-injector-role"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.namespace
      toFieldPath: spec.forProvider.manifest.subjects[0].namespace