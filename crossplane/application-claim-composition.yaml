apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: application-claim-composition
  labels:
    crossplane.io/xrd: xapplicationclaims.platform.example.org
    provider: github-kubernetes-helm
spec:
  writeConnectionSecretsToNamespace: crossplane-system
  compositeTypeRef:
    apiVersion: platform.example.org/v1alpha1
    kind: XApplicationClaim
  resources:
  
  # Add microservice to existing AppContainer source repository
  - name: add-microservice-to-container
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: default
            spec:
              template:
                spec:
                  serviceAccountName: crossplane-github-provider
                  restartPolicy: OnFailure
                  containers:
                  - name: microservice-creator
                    image: alpine:3.18
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      # Install git, curl, and jq
                      apk add --no-cache git curl jq
                      echo "Adding microservice $SERVICE_NAME to AppContainer $APP_CONTAINER..."
                      
                      TEMP_DIR="/tmp/app-container-$APP_CONTAINER"
                      mkdir -p $TEMP_DIR
                      cd $TEMP_DIR
                      
                      # Clone the AppContainer repository using GitHub token
                      git clone https://$GITHUB_TOKEN@github.com/$GITHUB_USER/$APP_CONTAINER.git .
                      
                      # Determine template repository based on service type
                      if [ "$LANGUAGE" = "python" ] && [ "$FRAMEWORK" = "fastapi" ]; then
                        TEMPLATE_REPO="onion-architecture-template"
                        echo "üèóÔ∏è Using onion architecture template for Python/FastAPI service"
                      elif [ "$LANGUAGE" = "rasa" ] && [ "$FRAMEWORK" = "chatbot" ]; then
                        TEMPLATE_REPO="chat-template"
                        echo "ü§ñ Using chat template for RASA chatbot service"
                      else
                        echo "‚ùå Unsupported service type: $LANGUAGE/$FRAMEWORK"
                        exit 1
                      fi
                      
                      # Clone template repository
                      TEMPLATE_DIR="/tmp/template-$SERVICE_NAME"
                      mkdir -p $TEMPLATE_DIR
                      git clone https://$GITHUB_TOKEN@github.com/$GITHUB_USER/$TEMPLATE_REPO.git $TEMPLATE_DIR
                      
                      # Create microservice directory and copy template
                      mkdir -p microservices/$SERVICE_NAME
                      
                      if [ "$LANGUAGE" = "python" ] && [ "$FRAMEWORK" = "fastapi" ]; then
                        # Copy onion architecture template
                        cp -r $TEMPLATE_DIR/* microservices/$SERVICE_NAME/
                        cd microservices/$SERVICE_NAME
                        
                        # Customize template for the specific service
                        sed -i "s/template-service/$SERVICE_NAME/g" pyproject.toml README.md
                        sed -i "s/Template Service/$SERVICE_NAME Service/g" README.md
                        
                        # Update any hardcoded references
                        find . -name "*.py" -exec sed -i "s/template_service/$SERVICE_NAME/g" {} \;
                        find . -name "*.md" -exec sed -i "s/template-service/$SERVICE_NAME/g" {} \;
                        
                        echo "‚úÖ Successfully created onion architecture microservice from template"
                      elif [ "$LANGUAGE" = "rasa" ] && [ "$FRAMEWORK" = "chatbot" ]; then
                        # Copy chat template structure 
                        cp -r $TEMPLATE_DIR/microservices/chat-template/* microservices/$SERVICE_NAME/
                        cd microservices/$SERVICE_NAME
                        
                        # Customize template for the specific service
                        sed -i "s/chat-template/$SERVICE_NAME/g" README.md docker-compose.yml
                        sed -i "s/Development Bot/$SERVICE_NAME Bot/g" docker-compose.yml
                        sed -i "s/Customer Support Bot/$SERVICE_NAME Support Bot/g" domain.yml
                        
                        # Update OAM files
                        find oam/ -name "*.yaml" -exec sed -i "s/chat-template/$SERVICE_NAME/g" {} \;
                        
                        echo "‚úÖ Successfully created RASA chatbot microservice from template"
                      fi
                      
                      # Create service README
                      cat > README.md << EOF
                      # $SERVICE_NAME
                      
                      CLAUDE.md-compliant microservice with Onion Architecture and 12-Factor principles.
                      
                      ## Architecture
                      
                      This microservice follows the Onion Architecture pattern:
                      
                      - **Domain Layer**: Business rules (`src/domain/`)
                      - **Application Layer**: Use cases (`src/application/`)
                      - **Interface Layer**: REST/API endpoints (`src/interface/`)
                      - **Infrastructure Layer**: Database, external services (`src/infrastructure/`)
                      
                      ## Development
                      
                      ### Prerequisites
                      - Python 3.11+
                      - Poetry
                      
                      ### Setup
                      ```bash
                      poetry install
                      poetry run pytest  # Run TDD tests
                      poetry run python src/main.py  # Run locally
                      ```
                      
                      ### Testing (TDD)
                      ```bash
                      poetry run pytest -v
                      ```
                      
                      ### Linting
                      ```bash
                      poetry run black src/
                      poetry run isort src/
                      poetry run mypy src/
                      ```
                      
                      ## Deployment
                      
                      This service is automatically deployed via the AppContainer CI/CD pipeline when changes are pushed to the main branch.
                      EOF
                      
                      # Update microservices README
                      cd ../../
                      if grep -q "- (Services will be listed here as they are added)" microservices/README.md; then
                        sed -i "s/- (Services will be listed here as they are added)/- $SERVICE_NAME ($LANGUAGE\/$FRAMEWORK)/" microservices/README.md
                      else
                        echo "- $SERVICE_NAME ($LANGUAGE/$FRAMEWORK)" >> microservices/README.md
                      fi
                      
                      # Commit and push
                      git config user.name "ApplicationClaim"
                      git config user.email "applicationclaim@platform.local"
                      git add .
                      git commit -m "Add $SERVICE_NAME microservice ($LANGUAGE/$FRAMEWORK)
                      
                      - Implements CLAUDE.md Onion Architecture
                      - Follows 12-Factor App principles
                      - Includes TDD test structure with pytest
                      - Dependency injection ready
                      - FastAPI with health checks
                      - Multi-stage Dockerfile
                      - Poetry for dependency management"
                      git push
                      
                      echo "Microservice $SERVICE_NAME added to AppContainer $APP_CONTAINER successfully"
                    env:
                    - name: APP_CONTAINER
                      value: placeholder
                    - name: SERVICE_NAME
                      value: placeholder
                    - name: LANGUAGE
                      value: placeholder
                    - name: FRAMEWORK
                      value: placeholder
                    - name: GITHUB_TOKEN
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: token
                    - name: GITHUB_USER
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: user
                    - name: DOCKER_REGISTRY
                      valueFrom:
                        secretKeyRef:
                          name: docker-credentials
                          key: registry
                    - name: DOCKER_USER
                      valueFrom:
                        secretKeyRef:
                          name: docker-credentials
                          key: username
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-microservice-creator"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.language
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.framework
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[3].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-microservice-creator"

  # Add CI/CD workflows to AppContainer repository (unified repository pattern)
  - name: add-gitops-manifests
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: default
            spec:
              template:
                spec:
                  serviceAccountName: crossplane-github-provider
                  restartPolicy: OnFailure
                  containers:
                  - name: gitops-manifest-creator
                    image: alpine:3.18
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      # Install git, curl, and jq
                      apk add --no-cache git curl jq
                      echo "Adding GitOps manifests for $SERVICE_NAME in $APP_CONTAINER-gitops..."
                      
                      TEMP_DIR="/tmp/gitops-$APP_CONTAINER"
                      mkdir -p $TEMP_DIR
                      cd $TEMP_DIR
                      
                      # Clone the AppContainer GitOps repository
                      git clone https://$GITHUB_TOKEN@github.com/$GITHUB_USER/$APP_CONTAINER-gitops.git .
                      
                      # Create manifests directory for the service
                      mkdir -p manifests/$SERVICE_NAME
                      cd manifests/$SERVICE_NAME
                      
                      # Create ConfigMap for environment variables
                      cat > configmap.yaml << EOF
                      apiVersion: v1
                      kind: ConfigMap
                      metadata:
                        name: $SERVICE_NAME-config
                        namespace: $APP_CONTAINER
                      data:
                        APP_ENV: "production"
                        SERVICE_NAME: "$SERVICE_NAME"
                      EOF
                      
                      # Add database config if needed
                      if [ "$DATABASE" = "postgres" ]; then
                        cat >> configmap.yaml << EOF
                        DATABASE_URL: "postgresql://\$DATABASE_USER:\$DATABASE_PASSWORD@$APP_CONTAINER-postgres-rw.$APP_CONTAINER.svc.cluster.local:5432/$SERVICE_NAME"
                      EOF
                      fi
                      
                      # Add cache config if needed  
                      if [ "$CACHE" = "redis" ]; then
                        cat >> configmap.yaml << EOF
                        REDIS_URL: "redis://:\$REDIS_PASSWORD@$APP_CONTAINER-redis-master.$APP_CONTAINER.svc.cluster.local:6379/0"
                      EOF
                      fi
                      
                      
                      # Commit and push GitOps manifests
                      cd ../..
                      git config user.name "ApplicationClaim GitOps"
                      git config user.email "applicationclaim-gitops@platform.local"
                      git add manifests/$SERVICE_NAME/
                      
                      # Only commit if there are changes
                      if ! git diff --cached --quiet; then
                        git commit -m "Add GitOps manifests for $SERVICE_NAME microservice
                      
                      - Add ConfigMap for environment variables
                      - Ready for ArgoCD deployment  
                      - Service: $SERVICE_NAME in AppContainer: $APP_CONTAINER"
                        git push
                        echo "‚úÖ GitOps manifests added for $SERVICE_NAME"
                      else
                        echo "‚úÖ GitOps manifests already exist for $SERVICE_NAME"
                      fi
                    env:
                    - name: APP_CONTAINER
                      value: placeholder
                    - name: SERVICE_NAME
                      value: placeholder
                    - name: DATABASE
                      value: placeholder
                    - name: CACHE
                      value: placeholder
                    - name: GITHUB_TOKEN
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: token
                    - name: GITHUB_USER
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: user
                    - name: DOCKER_REGISTRY
                      valueFrom:
                        secretKeyRef:
                          name: docker-credentials
                          key: registry
                    - name: DOCKER_USER
                      valueFrom:
                        secretKeyRef:
                          name: docker-credentials
                          key: username
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-gitops-creator"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.database
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.cache
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[3].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-gitops-creator"

  # PostgreSQL Database (conditional on spec.database=postgres)
  - name: postgres-database
    base:
      apiVersion: helm.crossplane.io/v1beta1
      kind: Release
      spec:
        forProvider:
          chart:
            name: postgresql
            repository: https://charts.bitnami.com/bitnami
            version: "13.2.24"
          namespace: placeholder
          skipCreateNamespace: false
          values:
            auth:
              enablePostgresUser: true
              postgresPassword: "placeholder"
              username: "placeholder"
              password: "placeholder"
              database: "placeholder"
            primary:
              persistence:
                enabled: true
                size: 10Gi
                storageClass: gp2
              resources:
                requests:
                  memory: 256Mi
                  cpu: 250m
                limits:
                  memory: 512Mi
                  cpu: 500m
              readinessProbe:
                enabled: true
                initialDelaySeconds: 30
                periodSeconds: 10
              livenessProbe:
                enabled: true
                initialDelaySeconds: 30
                periodSeconds: 10
            metrics:
              enabled: true
              serviceMonitor:
                enabled: false
            backup:
              enabled: false
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-postgres"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.auth.database
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.auth.username
    # Generate random passwords (in production, use External Secrets)
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.auth.postgresPassword
      transforms:
      - type: string
        string:
          fmt: "%s-postgres-admin-pass"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.auth.password
      transforms:
      - type: string
        string:
          fmt: "%s-user-pass"
    # Status patches for database connection info
    - type: ToCompositeFieldPath
      fromFieldPath: status.atProvider.state
      toFieldPath: status.infrastructure.database.ready
      transforms:
      - type: map
        map:
          "deployed": true
          "failed": false
      policy:
        fromFieldPath: Optional
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: status.infrastructure.database.endpoint
      transforms:
      - type: string
        string:
          fmt: "%s-postgresql.%s.svc.cluster.local:5432"
      policy:
        fromFieldPath: Optional
    # Only deploy if database is postgres
    - type: FromCompositeFieldPath
      fromFieldPath: spec.database
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "postgres": "true"
          "none": "false"

  # Redis Cache (conditional on spec.cache=redis)
  - name: redis-cache
    base:
      apiVersion: helm.crossplane.io/v1beta1
      kind: Release
      spec:
        forProvider:
          chart:
            name: redis
            repository: https://charts.bitnami.com/bitnami
            version: "18.4.0"
          namespace: placeholder
          skipCreateNamespace: false
          values:
            auth:
              enabled: true
              password: "placeholder"
            master:
              persistence:
                enabled: true
                size: 5Gi
                storageClass: gp2
              resources:
                requests:
                  memory: 128Mi
                  cpu: 100m
                limits:
                  memory: 256Mi
                  cpu: 200m
            replica:
              replicaCount: 1
              persistence:
                enabled: true
                size: 5Gi
                storageClass: gp2
              resources:
                requests:
                  memory: 128Mi
                  cpu: 100m
                limits:
                  memory: 256Mi
                  cpu: 200m
            metrics:
              enabled: true
              serviceMonitor:
                enabled: false
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-redis"
    # Generate random password (in production, use External Secrets)
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.auth.password
      transforms:
      - type: string
        string:
          fmt: "%s-redis-pass"
    # Status patches for cache connection info
    - type: ToCompositeFieldPath
      fromFieldPath: status.atProvider.state
      toFieldPath: status.infrastructure.cache.ready
      transforms:
      - type: map
        map:
          "deployed": true
          "failed": false
      policy:
        fromFieldPath: Optional
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: status.infrastructure.cache.endpoint
      transforms:
      - type: string
        string:
          fmt: "%s-redis-master.%s.svc.cluster.local:6379"
      policy:
        fromFieldPath: Optional
    # Only deploy if cache is redis
    - type: FromCompositeFieldPath
      fromFieldPath: spec.cache
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "redis": "true"
          "none": "false"

  # Database Secret (PostgreSQL credentials)
  - name: postgres-secret
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Secret
            metadata:
              name: placeholder
              namespace: placeholder
              labels:
                app.kubernetes.io/managed-by: "crossplane"
                app.kubernetes.io/component: "secret-integration"
                app.kubernetes.io/part-of: "application-infrastructure"
                realtime.platform.example.org/discoverable: "true"
                webservice.example.org/integration-type: "database"
              annotations:
                webservice.example.org/secret-type: "cross-component-integration"
                webservice.example.org/service-type: "db"
            type: Opaque
            stringData:
              # Plain text values - Kubernetes will base64 encode automatically
              DATABASE_URL: ""
              DB_HOST: ""
              DB_PORT: "5432"
              DB_NAME: ""
              DB_USER: ""
              DB_PASSWORD: ""
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-db-secret"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-db-secret"
    # Only create if database is postgres
    - type: FromCompositeFieldPath
      fromFieldPath: spec.database
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "postgres": "true"
          "none": "false"
    # Patch secret values with plain text (Kubernetes will base64 encode)
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.DB_HOST
      transforms:
      - type: string
        string:
          fmt: "%s-postgresql.%s.svc.cluster.local"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.DB_NAME
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.DB_USER
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.DB_PASSWORD
      transforms:
      - type: string
        string:
          fmt: "%s-user-pass"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.DATABASE_URL
      transforms:
      - type: string
        string:
          fmt: "postgresql://%s:%s-user-pass@claims-postgresql.claims.svc.cluster.local:5432/%s"
          type: Format

  # Cache Secret (Redis credentials)
  - name: redis-secret
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Secret
            metadata:
              name: placeholder
              namespace: placeholder
              labels:
                app.kubernetes.io/managed-by: "crossplane"
                app.kubernetes.io/component: "secret-integration"
                app.kubernetes.io/part-of: "application-infrastructure"
                realtime.platform.example.org/discoverable: "true"
                webservice.example.org/integration-type: "cache"
              annotations:
                webservice.example.org/secret-type: "cross-component-integration"
                webservice.example.org/service-type: "redis"
            type: Opaque
            stringData:
              # Plain text values - Kubernetes will base64 encode automatically
              REDIS_URL: ""
              REDIS_HOST: ""
              REDIS_PORT: "6379"
              REDIS_PASSWORD: ""
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-redis-secret"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-redis-secret"
    # Only create if cache is redis
    - type: FromCompositeFieldPath
      fromFieldPath: spec.cache
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "redis": "true"
          "none": "false"
    # Patch Redis secret values
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.REDIS_HOST
      transforms:
      - type: string
        string:
          fmt: "%s-redis-master.%s.svc.cluster.local"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.REDIS_PASSWORD
      transforms:
      - type: string
        string:
          fmt: "%s-redis-pass"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.REDIS_URL
      transforms:
      - type: string
        string:
          fmt: "redis://:%s-redis-pass@claims-redis-master.claims.svc.cluster.local:6379/0"
          type: Format

  # Update OAM Application with new webservice component
  - name: update-oam-application
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: default
            spec:
              template:
                spec:
                  serviceAccountName: crossplane-github-provider
                  restartPolicy: OnFailure
                  containers:
                  - name: oam-updater
                    image: alpine:3.18
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      # Install git, curl, and jq
                      apk add --no-cache git curl jq
                      echo "Updating OAM Application with webservice component for $SERVICE_NAME..."
                      
                      TEMP_DIR="/tmp/oam-update-$APP_CONTAINER"
                      mkdir -p $TEMP_DIR
                      cd $TEMP_DIR
                      
                      # Clone the GitOps repository
                      git clone https://$GITHUB_TOKEN@github.com/$GITHUB_USER/$APP_CONTAINER-gitops.git .
                      
                      # Configure git
                      git config user.name "ApplicationClaim OAM Updater"
                      git config user.email "applicationclaim@platform.local"
                      
                      # Check if this is an API-driven ApplicationClaim (should update OAM)
                      # vs OAM-driven ApplicationClaim (should NOT update OAM to avoid circular dependency)
                      SOURCE="${BOOTSTRAP_SOURCE:-api-driven}"
                      
                      if [ "$SOURCE" != "api-driven" ]; then
                        echo "üîÑ OAM-driven ApplicationClaim detected (source: $SOURCE)"
                        echo "‚ö†Ô∏è  Skipping OAM update to avoid circular dependency"
                        echo "‚ÑπÔ∏è  User should manually update OAM Application if needed"
                        exit 0
                      fi
                      
                      echo "üîÑ API-driven ApplicationClaim detected - proceeding with OAM update"
                      
                      # Check if OAM application file exists
                      if [ ! -f "oam/applications/application.yaml" ]; then
                        echo "‚ùå OAM application file not found"
                        exit 1
                      fi
                      
                      echo "üìã Current OAM Application:"
                      cat oam/applications/application.yaml
                      
                      # Check if component already exists in OAM Application
                      if grep -q "name: $SERVICE_NAME" oam/applications/application.yaml; then
                        echo "‚ö†Ô∏è  Component '$SERVICE_NAME' already exists in OAM Application"
                        echo "üîÑ Skipping update to avoid duplication"
                        echo "‚ÑπÔ∏è  If you need to update the component, modify the OAM Application directly"
                        exit 0
                      fi
                      
                      echo "‚úÖ Component '$SERVICE_NAME' not found - proceeding with addition"
                      
                      # Create new component definition - choose correct ComponentDefinition based on framework
                      if [ "$FRAMEWORK" = "chatbot" ]; then
                        COMPONENT_TYPE="rasa-chatbot"
                        COMPONENT_PORT="5005"
                      else
                        COMPONENT_TYPE="webservice"
                        COMPONENT_PORT="8080"
                      fi
                      
                      COMPONENT_YAML="
                        - name: $SERVICE_NAME
                          type: $COMPONENT_TYPE
                          properties:
                            name: $SERVICE_NAME
                            image: $SERVICE_NAME:latest
                            language: $LANGUAGE
                            framework: $FRAMEWORK
                            port: $COMPONENT_PORT
                            healthPath: /health"
                      
                      # Add realtime platform integration if specified
                      if [ -n "$REALTIME_PLATFORM" ] && [ "$REALTIME_PLATFORM" != "none" ]; then
                        COMPONENT_YAML="${COMPONENT_YAML}
                            realtime: $REALTIME_PLATFORM
                            websocket: true"
                      fi
                      
                      # Add database if specified
                      if [ "$DATABASE" != "none" ] && [ -n "$DATABASE" ]; then
                        COMPONENT_YAML="${COMPONENT_YAML}
                            database: $DATABASE"
                      fi
                      
                      # Add cache if specified
                      if [ "$CACHE" != "none" ] && [ -n "$CACHE" ]; then
                        COMPONENT_YAML="${COMPONENT_YAML}
                            cache: $CACHE"
                      fi
                      
                      # Add AppContainer reference
                      COMPONENT_YAML="${COMPONENT_YAML}
                            appContainer: $APP_CONTAINER
                            exposeApi: true"
                      
                      # Check if components array is empty
                      if grep -q "components: \[\]" oam/applications/application.yaml; then
                        echo "üîÑ Adding first component to empty OAM Application..."
                        
                        # Replace empty components array with the new component
                        sed -i "s/components: \[\]/components:$COMPONENT_YAML/" oam/applications/application.yaml
                        
                      elif grep -q "components:" oam/applications/application.yaml; then
                        echo "üîÑ Adding component to existing OAM Application..."
                        
                        # Find the line number of components: and add the new component
                        COMPONENTS_LINE=$(grep -n "components:" oam/applications/application.yaml | cut -d: -f1)
                        
                        # Create temp file with the new component added
                        head -n $COMPONENTS_LINE oam/applications/application.yaml > temp_app.yaml
                        echo "$COMPONENT_YAML" | sed 's/^/        /' >> temp_app.yaml
                        tail -n +$((COMPONENTS_LINE + 1)) oam/applications/application.yaml >> temp_app.yaml
                        
                        mv temp_app.yaml oam/applications/application.yaml
                        
                      else
                        echo "‚ùå No components section found in OAM Application"
                        exit 1
                      fi
                      
                      echo "‚úÖ Updated OAM Application:"
                      cat oam/applications/application.yaml
                      
                      # Commit and push changes
                      git add oam/applications/application.yaml
                      git commit -m "Add $SERVICE_NAME webservice component to OAM Application - Language $LANGUAGE Framework $FRAMEWORK Database $DATABASE Cache $CACHE - Generated by ApplicationClaim composition"
                      
                      git push
                      
                      echo "üéâ Successfully updated OAM Application with $SERVICE_NAME webservice component"
                    env:
                    - name: SERVICE_NAME
                      value: "placeholder"
                    - name: APP_CONTAINER
                      value: "placeholder"
                    - name: LANGUAGE
                      value: "placeholder"
                    - name: FRAMEWORK
                      value: "placeholder"
                    - name: DATABASE
                      value: "placeholder"
                    - name: CACHE
                      value: "placeholder"
                    - name: BOOTSTRAP_SOURCE
                      value: "placeholder"
                    - name: GITHUB_TOKEN
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: token
                    - name: GITHUB_USER
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: user
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-oam-updater"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-oam-updater"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.language
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.framework
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[3].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.database
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[4].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.cache
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[5].value
    - type: FromCompositeFieldPath
      fromFieldPath: metadata.annotations["webservice.oam.dev/source"]
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[6].value
      policy:
        fromFieldPath: Optional
      transforms:
      - type: string
        string:
          fmt: "%s"

  # Create Chat Service Repository (conditional on language=rasa and framework=chatbot)
  - name: create-chat-service-repository
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: default
            spec:
              template:
                spec:
                  serviceAccountName: crossplane-github-provider
                  restartPolicy: OnFailure
                  containers:
                  - name: chat-repo-creator
                    image: alpine:3.18
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      
                      # Check if this is a RASA chatbot service
                      if [ "$LANGUAGE" != "rasa" ] || [ "$FRAMEWORK" != "chatbot" ]; then
                        echo "‚ùå Skipping chat repository creation - not a RASA chatbot service"
                        echo "   Language: $LANGUAGE (expected: rasa)"  
                        echo "   Framework: $FRAMEWORK (expected: chatbot)"
                        echo "‚úÖ Chat repository creation skipped successfully"
                        exit 0
                      fi
                      
                      # Install git, curl, and jq
                      apk add --no-cache git curl jq
                      echo "Adding Rasa chatbot microservice $SERVICE_NAME to unified repository $APP_CONTAINER..."
                      
                      # Clone unified AppContainer repository
                      TEMP_DIR="/tmp/unified-repo-$SERVICE_NAME"
                      mkdir -p $TEMP_DIR
                      cd $TEMP_DIR
                      
                      # First check if AppContainer repository exists
                      REPO_EXISTS=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
                        https://api.github.com/repos/$GITHUB_USER/$APP_CONTAINER | jq -r '.name // "null"')
                      
                      if [ "$REPO_EXISTS" = "null" ]; then
                        echo "‚ùå AppContainer repository $APP_CONTAINER does not exist yet"
                        echo "‚è≥ Waiting for AppContainer to be created by other jobs..."
                        exit 1
                      fi
                      
                      echo "‚úÖ AppContainer repository exists, cloning..."
                      git clone https://$GITHUB_TOKEN@github.com/$GITHUB_USER/$APP_CONTAINER.git .
                      
                      # Check if microservice already exists
                      if [ -d "microservices/$SERVICE_NAME" ]; then
                        echo "‚ö†Ô∏è  Microservice $SERVICE_NAME already exists in $APP_CONTAINER"
                        echo "üîÑ Updating existing microservice..."
                      else
                        echo "‚ûï Adding new microservice $SERVICE_NAME to $APP_CONTAINER"
                        
                        # Clone chat-template to get the template
                        TEMPLATE_DIR="/tmp/chat-template"
                        git clone https://$GITHUB_TOKEN@github.com/$GITHUB_USER/chat-template.git $TEMPLATE_DIR
                        
                        # Copy template microservice structure
                        mkdir -p microservices/$SERVICE_NAME
                        cp -r $TEMPLATE_DIR/microservices/chat-template/* microservices/$SERVICE_NAME/
                        
                        # Add chat-specific GitHub Actions workflow if not exists
                        if [ ! -f ".github/workflows/chat-gitops.yml" ]; then
                          cp $TEMPLATE_DIR/.github/workflows/chat-gitops.yml .github/workflows/
                        fi
                        
                        rm -rf $TEMPLATE_DIR
                      fi
                      
                      # Customize for the specific service
                      sed -i "s/chat-template/$SERVICE_NAME/g" microservices/$SERVICE_NAME/docker-compose.yml
                      sed -i "s/Development Bot/$SERVICE_NAME Bot/g" microservices/$SERVICE_NAME/docker-compose.yml
                      sed -i "s/Customer Support Bot/$SERVICE_NAME Support Bot/g" microservices/$SERVICE_NAME/domain.yml
                      
                      # Update OAM files with correct service name
                      find microservices/$SERVICE_NAME/oam/ -name "*.yaml" -exec sed -i "s/chat-template/$SERVICE_NAME/g" {} \;
                      
                      # Set git configuration
                      git config user.name "Crossplane Bot"
                      git config user.email "crossplane@health-service-idp.local"
                      
                      # Add and commit changes to unified repository
                      git add microservices/$SERVICE_NAME/
                      if [ -f ".github/workflows/chat-gitops.yml" ]; then
                        git add .github/workflows/chat-gitops.yml
                      fi
                      
                      # Check if there are changes to commit
                      if git diff --staged --quiet; then
                        echo "‚ö†Ô∏è  No changes to commit for $SERVICE_NAME"
                      else
                        git commit -m "feat: add RASA chatbot microservice $SERVICE_NAME" -m "- Add complete RASA chatbot implementation with dual-container pattern" -m "- Include Rasa server and Actions server configurations" -m "- Add chat-specific GitHub Actions workflow for Docker builds" -m "- Support for natural language understanding and custom actions" -m "- Ready for OAM deployment with knative services" -m "ü§ñ Generated with [Claude Code](https://claude.ai/code)" -m "Co-Authored-By: Claude <noreply@anthropic.com>"
                        
                        git push origin main
                        echo "‚úÖ RASA chatbot microservice $SERVICE_NAME added to unified repository $APP_CONTAINER"
                      fi
                    env:
                    - name: SERVICE_NAME
                      value: placeholder
                    - name: LANGUAGE
                      value: placeholder
                    - name: FRAMEWORK
                      value: placeholder
                    - name: APP_CONTAINER
                      value: placeholder
                    - name: GITHUB_TOKEN
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: token
                    - name: GITHUB_USER
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: user
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-chat-repo-creator"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-chat-repo-creator"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.language
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.framework
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[3].value
    # Only deploy if language is rasa and framework is chatbot
    - type: FromCompositeFieldPath
      fromFieldPath: spec.language
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "rasa": "true"
          "python": "false"
          "java": "false"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.framework
      toFieldPath: metadata.labels["crossplane.io/chatbot-enable"]
      transforms:
      - type: map
        map:
          "chatbot": "true"
          "fastapi": "false"
          "springboot": "false"

  # Repository status synchronizer - gets repository URL from AppContainerClaim
  - name: repository-status-sync
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: default
            spec:
              template:
                spec:
                  serviceAccountName: crossplane-github-provider
                  restartPolicy: OnFailure
                  containers:
                  - name: repository-sync
                    image: bitnami/kubectl:1.28
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      echo "üîÑ Synchronizing repository status from AppContainerClaim..."
                      
                      # Wait for AppContainerClaim to be ready and get repository URL
                      APP_CONTAINER="$APP_CONTAINER_NAME"
                      SERVICE_NAME="$SERVICE_NAME"
                      NAMESPACE="$NAMESPACE"
                      
                      echo "Waiting for AppContainerClaim $APP_CONTAINER to be ready..."
                      
                      TIMEOUT=300
                      ELAPSED=0
                      
                      while [ $ELAPSED -lt $TIMEOUT ]; do
                        # Check if AppContainerClaim exists and get repository URL
                        REPO_URL=$(kubectl get appcontainerclaim "$APP_CONTAINER" -n "$NAMESPACE" -o jsonpath='{.status.sourceRepository.url}' 2>/dev/null || echo "")
                        CLONE_URL=$(kubectl get appcontainerclaim "$APP_CONTAINER" -n "$NAMESPACE" -o jsonpath='{.status.sourceRepository.cloneUrl}' 2>/dev/null || echo "")
                        
                        if [ -n "$REPO_URL" ]; then
                          echo "‚úÖ Found repository URL: $REPO_URL"
                          echo "‚úÖ Found clone URL: $CLONE_URL"
                          
                          # Find associated Knative service
                          KNATIVE_SERVICE=""
                          if kubectl get ksvc "$SERVICE_NAME" -n "$NAMESPACE" >/dev/null 2>&1; then
                            KNATIVE_SERVICE="$SERVICE_NAME"
                          elif kubectl get ksvc "${SERVICE_NAME}-realtime-service" -n "$NAMESPACE" >/dev/null 2>&1; then
                            KNATIVE_SERVICE="${SERVICE_NAME}-realtime-service"
                          elif kubectl get ksvc "${SERVICE_NAME}-service" -n "$NAMESPACE" >/dev/null 2>&1; then
                            KNATIVE_SERVICE="${SERVICE_NAME}-service"
                          fi
                          
                          echo "Found Knative Service: $KNATIVE_SERVICE"
                          
                          # Update ApplicationClaim status
                          kubectl patch applicationclaim "$SERVICE_NAME" -n "$NAMESPACE" --type=merge --subresource=status -p "{
                            \"status\": {
                              \"repository\": {
                                \"url\": \"$REPO_URL\",
                                \"cloneUrl\": \"$CLONE_URL\"
                              },
                              \"application\": {
                                \"knativeService\": \"$KNATIVE_SERVICE\"
                              }
                            }
                          }"
                          
                          echo "‚úÖ ApplicationClaim status synchronized from AppContainerClaim"
                          exit 0
                        fi
                        
                        echo "Waiting for AppContainerClaim repository status... (${ELAPSED}s/${TIMEOUT}s)"
                        sleep 10
                        ELAPSED=$((ELAPSED + 10))
                      done
                      
                      echo "‚ùå Timeout waiting for AppContainerClaim repository status"
                      exit 1
                    env:
                    - name: SERVICE_NAME
                      value: placeholder
                    - name: APP_CONTAINER_NAME
                      value: placeholder
                    - name: NAMESPACE
                      value: placeholder
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-repo-sync"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-repo-sync"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
    - type: FromCompositeFieldPath  
      fromFieldPath: spec.namespace
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].value
    - type: FromCompositeFieldPath
      fromFieldPath: metadata.namespace  
      toFieldPath: spec.forProvider.manifest.metadata.namespace

