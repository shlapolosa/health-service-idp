apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: application-claim-composition
  labels:
    crossplane.io/xrd: xapplicationclaims.platform.example.org
    provider: github-kubernetes-helm
spec:
  writeConnectionSecretsToNamespace: crossplane-system
  compositeTypeRef:
    apiVersion: platform.example.org/v1alpha1
    kind: XApplicationClaim
  resources:
  
  # Add microservice to existing AppContainer source repository
  - name: add-microservice-to-container
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: default
            spec:
              template:
                spec:
                  serviceAccountName: crossplane-github-provider
                  restartPolicy: OnFailure
                  containers:
                  - name: microservice-creator
                    image: alpine/git:latest
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      echo "Adding microservice $SERVICE_NAME to AppContainer $APP_CONTAINER..."
                      
                      TEMP_DIR="/tmp/app-container-$APP_CONTAINER"
                      mkdir -p $TEMP_DIR
                      cd $TEMP_DIR
                      
                      # Clone the AppContainer repository using GitHub token
                      git clone https://$GITHUB_TOKEN@github.com/$GITHUB_USER/$APP_CONTAINER.git .
                      
                      # Create microservice directory
                      mkdir -p microservices/$SERVICE_NAME
                      cd microservices/$SERVICE_NAME
                      
                      # Create CLAUDE.md-compliant Onion Architecture structure
                      mkdir -p src/domain
                      mkdir -p src/application  
                      mkdir -p src/infrastructure
                      mkdir -p src/interface
                      mkdir -p tests/unit
                      mkdir -p tests/integration
                      mkdir -p manifest
                      
                      if [ "$LANGUAGE" = "python" ] && [ "$FRAMEWORK" = "fastapi" ]; then
                        # Python FastAPI microservice with CLAUDE.md structure
                        cat > pyproject.toml << EOF
                      [tool.poetry]
                      name = "$SERVICE_NAME"
                      version = "0.1.0"
                      description = "CLAUDE.md-compliant FastAPI microservice"
                      authors = ["Generated by ApplicationClaim"]
                      
                      [tool.poetry.dependencies]
                      python = "^3.11"
                      fastapi = "^0.104.0"
                      uvicorn = "^0.24.0"
                      pydantic = "^2.0.0"
                      sqlalchemy = "^2.0.0"
                      
                      [tool.poetry.group.dev.dependencies]
                      pytest = "^7.4.0"
                      pytest-asyncio = "^0.21.0"
                      black = "^23.0.0"
                      isort = "^5.12.0"
                      mypy = "^1.5.0"
                      
                      [build-system]
                      requires = ["poetry-core"]
                      build-backend = "poetry.core.masonry.api"
                      EOF
                      
                        # Domain layer
                        cat > src/domain/models.py << EOF
                      """Domain models following CLAUDE.md Onion Architecture"""
                      from abc import ABC, abstractmethod
                      from typing import Optional
                      from pydantic import BaseModel
                      
                      class Entity(BaseModel):
                          """Base domain entity"""
                          id: Optional[str] = None
                      
                      class DomainService(ABC):
                          """Base domain service interface"""
                          pass
                      EOF
                      
                        # Application layer
                        cat > src/application/use_cases.py << EOF
                      """Application use cases following CLAUDE.md principles"""
                      from abc import ABC, abstractmethod
                      from typing import Generic, TypeVar
                      
                      T = TypeVar('T')
                      
                      class UseCase(ABC, Generic[T]):
                          """Base use case following CLAUDE.md patterns"""
                          
                          @abstractmethod
                          async def execute(self, request: T) -> dict:
                              pass
                      EOF
                      
                        # Infrastructure layer
                        cat > src/infrastructure/repositories.py << EOF
                      """Infrastructure repositories with dependency injection"""
                      from abc import ABC, abstractmethod
                      from typing import List, Optional
                      
                      class Repository(ABC):
                          """Base repository interface for dependency injection"""
                          pass
                      EOF
                      
                        # Interface layer (FastAPI)
                        cat > src/interface/api.py << EOF
                      """FastAPI interface layer following CLAUDE.md 12-factor principles"""
                      import os
                      from fastapi import FastAPI, Depends
                      from pydantic import BaseModel
                      
                      # 12-Factor: Config from environment
                      DATABASE_URL = os.getenv("DATABASE_URL", "")
                      REDIS_URL = os.getenv("REDIS_URL", "")
                      
                      app = FastAPI(
                          title="$SERVICE_NAME",
                          description="CLAUDE.md-compliant microservice with Onion Architecture",
                          version="0.1.0"
                      )
                      
                      class HealthResponse(BaseModel):
                          status: str
                          service: str
                      
                      @app.get("/health", response_model=HealthResponse)
                      async def health_check():
                          """Health check endpoint for Kubernetes probes"""
                          return HealthResponse(status="healthy", service="$SERVICE_NAME")
                      
                      @app.get("/ready", response_model=HealthResponse)
                      async def readiness_check():
                          """Readiness check endpoint for Kubernetes probes"""
                          return HealthResponse(status="ready", service="$SERVICE_NAME")
                      
                      @app.get("/")
                      async def root():
                          """Root endpoint"""
                          return {"message": "Hello from $SERVICE_NAME", "architecture": "onion"}
                      EOF
                      
                        # Main application entry point
                        cat > src/main.py << EOF
                      """Main application entry point following 12-factor principles"""
                      import os
                      import uvicorn
                      from interface.api import app
                      
                      if __name__ == "__main__":
                          # 12-Factor: Port binding
                          port = int(os.getenv("PORT", 8080))
                          uvicorn.run(app, host="0.0.0.0", port=port)
                      EOF
                      
                        # Multi-stage Dockerfile optimized for microservices build context
                        cat > Dockerfile << EOF
                      # Multi-stage build for production
                      FROM python:3.11-slim as builder
                      
                      # Install Poetry and basic build tools
                      RUN apt-get update && apt-get install -y curl gcc && rm -rf /var/lib/apt/lists/*
                      RUN pip install poetry
                      
                      # Set working directory for build
                      WORKDIR /build
                      
                      # Copy dependency files
                      COPY pyproject.toml ./
                      
                      # Configure poetry and install dependencies without dev packages (no-root to skip project install)
                      RUN poetry config virtualenvs.create false \
                          && poetry install --only=main --no-root --no-interaction --no-ansi
                      
                      # Production stage
                      FROM python:3.11-slim as production
                      
                      # Install curl for health checks
                      RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*
                      
                      # Create non-root user (security best practice)
                      RUN useradd --create-home --shell /bin/bash app
                      
                      # Copy installed packages from builder
                      COPY --from=builder /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages
                      COPY --from=builder /usr/local/bin /usr/local/bin
                      
                      # Set working directory
                      WORKDIR /app
                      
                      # Copy application code
                      COPY --chown=app:app src/ src/
                      
                      # Switch to non-root user
                      USER app
                      
                      # 12-Factor: Port binding
                      EXPOSE 8080
                      
                      # Health check with better error handling
                      HEALTHCHECK --interval=30s --timeout=10s --start-period=15s --retries=3 \
                        CMD curl -f http://localhost:8080/health || exit 1
                      
                      # Start application
                      CMD ["python", "-m", "src.main"]
                      EOF
                      
                        # TDD Tests
                        cat > tests/test_main.py << EOF
                      """TDD tests following CLAUDE.md principles"""
                      import pytest
                      from fastapi.testclient import TestClient
                      from src.interface.api import app
                      
                      client = TestClient(app)
                      
                      def test_health_check():
                          """Test health endpoint (TDD Red-Green-Refactor)"""
                          response = client.get("/health")
                          assert response.status_code == 200
                          data = response.json()
                          assert data["status"] == "healthy"
                          assert data["service"] == "$SERVICE_NAME"
                      
                      def test_readiness_check():
                          """Test readiness endpoint"""
                          response = client.get("/ready")
                          assert response.status_code == 200
                          data = response.json()
                          assert data["status"] == "ready"
                      
                      def test_root_endpoint():
                          """Test root endpoint"""
                          response = client.get("/")
                          assert response.status_code == 200
                          data = response.json()
                          assert "Hello from" in data["message"]
                          assert data["architecture"] == "onion"
                      EOF
                      fi
                      
                      # Create service README
                      cat > README.md << EOF
                      # $SERVICE_NAME
                      
                      CLAUDE.md-compliant microservice with Onion Architecture and 12-Factor principles.
                      
                      ## Architecture
                      
                      This microservice follows the Onion Architecture pattern:
                      
                      - **Domain Layer**: Business rules (`src/domain/`)
                      - **Application Layer**: Use cases (`src/application/`)
                      - **Interface Layer**: REST/API endpoints (`src/interface/`)
                      - **Infrastructure Layer**: Database, external services (`src/infrastructure/`)
                      
                      ## Development
                      
                      ### Prerequisites
                      - Python 3.11+
                      - Poetry
                      
                      ### Setup
                      ```bash
                      poetry install
                      poetry run pytest  # Run TDD tests
                      poetry run python src/main.py  # Run locally
                      ```
                      
                      ### Testing (TDD)
                      ```bash
                      poetry run pytest -v
                      ```
                      
                      ### Linting
                      ```bash
                      poetry run black src/
                      poetry run isort src/
                      poetry run mypy src/
                      ```
                      
                      ## Deployment
                      
                      This service is automatically deployed via the AppContainer CI/CD pipeline when changes are pushed to the main branch.
                      EOF
                      
                      # Update microservices README
                      cd ../../
                      if grep -q "- (Services will be listed here as they are added)" microservices/README.md; then
                        sed -i "s/- (Services will be listed here as they are added)/- $SERVICE_NAME ($LANGUAGE\/$FRAMEWORK)/" microservices/README.md
                      else
                        echo "- $SERVICE_NAME ($LANGUAGE/$FRAMEWORK)" >> microservices/README.md
                      fi
                      
                      # Commit and push
                      git config user.name "ApplicationClaim"
                      git config user.email "applicationclaim@platform.local"
                      git add .
                      git commit -m "Add $SERVICE_NAME microservice ($LANGUAGE/$FRAMEWORK)
                      
                      - Implements CLAUDE.md Onion Architecture
                      - Follows 12-Factor App principles
                      - Includes TDD test structure with pytest
                      - Dependency injection ready
                      - FastAPI with health checks
                      - Multi-stage Dockerfile
                      - Poetry for dependency management"
                      git push
                      
                      echo "Microservice $SERVICE_NAME added to AppContainer $APP_CONTAINER successfully"
                    env:
                    - name: APP_CONTAINER
                      value: placeholder
                    - name: SERVICE_NAME
                      value: placeholder
                    - name: LANGUAGE
                      value: placeholder
                    - name: FRAMEWORK
                      value: placeholder
                    - name: GITHUB_TOKEN
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: token
                    - name: GITHUB_USER
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: user
                    - name: DOCKER_REGISTRY
                      valueFrom:
                        secretKeyRef:
                          name: docker-credentials
                          key: registry
                    - name: DOCKER_USER
                      valueFrom:
                        secretKeyRef:
                          name: docker-credentials
                          key: username
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-microservice-creator"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.language
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.framework
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[3].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-microservice-creator"

  # Add GitOps manifests for the new microservice
  - name: add-gitops-manifests
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: default
            spec:
              template:
                spec:
                  serviceAccountName: crossplane-github-provider
                  restartPolicy: OnFailure
                  containers:
                  - name: gitops-manifest-creator
                    image: alpine/git:latest
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      echo "Adding GitOps manifests for $SERVICE_NAME in $APP_CONTAINER-gitops..."
                      
                      TEMP_DIR="/tmp/gitops-$APP_CONTAINER"
                      mkdir -p $TEMP_DIR
                      cd $TEMP_DIR
                      
                      # Clone the GitOps repository using GitHub token
                      git clone https://$GITHUB_TOKEN@github.com/$GITHUB_USER/$APP_CONTAINER-gitops.git .
                      
                      # Create manifests directory for the service
                      mkdir -p manifests/$SERVICE_NAME
                      cd manifests/$SERVICE_NAME
                      
                      # Create Knative Service manifest with cost optimization
                      cat > knative-service.yaml << EOF
                      apiVersion: serving.knative.dev/v1
                      kind: Service
                      metadata:
                        name: $SERVICE_NAME
                        namespace: $APP_CONTAINER
                        annotations:
                          # Cost optimization: Scale to zero when not in use
                          autoscaling.knative.dev/min-scale: "0"
                          autoscaling.knative.dev/max-scale: "5"
                          autoscaling.knative.dev/target: "50"
                          autoscaling.knative.dev/metric: "concurrency"
                          # Karpenter optimization
                          karpenter.sh/do-not-evict: "false"
                          cluster-autoscaler.kubernetes.io/safe-to-evict: "true"
                          # Internal only for cost savings
                          serving.knative.dev/visibility: "cluster-local"
                      spec:
                        template:
                          metadata:
                            annotations:
                              autoscaling.knative.dev/min-scale: "0"
                              autoscaling.knative.dev/max-scale: "5"
                              autoscaling.knative.dev/target: "50"
                              autoscaling.knative.dev/scale-to-zero-pod-retention-period: "30s"
                              # Queue proxy resource optimization
                              queue.sidecar.serving.knative.dev/cpu-resource-request: "25m"
                              queue.sidecar.serving.knative.dev/memory-resource-request: "50Mi"
                              queue.sidecar.serving.knative.dev/cpu-resource-limit: "100m"
                              queue.sidecar.serving.knative.dev/memory-resource-limit: "100Mi"
                          spec:
                            # Lower concurrency for better resource utilization
                            containerConcurrency: 50
                            # Shorter timeout for cost optimization
                            timeoutSeconds: 300
                            containers:
                            - image: $DOCKER_REGISTRY/$DOCKER_USER/$SERVICE_NAME:latest
                              ports:
                              - containerPort: 8080
                                name: http1
                              env:
                              - name: APP_NAME
                                value: $SERVICE_NAME
                              - name: LOG_LEVEL
                                value: "INFO"
                              - name: PORT
                                value: "8080"
                              envFrom:
                              - configMapRef:
                                  name: $SERVICE_NAME-config
                                  optional: true
                              - secretRef:
                                  name: $SERVICE_NAME-postgres-secret
                                  optional: true
                              - secretRef:
                                  name: $SERVICE_NAME-redis-secret
                                  optional: true
                              # Health checks optimized for cold starts
                              livenessProbe:
                                httpGet:
                                  path: /health
                                  port: 8080
                                initialDelaySeconds: 15
                                periodSeconds: 15
                                timeoutSeconds: 5
                                failureThreshold: 3
                              readinessProbe:
                                httpGet:
                                  path: /health
                                  port: 8080
                                initialDelaySeconds: 5
                                periodSeconds: 10
                                timeoutSeconds: 3
                                successThreshold: 1
                                failureThreshold: 3
                              # Minimal resource requests for cost optimization
                              resources:
                                requests:
                                  cpu: 100m
                                  memory: 128Mi
                                limits:
                                  cpu: 500m
                                  memory: 256Mi
                              # Security context
                              securityContext:
                                allowPrivilegeEscalation: false
                                runAsNonRoot: true
                                runAsUser: 1001
                                capabilities:
                                  drop:
                                  - ALL
                                seccompProfile:
                                  type: RuntimeDefault
                      EOF
                      
                      # Create ConfigMap for environment variables
                      cat > configmap.yaml << EOF
                      apiVersion: v1
                      kind: ConfigMap
                      metadata:
                        name: $SERVICE_NAME-config
                        namespace: $APP_CONTAINER
                      data:
                        APP_ENV: "production"
                        SERVICE_NAME: "$SERVICE_NAME"
                      EOF
                      
                      # Add database config if needed
                      if [ "$DATABASE" = "postgres" ]; then
                        cat >> configmap.yaml << EOF
                        DATABASE_URL: "postgresql://\$DATABASE_USER:\$DATABASE_PASSWORD@$APP_CONTAINER-postgres-rw.$APP_CONTAINER.svc.cluster.local:5432/$SERVICE_NAME"
                      EOF
                      fi
                      
                      # Add cache config if needed  
                      if [ "$CACHE" = "redis" ]; then
                        cat >> configmap.yaml << EOF
                        REDIS_URL: "redis://:\$REDIS_PASSWORD@$APP_CONTAINER-redis-master.$APP_CONTAINER.svc.cluster.local:6379/0"
                      EOF
                      fi
                      
                      # Create OAM Component in correct directory
                      cd ../../oam/components
                      cat > $SERVICE_NAME.yaml << EOF
                      apiVersion: core.oam.dev/v1beta1
                      kind: Component
                      metadata:
                        name: $SERVICE_NAME
                        namespace: $APP_CONTAINER
                        labels:
                          app.oam.dev/component: $SERVICE_NAME
                          app.oam.dev/name: $APP_CONTAINER
                      spec:
                        workload:
                          apiVersion: serving.knative.dev/v1
                          kind: Service
                          metadata:
                            name: $SERVICE_NAME
                          spec:
                            template:
                              spec:
                                containers:
                                - name: $SERVICE_NAME
                                  image: $DOCKER_REGISTRY/$DOCKER_USER/$SERVICE_NAME:latest
                                  ports:
                                  - containerPort: 8080
                                  env:
                                  - name: APP_NAME
                                    value: $SERVICE_NAME
                        parameters:
                        - name: image
                          fieldPaths:
                          - "spec.template.spec.containers[0].image"
                        - name: replicas
                          fieldPaths:
                          - "metadata.annotations[autoscaling.knative.dev/minScale]"
                      EOF
                      
                      # Commit and push GitOps changes
                      cd ..
                      git config user.name "ApplicationClaim GitOps"
                      git config user.email "applicationclaim-gitops@platform.local"
                      git add .
                      git commit -m "Add GitOps manifests for $SERVICE_NAME microservice
                      
                      - Add Knative Service for $SERVICE_NAME
                      - Add ConfigMap for environment variables  
                      - Add OAM Component definition
                      - Configure autoscaling and health checks
                      - Ready for ArgoCD ApplicationSet deployment"
                      git push
                      
                      echo "GitOps manifests for $SERVICE_NAME added successfully"
                    env:
                    - name: APP_CONTAINER
                      value: placeholder
                    - name: SERVICE_NAME
                      value: placeholder
                    - name: DATABASE
                      value: placeholder
                    - name: CACHE
                      value: placeholder
                    - name: GITHUB_TOKEN
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: token
                    - name: GITHUB_USER
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: user
                    - name: DOCKER_REGISTRY
                      valueFrom:
                        secretKeyRef:
                          name: docker-credentials
                          key: registry
                    - name: DOCKER_USER
                      valueFrom:
                        secretKeyRef:
                          name: docker-credentials
                          key: username
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-gitops-creator"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.database
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.cache
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[3].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-gitops-creator"

  # PostgreSQL Database (conditional on spec.database=postgres)
  - name: postgres-database
    base:
      apiVersion: helm.crossplane.io/v1beta1
      kind: Release
      spec:
        forProvider:
          chart:
            name: postgresql
            repository: https://charts.bitnami.com/bitnami
            version: "13.2.24"
          namespace: placeholder
          skipCreateNamespace: false
          values:
            auth:
              enablePostgresUser: true
              postgresPassword: "placeholder"
              username: "placeholder"
              password: "placeholder"
              database: "placeholder"
            primary:
              persistence:
                enabled: true
                size: 10Gi
                storageClass: gp2
              resources:
                requests:
                  memory: 256Mi
                  cpu: 250m
                limits:
                  memory: 512Mi
                  cpu: 500m
              readinessProbe:
                enabled: true
                initialDelaySeconds: 30
                periodSeconds: 10
              livenessProbe:
                enabled: true
                initialDelaySeconds: 30
                periodSeconds: 10
            metrics:
              enabled: true
              serviceMonitor:
                enabled: false
            backup:
              enabled: false
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-postgres"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.auth.database
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.auth.username
    # Generate random passwords (in production, use External Secrets)
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.auth.postgresPassword
      transforms:
      - type: string
        string:
          fmt: "%s-postgres-admin-pass"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.auth.password
      transforms:
      - type: string
        string:
          fmt: "%s-user-pass"
    # Status patches for database connection info
    - type: ToCompositeFieldPath
      fromFieldPath: status.atProvider.state
      toFieldPath: status.infrastructure.database.ready
      transforms:
      - type: map
        map:
          "deployed": true
          "failed": false
      policy:
        fromFieldPath: Optional
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: status.infrastructure.database.endpoint
      transforms:
      - type: string
        string:
          fmt: "%s-postgresql.%s.svc.cluster.local:5432"
      policy:
        fromFieldPath: Optional
    # Only deploy if database is postgres
    - type: FromCompositeFieldPath
      fromFieldPath: spec.database
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "postgres": "true"
          "none": "false"

  # Redis Cache (conditional on spec.cache=redis)
  - name: redis-cache
    base:
      apiVersion: helm.crossplane.io/v1beta1
      kind: Release
      spec:
        forProvider:
          chart:
            name: redis
            repository: https://charts.bitnami.com/bitnami
            version: "18.4.0"
          namespace: placeholder
          skipCreateNamespace: false
          values:
            auth:
              enabled: true
              password: "placeholder"
            master:
              persistence:
                enabled: true
                size: 5Gi
                storageClass: gp2
              resources:
                requests:
                  memory: 128Mi
                  cpu: 100m
                limits:
                  memory: 256Mi
                  cpu: 200m
            replica:
              replicaCount: 1
              persistence:
                enabled: true
                size: 5Gi
                storageClass: gp2
              resources:
                requests:
                  memory: 128Mi
                  cpu: 100m
                limits:
                  memory: 256Mi
                  cpu: 200m
            metrics:
              enabled: true
              serviceMonitor:
                enabled: false
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-redis"
    # Generate random password (in production, use External Secrets)
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.auth.password
      transforms:
      - type: string
        string:
          fmt: "%s-redis-pass"
    # Status patches for cache connection info
    - type: ToCompositeFieldPath
      fromFieldPath: status.atProvider.state
      toFieldPath: status.infrastructure.cache.ready
      transforms:
      - type: map
        map:
          "deployed": true
          "failed": false
      policy:
        fromFieldPath: Optional
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: status.infrastructure.cache.endpoint
      transforms:
      - type: string
        string:
          fmt: "%s-redis-master.%s.svc.cluster.local:6379"
      policy:
        fromFieldPath: Optional
    # Only deploy if cache is redis
    - type: FromCompositeFieldPath
      fromFieldPath: spec.cache
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "redis": "true"
          "none": "false"

  # Database Secret (PostgreSQL credentials)
  - name: postgres-secret
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Secret
            metadata:
              name: placeholder
              namespace: placeholder
            type: Opaque
            stringData:
              # Plain text values - Kubernetes will base64 encode automatically
              DATABASE_URL: ""
              DB_HOST: ""
              DB_PORT: "5432"
              DB_NAME: ""
              DB_USER: ""
              DB_PASSWORD: ""
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-postgres-secret"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-postgres-secret"
    # Only create if database is postgres
    - type: FromCompositeFieldPath
      fromFieldPath: spec.database
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "postgres": "true"
          "none": "false"
    # Patch secret values with plain text (Kubernetes will base64 encode)
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.stringData.DB_HOST
      transforms:
      - type: string
        string:
          fmt: "%s-postgresql.%s.svc.cluster.local"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.DB_NAME
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.DB_USER
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.DB_PASSWORD
      transforms:
      - type: string
        string:
          fmt: "%s-user-pass"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.DATABASE_URL
      transforms:
      - type: string
        string:
          fmt: "postgresql://%s:%s-user-pass@claims-postgresql.claims.svc.cluster.local:5432/%s"
          type: Format

  # Cache Secret (Redis credentials)
  - name: redis-secret
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Secret
            metadata:
              name: placeholder
              namespace: placeholder
            type: Opaque
            stringData:
              # Plain text values - Kubernetes will base64 encode automatically
              REDIS_URL: ""
              REDIS_HOST: ""
              REDIS_PORT: "6379"
              REDIS_PASSWORD: ""
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-redis-secret"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-redis-secret"
    # Only create if cache is redis
    - type: FromCompositeFieldPath
      fromFieldPath: spec.cache
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "redis": "true"
          "none": "false"
    # Patch Redis secret values
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.stringData.REDIS_HOST
      transforms:
      - type: string
        string:
          fmt: "%s-redis-master.%s.svc.cluster.local"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.REDIS_PASSWORD
      transforms:
      - type: string
        string:
          fmt: "%s-redis-pass"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.REDIS_URL
      transforms:
      - type: string
        string:
          fmt: "redis://:%s-redis-pass@claims-redis-master.claims.svc.cluster.local:6379/0"
          type: Format

  # Configuration Generator for Realtime Platform
  - name: realtime-config-generator
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: placeholder
            spec:
              template:
                spec:
                  restartPolicy: OnFailure
                  containers:
                  - name: config-generator
                    image: busybox:latest
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      echo "Generating Lenses configuration files..."
                      
                      # Create Lenses HQ config.yaml
                      cat > /tmp/hq-config.yaml << EOF
                      lenses:
                        http:
                          port: 9991
                          bind: 0.0.0.0
                        authentication:
                          default:
                            enabled: true
                            username: admin
                            password: admin
                        license:
                          key: "${LENSES_LICENSE_KEY}"
                        database:
                          url: "jdbc:postgresql://${POSTGRES_HOST}:5432/${POSTGRES_DB}"
                          username: "${POSTGRES_USER}"
                          password: "${POSTGRES_PASSWORD}"
                        kafka:
                          brokers:
                            - "${KAFKA_HOST}:9092"
                          schema-registry:
                            url: "http://${KAFKA_HOST}:8081"
                      EOF
                      
                      # Create Lenses Agent lenses.conf
                      cat > /tmp/agent-config.conf << EOF
                      lenses.hq.url=${LENSES_HQ_URL}
                      lenses.hq.user=admin
                      lenses.hq.password=admin
                      lenses.heap.opts=-Xmx1536m -Xms512m
                      EOF
                      
                      # Create provisioning.yaml for MQTT/Kafka connectors
                      cat > /tmp/provisioning.yaml << EOF
                      connectors:
                        - name: "mqtt-source-connector"
                          config:
                            connector.class: "io.lenses.streamreactor.connect.mqtt.source.MqttSourceConnector"
                            tasks.max: "1"
                            connect.mqtt.hosts: "tcp://${MQTT_HOST}:1883"
                            connect.mqtt.username: "${MQTT_USER}"
                            connect.mqtt.password: "${MQTT_PASSWORD}"
                            connect.mqtt.kcql: "INSERT INTO device_data SELECT * FROM health/device_data WITHKEY(deviceId)"
                            connect.mqtt.service.quality: "1"
                      EOF
                      
                      # Create stream processing queries for data decomposition
                      cat > /tmp/stream-queries.sql << EOF
                      -- Blood Pressure Data Decomposition
                      INSERT INTO blood_pressure_device_topic
                      STORE KEY AS STRING VALUE AS AVRO
                      SELECT STREAM
                          _value.deviceId AS _key,
                          _value.deviceId AS deviceId,
                          _value.systolic AS systolic,
                          _value.diastolic AS diastolic,
                          _value.latitude AS latitude,
                          _value.longitude AS longitude,
                          _value.timestamp AS createdTime
                      FROM device_data;
                      
                      -- Heart Rate Data Decomposition
                      INSERT INTO heart_rate_device_topic
                      STORE KEY AS STRING VALUE AS AVRO
                      SELECT STREAM
                          _value.deviceId AS _key,
                          _value.deviceId AS deviceId,
                          _value.heartRate AS value,
                          _value.latitude AS latitude,
                          _value.longitude AS longitude,
                          _value.timestamp AS createdTime
                      FROM device_data;
                      
                      -- Oxygen Saturation Data Decomposition
                      INSERT INTO oxygen_saturation_device_topic
                      STORE KEY AS STRING VALUE AS AVRO
                      SELECT STREAM
                          _value.deviceId AS _key,
                          _value.deviceId AS deviceId,
                          _value.oxygenSaturation AS value,
                          _value.latitude AS latitude,
                          _value.longitude AS longitude,
                          _value.timestamp AS createdTime
                      FROM device_data;
                      
                      -- Temperature Data Decomposition
                      INSERT INTO temperature_device_topic
                      STORE KEY AS STRING VALUE AS AVRO
                      SELECT STREAM
                          _value.deviceId AS _key,
                          _value.deviceId AS deviceId,
                          _value.bodyTemperature AS value,
                          _value.latitude AS latitude,
                          _value.longitude AS longitude,
                          _value.timestamp AS createdTime
                      FROM device_data;
                      EOF
                      
                      # Create Avro schema definitions
                      cat > /tmp/avro-schemas.json << EOF
                      {
                        "device_data": {
                          "type": "record",
                          "name": "HealthData",
                          "namespace": "com.health.streaming",
                          "fields": [
                            {"name": "deviceId", "type": "string"},
                            {"name": "timestamp", "type": "long"},
                            {"name": "heartRate", "type": "int"},
                            {"name": "systolic", "type": "int"},
                            {"name": "diastolic", "type": "int"},
                            {"name": "oxygenSaturation", "type": "int"},
                            {"name": "bodyTemperature", "type": "double"},
                            {"name": "latitude", "type": "double"},
                            {"name": "longitude", "type": "double"}
                          ]
                        },
                        "blood_pressure_device_topic": {
                          "type": "record",
                          "name": "BloodPressureData",
                          "namespace": "com.health.streaming",
                          "fields": [
                            {"name": "deviceId", "type": "string"},
                            {"name": "systolic", "type": "int"},
                            {"name": "diastolic", "type": "int"},
                            {"name": "latitude", "type": "double"},
                            {"name": "longitude", "type": "double"},
                            {"name": "createdTime", "type": "long"}
                          ]
                        },
                        "heart_rate_device_topic": {
                          "type": "record",
                          "name": "HeartRateData",
                          "namespace": "com.health.streaming",
                          "fields": [
                            {"name": "deviceId", "type": "string"},
                            {"name": "value", "type": "int"},
                            {"name": "latitude", "type": "double"},
                            {"name": "longitude", "type": "double"},
                            {"name": "createdTime", "type": "long"}
                          ]
                        }
                      }
                      EOF
                      
                      # Create ping-pong demo connector configurations
                      cat > /tmp/ping-pong-connectors.json << EOF
                      {
                        "ping-mqtt-source": {
                          "name": "ping-mqtt-source",
                          "connector.class": "io.lenses.streamreactor.connect.mqtt.source.MqttSourceConnector",
                          "tasks.max": "1",
                          "connect.mqtt.hosts": "tcp://${MQTT_HOST}:1883",
                          "connect.mqtt.username": "${MQTT_USER}",
                          "connect.mqtt.password": "${MQTT_PASSWORD}",
                          "connect.mqtt.kcql": "INSERT INTO ping_topic SELECT messageId, content, timestamp, source FROM ping/messages WITHKEY(messageId)",
                          "connect.mqtt.service.quality": "1",
                          "errors.tolerance": "all"
                        }
                      }
                      EOF
                      
                      # Create ping-pong stream processing queries
                      cat > /tmp/ping-pong-queries.sql << EOF
                      -- Ping to Pong Transformation
                      INSERT INTO pong_topic
                      STORE KEY AS STRING VALUE AS AVRO
                      SELECT STREAM
                          _value.messageId AS _key,
                          STRUCT(
                            messageId := _value.messageId,
                            originalContent := _value.content,
                            response := CONCAT('pong: ', _value.content),
                            pingTimestamp := _value.timestamp,
                            pongTimestamp := UNIX_TIMESTAMP() * 1000,
                            processingTimeMs := (UNIX_TIMESTAMP() * 1000) - _value.timestamp
                          ) AS _value
                      FROM ping_topic;
                      
                      -- Ping Analytics Stream
                      INSERT INTO ping_analytics_topic
                      STORE KEY AS STRING VALUE AS AVRO
                      SELECT STREAM
                          _value.messageId AS _key,
                          STRUCT(
                            messageId := _value.messageId,
                            processingTimeMs := _value.processingTimeMs,
                            timestamp := _value.pongTimestamp,
                            messageCount := COUNT(*) OVER (RANGE INTERVAL '1' MINUTE PRECEDING)
                          ) AS _value
                      FROM pong_topic
                      WHERE _value.processingTimeMs > 0;
                      EOF
                      
                      echo "Configuration files generated successfully"
                    env:
                    - name: LENSES_LICENSE_KEY
                      value: "license_key_2SFZ0BesCNu6NFv0-EOSIvY22ChSzNWXa5nSds2l4z3y7aBgRPKCVnaeMlS57hHNVboR2kKaQ8Mtv1LFt0MPBBACGhDT5If8PmTraUM5xXLz4MYv"
                    - name: POSTGRES_HOST
                      value: "placeholder-postgres"
                    - name: POSTGRES_DB
                      value: "lenses"
                    - name: POSTGRES_USER
                      value: "lenses"
                    - name: POSTGRES_PASSWORD
                      value: "lenses"
                    - name: KAFKA_HOST
                      value: "placeholder-kafka"
                    - name: MQTT_HOST
                      value: "placeholder-mqtt"
                    - name: MQTT_USER
                      value: "realtime-user"
                    - name: MQTT_PASSWORD
                      value: "realtime-pass"
                    - name: LENSES_HQ_URL
                      value: "http://placeholder-lenses-hq:9991"
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-config-generator"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-config-generator"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"
    # Configure environment variables with proper hostnames
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
      transforms:
      - type: string
        string:
          fmt: "%s-postgres.%s.svc.cluster.local"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[5].value
      transforms:
      - type: string
        string:
          fmt: "%s-kafka.%s.svc.cluster.local"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[6].value
      transforms:
      - type: string
        string:
          fmt: "%s-mqtt.%s.svc.cluster.local"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[9].value
      transforms:
      - type: string
        string:
          fmt: "http://%s-lenses-hq.%s.svc.cluster.local:9991"
          type: Format

  # Realtime Platform (Kafka + MQTT + Lenses + Metabase)
  - name: realtime-platform
    base:
      apiVersion: helm.crossplane.io/v1beta1
      kind: Release
      spec:
        forProvider:
          chart:
            name: realtime-platform
            repository: https://charts.bitnami.com/bitnami
            version: "1.0.0"  # Custom chart for realtime platform
          namespace: placeholder
          skipCreateNamespace: false
          values:
            # Kafka configuration (using lensesio/fast-data-dev for all-in-one)
            kafka:
              enabled: true
              image:
                repository: lensesio/fast-data-dev
                tag: "3.9.0"
              service:
                type: ClusterIP
                ports:
                  kafka: 9092
                  schemaRegistry: 8081
                  kafkaConnect: 8083
              environment:
                ADV_HOST: "realtime-kafka"
                RUNNING_SAMPLEDATA: "0"  # Disable demo data
                RUNTESTS: "0"
              persistence:
                enabled: true
                size: "10Gi"
            # MQTT Broker configuration
            mqtt:
              enabled: true
              image:
                repository: eclipse-mosquitto
                tag: "latest"
              service:
                type: ClusterIP
                ports:
                  mqtt: 1883
                  websockets: 9001
              auth:
                enabled: true
                users:
                  - username: "realtime-user"
                    password: "realtime-pass"
              persistence:
                enabled: true
                size: "5Gi"
            # Lenses HQ configuration
            lensesHq:
              enabled: true
              image:
                repository: lensting/lenses-hq
                tag: "6-preview"
              service:
                type: ClusterIP
                port: 9991
              licenseKey: "license_key_2SFZ0BesCNu6NFv0-EOSIvY22ChSzNWXa5nSds2l4z3y7aBgRPKCVnaeMlS57hHNVboR2kKaQ8Mtv1LFt0MPBBACGhDT5If8PmTraUM5xXLz4MYv"
            # Lenses Agent configuration  
            lensesAgent:
              enabled: true
              image:
                repository: lensting/lenses-agent
                tag: "6-preview"
              hqUrl: "http://realtime-lenses-hq:9991"
              heapOpts: "-Xmx1536m -Xms512m"
            # Metabase configuration
            metabase:
              enabled: true
              image:
                repository: metabase/metabase
                tag: "latest"
              service:
                type: ClusterIP
                port: 3000
              database:
                type: postgres
                host: "placeholder-postgres"
                name: "metabasedb"
                user: "metabase"
                password: "metabase-pass"
        providerConfigRef:
          name: default
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-realtime-platform"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"
    # Configure platform name
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.values.platformName
    # Connect to existing PostgreSQL database
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.metabase.database.host
      transforms:
      - type: string
        string:
          fmt: "%s-postgres.%s.svc.cluster.local"
          type: Format

  # Realtime Platform Secrets
  - name: realtime-mqtt-secret
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Secret
            metadata:
              name: placeholder
              namespace: placeholder
            stringData:
              MQTT_HOST: "placeholder"
              MQTT_PORT: "1883"
              MQTT_USER: "realtime-user"
              MQTT_PASSWORD: "realtime-pass"
              MQTT_WEBSOCKET_PORT: "9001"
              MQTT_TOPIC_PREFIX: "health"
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-mqtt-secret"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-mqtt-secret"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"
    # Configure MQTT host
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.stringData.MQTT_HOST
      transforms:
      - type: string
        string:
          fmt: "%s-mqtt.%s.svc.cluster.local"
          type: Format

  - name: realtime-kafka-secret
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Secret
            metadata:
              name: placeholder
              namespace: placeholder
            stringData:
              KAFKA_BOOTSTRAP_SERVERS: "placeholder"
              KAFKA_SCHEMA_REGISTRY_URL: "placeholder"
              KAFKA_CONNECT_URL: "placeholder"
              KAFKA_TOPICS: "device_data,blood_pressure_device_topic,heart_rate_device_topic"
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-kafka-secret"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-kafka-secret"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"
    # Configure Kafka endpoints
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.stringData.KAFKA_BOOTSTRAP_SERVERS
      transforms:
      - type: string
        string:
          fmt: "%s-kafka.%s.svc.cluster.local:9092"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.stringData.KAFKA_SCHEMA_REGISTRY_URL
      transforms:
      - type: string
        string:
          fmt: "http://%s-kafka.%s.svc.cluster.local:8081"
          type: Format

  - name: realtime-lenses-secret
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Secret
            metadata:
              name: placeholder
              namespace: placeholder
            stringData:
              LENSES_URL: "placeholder"
              LENSES_USER: "admin"
              LENSES_PASSWORD: "admin"
              LENSES_HQ_URL: "placeholder"
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-lenses-secret"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-lenses-secret"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"
    # Configure Lenses endpoints
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.stringData.LENSES_URL
      transforms:
      - type: string
        string:
          fmt: "http://%s-lenses-hq.%s.svc.cluster.local:9991"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.stringData.LENSES_HQ_URL
      transforms:
      - type: string
        string:
          fmt: "http://%s-lenses-hq.%s.svc.cluster.local:9991"
          type: Format

  - name: realtime-metabase-secret
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Secret
            metadata:
              name: placeholder
              namespace: placeholder
            stringData:
              METABASE_URL: "placeholder"
              METABASE_USER: "admin@example.com"
              METABASE_PASSWORD: "metabase123"
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-metabase-secret"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-metabase-secret"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"
    # Configure Metabase endpoint
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.stringData.METABASE_URL
      transforms:
      - type: string
        string:
          fmt: "http://%s-metabase.%s.svc.cluster.local:3000"
          type: Format