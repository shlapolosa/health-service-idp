apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: application-claim-composition
  labels:
    crossplane.io/xrd: xapplicationclaims.platform.example.org
    provider: github-kubernetes-helm
spec:
  writeConnectionSecretsToNamespace: crossplane-system
  compositeTypeRef:
    apiVersion: platform.example.org/v1alpha1
    kind: XApplicationClaim
  resources:
  
  # Add microservice to existing AppContainer source repository
  - name: add-microservice-to-container
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: default
            spec:
              template:
                spec:
                  serviceAccountName: crossplane-github-provider
                  restartPolicy: OnFailure
                  containers:
                  - name: microservice-creator
                    image: alpine/git:latest
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      echo "Adding microservice $SERVICE_NAME to AppContainer $APP_CONTAINER..."
                      
                      TEMP_DIR="/tmp/app-container-$APP_CONTAINER"
                      mkdir -p $TEMP_DIR
                      cd $TEMP_DIR
                      
                      # Clone the AppContainer repository using GitHub token
                      git clone https://$GITHUB_TOKEN@github.com/$GITHUB_USER/$APP_CONTAINER.git .
                      
                      # Create microservice directory
                      mkdir -p microservices/$SERVICE_NAME
                      cd microservices/$SERVICE_NAME
                      
                      # Create CLAUDE.md-compliant Onion Architecture structure
                      mkdir -p src/domain
                      mkdir -p src/application  
                      mkdir -p src/infrastructure
                      mkdir -p src/interface
                      mkdir -p tests/unit
                      mkdir -p tests/integration
                      mkdir -p manifest
                      
                      if [ "$LANGUAGE" = "python" ] && [ "$FRAMEWORK" = "fastapi" ]; then
                        # Python FastAPI microservice with CLAUDE.md structure
                        cat > pyproject.toml << EOF
                      [tool.poetry]
                      name = "$SERVICE_NAME"
                      version = "0.1.0"
                      description = "CLAUDE.md-compliant FastAPI microservice"
                      authors = ["Generated by ApplicationClaim"]
                      
                      [tool.poetry.dependencies]
                      python = "^3.11"
                      fastapi = "^0.104.0"
                      uvicorn = "^0.24.0"
                      pydantic = "^2.0.0"
                      sqlalchemy = "^2.0.0"
                      
                      [tool.poetry.group.dev.dependencies]
                      pytest = "^7.4.0"
                      pytest-asyncio = "^0.21.0"
                      black = "^23.0.0"
                      isort = "^5.12.0"
                      mypy = "^1.5.0"
                      
                      [build-system]
                      requires = ["poetry-core"]
                      build-backend = "poetry.core.masonry.api"
                      EOF
                      
                        # Domain layer
                        cat > src/domain/models.py << EOF
                      """Domain models following CLAUDE.md Onion Architecture"""
                      from abc import ABC, abstractmethod
                      from typing import Optional
                      from pydantic import BaseModel
                      
                      class Entity(BaseModel):
                          """Base domain entity"""
                          id: Optional[str] = None
                      
                      class DomainService(ABC):
                          """Base domain service interface"""
                          pass
                      EOF
                      
                        # Application layer
                        cat > src/application/use_cases.py << EOF
                      """Application use cases following CLAUDE.md principles"""
                      from abc import ABC, abstractmethod
                      from typing import Generic, TypeVar
                      
                      T = TypeVar('T')
                      
                      class UseCase(ABC, Generic[T]):
                          """Base use case following CLAUDE.md patterns"""
                          
                          @abstractmethod
                          async def execute(self, request: T) -> dict:
                              pass
                      EOF
                      
                        # Infrastructure layer
                        cat > src/infrastructure/repositories.py << EOF
                      """Infrastructure repositories with dependency injection"""
                      from abc import ABC, abstractmethod
                      from typing import List, Optional
                      
                      class Repository(ABC):
                          """Base repository interface for dependency injection"""
                          pass
                      EOF
                      
                        # Interface layer (FastAPI)
                        cat > src/interface/api.py << EOF
                      """FastAPI interface layer following CLAUDE.md 12-factor principles"""
                      import os
                      from fastapi import FastAPI, Depends
                      from pydantic import BaseModel
                      
                      # 12-Factor: Config from environment
                      DATABASE_URL = os.getenv("DATABASE_URL", "")
                      REDIS_URL = os.getenv("REDIS_URL", "")
                      
                      app = FastAPI(
                          title="$SERVICE_NAME",
                          description="CLAUDE.md-compliant microservice with Onion Architecture",
                          version="0.1.0"
                      )
                      
                      class HealthResponse(BaseModel):
                          status: str
                          service: str
                      
                      @app.get("/health", response_model=HealthResponse)
                      async def health_check():
                          """Health check endpoint for Kubernetes probes"""
                          return HealthResponse(status="healthy", service="$SERVICE_NAME")
                      
                      @app.get("/ready", response_model=HealthResponse)
                      async def readiness_check():
                          """Readiness check endpoint for Kubernetes probes"""
                          return HealthResponse(status="ready", service="$SERVICE_NAME")
                      
                      @app.get("/")
                      async def root():
                          """Root endpoint"""
                          return {"message": "Hello from $SERVICE_NAME", "architecture": "onion"}
                      EOF
                      
                        # Main application entry point
                        cat > src/main.py << EOF
                      """Main application entry point following 12-factor principles"""
                      import os
                      import uvicorn
                      from interface.api import app
                      
                      if __name__ == "__main__":
                          # 12-Factor: Port binding
                          port = int(os.getenv("PORT", 8080))
                          uvicorn.run(app, host="0.0.0.0", port=port)
                      EOF
                      
                        # Multi-stage Dockerfile optimized for microservices build context
                        cat > Dockerfile << EOF
                      # Multi-stage build for production
                      FROM python:3.11-slim as builder
                      
                      # Install Poetry and basic build tools
                      RUN apt-get update && apt-get install -y curl gcc && rm -rf /var/lib/apt/lists/*
                      RUN pip install poetry
                      
                      # Set working directory for build
                      WORKDIR /build
                      
                      # Copy dependency files
                      COPY pyproject.toml ./
                      
                      # Configure poetry and install dependencies without dev packages (no-root to skip project install)
                      RUN poetry config virtualenvs.create false \
                          && poetry install --only=main --no-root --no-interaction --no-ansi
                      
                      # Production stage
                      FROM python:3.11-slim as production
                      
                      # Install curl for health checks
                      RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*
                      
                      # Create non-root user (security best practice)
                      RUN useradd --create-home --shell /bin/bash app
                      
                      # Copy installed packages from builder
                      COPY --from=builder /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages
                      COPY --from=builder /usr/local/bin /usr/local/bin
                      
                      # Set working directory
                      WORKDIR /app
                      
                      # Copy application code
                      COPY --chown=app:app src/ src/
                      
                      # Switch to non-root user
                      USER app
                      
                      # 12-Factor: Port binding
                      EXPOSE 8080
                      
                      # Health check with better error handling
                      HEALTHCHECK --interval=30s --timeout=10s --start-period=15s --retries=3 \
                        CMD curl -f http://localhost:8080/health || exit 1
                      
                      # Start application
                      CMD ["python", "-m", "src.main"]
                      EOF
                      
                        # TDD Tests
                        cat > tests/test_main.py << EOF
                      """TDD tests following CLAUDE.md principles"""
                      import pytest
                      from fastapi.testclient import TestClient
                      from src.interface.api import app
                      
                      client = TestClient(app)
                      
                      def test_health_check():
                          """Test health endpoint (TDD Red-Green-Refactor)"""
                          response = client.get("/health")
                          assert response.status_code == 200
                          data = response.json()
                          assert data["status"] == "healthy"
                          assert data["service"] == "$SERVICE_NAME"
                      
                      def test_readiness_check():
                          """Test readiness endpoint"""
                          response = client.get("/ready")
                          assert response.status_code == 200
                          data = response.json()
                          assert data["status"] == "ready"
                      
                      def test_root_endpoint():
                          """Test root endpoint"""
                          response = client.get("/")
                          assert response.status_code == 200
                          data = response.json()
                          assert "Hello from" in data["message"]
                          assert data["architecture"] == "onion"
                      EOF
                      fi
                      
                      # Create service README
                      cat > README.md << EOF
                      # $SERVICE_NAME
                      
                      CLAUDE.md-compliant microservice with Onion Architecture and 12-Factor principles.
                      
                      ## Architecture
                      
                      This microservice follows the Onion Architecture pattern:
                      
                      - **Domain Layer**: Business rules (`src/domain/`)
                      - **Application Layer**: Use cases (`src/application/`)
                      - **Interface Layer**: REST/API endpoints (`src/interface/`)
                      - **Infrastructure Layer**: Database, external services (`src/infrastructure/`)
                      
                      ## Development
                      
                      ### Prerequisites
                      - Python 3.11+
                      - Poetry
                      
                      ### Setup
                      ```bash
                      poetry install
                      poetry run pytest  # Run TDD tests
                      poetry run python src/main.py  # Run locally
                      ```
                      
                      ### Testing (TDD)
                      ```bash
                      poetry run pytest -v
                      ```
                      
                      ### Linting
                      ```bash
                      poetry run black src/
                      poetry run isort src/
                      poetry run mypy src/
                      ```
                      
                      ## Deployment
                      
                      This service is automatically deployed via the AppContainer CI/CD pipeline when changes are pushed to the main branch.
                      EOF
                      
                      # Update microservices README
                      cd ../../
                      if grep -q "- (Services will be listed here as they are added)" microservices/README.md; then
                        sed -i "s/- (Services will be listed here as they are added)/- $SERVICE_NAME ($LANGUAGE\/$FRAMEWORK)/" microservices/README.md
                      else
                        echo "- $SERVICE_NAME ($LANGUAGE/$FRAMEWORK)" >> microservices/README.md
                      fi
                      
                      # Commit and push
                      git config user.name "ApplicationClaim"
                      git config user.email "applicationclaim@platform.local"
                      git add .
                      git commit -m "Add $SERVICE_NAME microservice ($LANGUAGE/$FRAMEWORK)
                      
                      - Implements CLAUDE.md Onion Architecture
                      - Follows 12-Factor App principles
                      - Includes TDD test structure with pytest
                      - Dependency injection ready
                      - FastAPI with health checks
                      - Multi-stage Dockerfile
                      - Poetry for dependency management"
                      git push
                      
                      echo "Microservice $SERVICE_NAME added to AppContainer $APP_CONTAINER successfully"
                    env:
                    - name: APP_CONTAINER
                      value: placeholder
                    - name: SERVICE_NAME
                      value: placeholder
                    - name: LANGUAGE
                      value: placeholder
                    - name: FRAMEWORK
                      value: placeholder
                    - name: GITHUB_TOKEN
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: token
                    - name: GITHUB_USER
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: user
                    - name: DOCKER_REGISTRY
                      valueFrom:
                        secretKeyRef:
                          name: docker-credentials
                          key: registry
                    - name: DOCKER_USER
                      valueFrom:
                        secretKeyRef:
                          name: docker-credentials
                          key: username
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-microservice-creator"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.language
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.framework
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[3].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-microservice-creator"

  # Add GitOps manifests for the new microservice
  - name: add-gitops-manifests
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: default
            spec:
              template:
                spec:
                  serviceAccountName: crossplane-github-provider
                  restartPolicy: OnFailure
                  containers:
                  - name: gitops-manifest-creator
                    image: alpine/git:latest
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      echo "Adding GitOps manifests for $SERVICE_NAME in $APP_CONTAINER-gitops..."
                      
                      TEMP_DIR="/tmp/gitops-$APP_CONTAINER"
                      mkdir -p $TEMP_DIR
                      cd $TEMP_DIR
                      
                      # Clone the GitOps repository using GitHub token
                      git clone https://$GITHUB_TOKEN@github.com/$GITHUB_USER/$APP_CONTAINER-gitops.git .
                      
                      # Create manifests directory for the service
                      mkdir -p manifests/$SERVICE_NAME
                      cd manifests/$SERVICE_NAME
                      
                      # Create Knative Service manifest with cost optimization
                      cat > knative-service.yaml << EOF
                      apiVersion: serving.knative.dev/v1
                      kind: Service
                      metadata:
                        name: $SERVICE_NAME
                        namespace: $APP_CONTAINER
                        annotations:
                          # Cost optimization: Scale to zero when not in use
                          autoscaling.knative.dev/min-scale: "0"
                          autoscaling.knative.dev/max-scale: "5"
                          autoscaling.knative.dev/target: "50"
                          autoscaling.knative.dev/metric: "concurrency"
                          # Karpenter optimization
                          karpenter.sh/do-not-evict: "false"
                          cluster-autoscaler.kubernetes.io/safe-to-evict: "true"
                          # Internal only for cost savings
                          serving.knative.dev/visibility: "cluster-local"
                      spec:
                        template:
                          metadata:
                            annotations:
                              autoscaling.knative.dev/min-scale: "0"
                              autoscaling.knative.dev/max-scale: "5"
                              autoscaling.knative.dev/target: "50"
                              autoscaling.knative.dev/scale-to-zero-pod-retention-period: "30s"
                              # Queue proxy resource optimization
                              queue.sidecar.serving.knative.dev/cpu-resource-request: "25m"
                              queue.sidecar.serving.knative.dev/memory-resource-request: "50Mi"
                              queue.sidecar.serving.knative.dev/cpu-resource-limit: "100m"
                              queue.sidecar.serving.knative.dev/memory-resource-limit: "100Mi"
                          spec:
                            # Lower concurrency for better resource utilization
                            containerConcurrency: 50
                            # Shorter timeout for cost optimization
                            timeoutSeconds: 300
                            containers:
                            - image: $DOCKER_REGISTRY/$DOCKER_USER/$SERVICE_NAME:latest
                              ports:
                              - containerPort: 8080
                                name: http1
                              env:
                              - name: APP_NAME
                                value: $SERVICE_NAME
                              - name: LOG_LEVEL
                                value: "INFO"
                              - name: PORT
                                value: "8080"
                              envFrom:
                              - configMapRef:
                                  name: $SERVICE_NAME-config
                                  optional: true
                              - secretRef:
                                  name: $SERVICE_NAME-postgres-secret
                                  optional: true
                              - secretRef:
                                  name: $SERVICE_NAME-redis-secret
                                  optional: true
                              # Health checks optimized for cold starts
                              livenessProbe:
                                httpGet:
                                  path: /health
                                  port: 8080
                                initialDelaySeconds: 15
                                periodSeconds: 15
                                timeoutSeconds: 5
                                failureThreshold: 3
                              readinessProbe:
                                httpGet:
                                  path: /health
                                  port: 8080
                                initialDelaySeconds: 5
                                periodSeconds: 10
                                timeoutSeconds: 3
                                successThreshold: 1
                                failureThreshold: 3
                              # Minimal resource requests for cost optimization
                              resources:
                                requests:
                                  cpu: 100m
                                  memory: 128Mi
                                limits:
                                  cpu: 500m
                                  memory: 256Mi
                              # Security context
                              securityContext:
                                allowPrivilegeEscalation: false
                                runAsNonRoot: true
                                runAsUser: 1001
                                capabilities:
                                  drop:
                                  - ALL
                                seccompProfile:
                                  type: RuntimeDefault
                      EOF
                      
                      # Create ConfigMap for environment variables
                      cat > configmap.yaml << EOF
                      apiVersion: v1
                      kind: ConfigMap
                      metadata:
                        name: $SERVICE_NAME-config
                        namespace: $APP_CONTAINER
                      data:
                        APP_ENV: "production"
                        SERVICE_NAME: "$SERVICE_NAME"
                      EOF
                      
                      # Add database config if needed
                      if [ "$DATABASE" = "postgres" ]; then
                        cat >> configmap.yaml << EOF
                        DATABASE_URL: "postgresql://\$DATABASE_USER:\$DATABASE_PASSWORD@$APP_CONTAINER-postgres-rw.$APP_CONTAINER.svc.cluster.local:5432/$SERVICE_NAME"
                      EOF
                      fi
                      
                      # Add cache config if needed  
                      if [ "$CACHE" = "redis" ]; then
                        cat >> configmap.yaml << EOF
                        REDIS_URL: "redis://:\$REDIS_PASSWORD@$APP_CONTAINER-redis-master.$APP_CONTAINER.svc.cluster.local:6379/0"
                      EOF
                      fi
                      
                      # Create OAM Component in correct directory
                      cd ../../oam/components
                      cat > $SERVICE_NAME.yaml << EOF
                      apiVersion: core.oam.dev/v1beta1
                      kind: Component
                      metadata:
                        name: $SERVICE_NAME
                        namespace: $APP_CONTAINER
                        labels:
                          app.oam.dev/component: $SERVICE_NAME
                          app.oam.dev/name: $APP_CONTAINER
                      spec:
                        workload:
                          apiVersion: serving.knative.dev/v1
                          kind: Service
                          metadata:
                            name: $SERVICE_NAME
                          spec:
                            template:
                              spec:
                                containers:
                                - name: $SERVICE_NAME
                                  image: $DOCKER_REGISTRY/$DOCKER_USER/$SERVICE_NAME:latest
                                  ports:
                                  - containerPort: 8080
                                  env:
                                  - name: APP_NAME
                                    value: $SERVICE_NAME
                        parameters:
                        - name: image
                          fieldPaths:
                          - "spec.template.spec.containers[0].image"
                        - name: replicas
                          fieldPaths:
                          - "metadata.annotations[autoscaling.knative.dev/minScale]"
                      EOF
                      
                      # Commit and push GitOps changes
                      cd ..
                      git config user.name "ApplicationClaim GitOps"
                      git config user.email "applicationclaim-gitops@platform.local"
                      git add .
                      git commit -m "Add GitOps manifests for $SERVICE_NAME microservice
                      
                      - Add Knative Service for $SERVICE_NAME
                      - Add ConfigMap for environment variables  
                      - Add OAM Component definition
                      - Configure autoscaling and health checks
                      - Ready for ArgoCD ApplicationSet deployment"
                      git push
                      
                      echo "GitOps manifests for $SERVICE_NAME added successfully"
                    env:
                    - name: APP_CONTAINER
                      value: placeholder
                    - name: SERVICE_NAME
                      value: placeholder
                    - name: DATABASE
                      value: placeholder
                    - name: CACHE
                      value: placeholder
                    - name: GITHUB_TOKEN
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: token
                    - name: GITHUB_USER
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: user
                    - name: DOCKER_REGISTRY
                      valueFrom:
                        secretKeyRef:
                          name: docker-credentials
                          key: registry
                    - name: DOCKER_USER
                      valueFrom:
                        secretKeyRef:
                          name: docker-credentials
                          key: username
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-gitops-creator"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.database
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.cache
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[3].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-gitops-creator"

  # PostgreSQL Database (conditional on spec.database=postgres)
  - name: postgres-database
    base:
      apiVersion: helm.crossplane.io/v1beta1
      kind: Release
      spec:
        forProvider:
          chart:
            name: postgresql
            repository: https://charts.bitnami.com/bitnami
            version: "13.2.24"
          namespace: placeholder
          skipCreateNamespace: false
          values:
            auth:
              enablePostgresUser: true
              postgresPassword: "placeholder"
              username: "placeholder"
              password: "placeholder"
              database: "placeholder"
            primary:
              persistence:
                enabled: true
                size: 10Gi
                storageClass: gp2
              resources:
                requests:
                  memory: 256Mi
                  cpu: 250m
                limits:
                  memory: 512Mi
                  cpu: 500m
              readinessProbe:
                enabled: true
                initialDelaySeconds: 30
                periodSeconds: 10
              livenessProbe:
                enabled: true
                initialDelaySeconds: 30
                periodSeconds: 10
            metrics:
              enabled: true
              serviceMonitor:
                enabled: false
            backup:
              enabled: false
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-postgres"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.auth.database
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.auth.username
    # Generate random passwords (in production, use External Secrets)
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.auth.postgresPassword
      transforms:
      - type: string
        string:
          fmt: "%s-postgres-admin-pass"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.auth.password
      transforms:
      - type: string
        string:
          fmt: "%s-user-pass"
    # Status patches for database connection info
    - type: ToCompositeFieldPath
      fromFieldPath: status.atProvider.state
      toFieldPath: status.infrastructure.database.ready
      transforms:
      - type: map
        map:
          "deployed": true
          "failed": false
      policy:
        fromFieldPath: Optional
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: status.infrastructure.database.endpoint
      transforms:
      - type: string
        string:
          fmt: "%s-postgresql.%s.svc.cluster.local:5432"
      policy:
        fromFieldPath: Optional
    # Only deploy if database is postgres
    - type: FromCompositeFieldPath
      fromFieldPath: spec.database
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "postgres": "true"
          "none": "false"

  # Redis Cache (conditional on spec.cache=redis)
  - name: redis-cache
    base:
      apiVersion: helm.crossplane.io/v1beta1
      kind: Release
      spec:
        forProvider:
          chart:
            name: redis
            repository: https://charts.bitnami.com/bitnami
            version: "18.4.0"
          namespace: placeholder
          skipCreateNamespace: false
          values:
            auth:
              enabled: true
              password: "placeholder"
            master:
              persistence:
                enabled: true
                size: 5Gi
                storageClass: gp2
              resources:
                requests:
                  memory: 128Mi
                  cpu: 100m
                limits:
                  memory: 256Mi
                  cpu: 200m
            replica:
              replicaCount: 1
              persistence:
                enabled: true
                size: 5Gi
                storageClass: gp2
              resources:
                requests:
                  memory: 128Mi
                  cpu: 100m
                limits:
                  memory: 256Mi
                  cpu: 200m
            metrics:
              enabled: true
              serviceMonitor:
                enabled: false
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-redis"
    # Generate random password (in production, use External Secrets)
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.auth.password
      transforms:
      - type: string
        string:
          fmt: "%s-redis-pass"
    # Status patches for cache connection info
    - type: ToCompositeFieldPath
      fromFieldPath: status.atProvider.state
      toFieldPath: status.infrastructure.cache.ready
      transforms:
      - type: map
        map:
          "deployed": true
          "failed": false
      policy:
        fromFieldPath: Optional
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: status.infrastructure.cache.endpoint
      transforms:
      - type: string
        string:
          fmt: "%s-redis-master.%s.svc.cluster.local:6379"
      policy:
        fromFieldPath: Optional
    # Only deploy if cache is redis
    - type: FromCompositeFieldPath
      fromFieldPath: spec.cache
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "redis": "true"
          "none": "false"

  # Database Secret (PostgreSQL credentials)
  - name: postgres-secret
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Secret
            metadata:
              name: placeholder
              namespace: placeholder
            type: Opaque
            stringData:
              # Plain text values - Kubernetes will base64 encode automatically
              DATABASE_URL: ""
              DB_HOST: ""
              DB_PORT: "5432"
              DB_NAME: ""
              DB_USER: ""
              DB_PASSWORD: ""
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-postgres-secret"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-postgres-secret"
    # Only create if database is postgres
    - type: FromCompositeFieldPath
      fromFieldPath: spec.database
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "postgres": "true"
          "none": "false"
    # Patch secret values with plain text (Kubernetes will base64 encode)
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.stringData.DB_HOST
      transforms:
      - type: string
        string:
          fmt: "%s-postgresql.%s.svc.cluster.local"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.DB_NAME
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.DB_USER
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.DB_PASSWORD
      transforms:
      - type: string
        string:
          fmt: "%s-user-pass"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.DATABASE_URL
      transforms:
      - type: string
        string:
          fmt: "postgresql://%s:%s-user-pass@claims-postgresql.claims.svc.cluster.local:5432/%s"
          type: Format

  # Cache Secret (Redis credentials)
  - name: redis-secret
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Secret
            metadata:
              name: placeholder
              namespace: placeholder
            type: Opaque
            stringData:
              # Plain text values - Kubernetes will base64 encode automatically
              REDIS_URL: ""
              REDIS_HOST: ""
              REDIS_PORT: "6379"
              REDIS_PASSWORD: ""
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-redis-secret"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-redis-secret"
    # Only create if cache is redis
    - type: FromCompositeFieldPath
      fromFieldPath: spec.cache
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "redis": "true"
          "none": "false"
    # Patch Redis secret values
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.stringData.REDIS_HOST
      transforms:
      - type: string
        string:
          fmt: "%s-redis-master.%s.svc.cluster.local"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.REDIS_PASSWORD
      transforms:
      - type: string
        string:
          fmt: "%s-redis-pass"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.REDIS_URL
      transforms:
      - type: string
        string:
          fmt: "redis://:%s-redis-pass@claims-redis-master.claims.svc.cluster.local:6379/0"
          type: Format

  # Configuration Generator for Realtime Platform
  - name: realtime-config-generator
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: placeholder
            spec:
              template:
                spec:
                  restartPolicy: OnFailure
                  containers:
                  - name: config-generator
                    image: busybox:latest
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      echo "Generating Lenses configuration files..."
                      
                      # Create Lenses HQ config.yaml
                      cat > /tmp/hq-config.yaml << EOF
                      lenses:
                        http:
                          port: 9991
                          bind: 0.0.0.0
                        authentication:
                          default:
                            enabled: true
                            username: admin
                            password: admin
                        license:
                          key: "${LENSES_LICENSE_KEY}"
                        database:
                          url: "jdbc:postgresql://${POSTGRES_HOST}:5432/${POSTGRES_DB}"
                          username: "${POSTGRES_USER}"
                          password: "${POSTGRES_PASSWORD}"
                        kafka:
                          brokers:
                            - "${KAFKA_HOST}:9092"
                          schema-registry:
                            url: "http://${KAFKA_HOST}:8081"
                      EOF
                      
                      # Create Lenses Agent lenses.conf
                      cat > /tmp/agent-config.conf << EOF
                      lenses.hq.url=${LENSES_HQ_URL}
                      lenses.hq.user=admin
                      lenses.hq.password=admin
                      lenses.heap.opts=-Xmx1536m -Xms512m
                      EOF
                      
                      # Create provisioning.yaml for MQTT/Kafka connectors
                      cat > /tmp/provisioning.yaml << EOF
                      connectors:
                        - name: "mqtt-source-connector"
                          config:
                            connector.class: "io.lenses.streamreactor.connect.mqtt.source.MqttSourceConnector"
                            tasks.max: "1"
                            connect.mqtt.hosts: "tcp://${MQTT_HOST}:1883"
                            connect.mqtt.username: "${MQTT_USER}"
                            connect.mqtt.password: "${MQTT_PASSWORD}"
                            connect.mqtt.kcql: "INSERT INTO device_data SELECT * FROM health/device_data WITHKEY(deviceId)"
                            connect.mqtt.service.quality: "1"
                      EOF
                      
                      # Create stream processing queries for data decomposition
                      cat > /tmp/stream-queries.sql << EOF
                      -- Blood Pressure Data Decomposition
                      INSERT INTO blood_pressure_device_topic
                      STORE KEY AS STRING VALUE AS AVRO
                      SELECT STREAM
                          _value.deviceId AS _key,
                          _value.deviceId AS deviceId,
                          _value.systolic AS systolic,
                          _value.diastolic AS diastolic,
                          _value.latitude AS latitude,
                          _value.longitude AS longitude,
                          _value.timestamp AS createdTime
                      FROM device_data;
                      
                      -- Heart Rate Data Decomposition
                      INSERT INTO heart_rate_device_topic
                      STORE KEY AS STRING VALUE AS AVRO
                      SELECT STREAM
                          _value.deviceId AS _key,
                          _value.deviceId AS deviceId,
                          _value.heartRate AS value,
                          _value.latitude AS latitude,
                          _value.longitude AS longitude,
                          _value.timestamp AS createdTime
                      FROM device_data;
                      
                      -- Oxygen Saturation Data Decomposition
                      INSERT INTO oxygen_saturation_device_topic
                      STORE KEY AS STRING VALUE AS AVRO
                      SELECT STREAM
                          _value.deviceId AS _key,
                          _value.deviceId AS deviceId,
                          _value.oxygenSaturation AS value,
                          _value.latitude AS latitude,
                          _value.longitude AS longitude,
                          _value.timestamp AS createdTime
                      FROM device_data;
                      
                      -- Temperature Data Decomposition
                      INSERT INTO temperature_device_topic
                      STORE KEY AS STRING VALUE AS AVRO
                      SELECT STREAM
                          _value.deviceId AS _key,
                          _value.deviceId AS deviceId,
                          _value.bodyTemperature AS value,
                          _value.latitude AS latitude,
                          _value.longitude AS longitude,
                          _value.timestamp AS createdTime
                      FROM device_data;
                      EOF
                      
                      # Create Avro schema definitions
                      cat > /tmp/avro-schemas.json << EOF
                      {
                        "device_data": {
                          "type": "record",
                          "name": "HealthData",
                          "namespace": "com.health.streaming",
                          "fields": [
                            {"name": "deviceId", "type": "string"},
                            {"name": "timestamp", "type": "long"},
                            {"name": "heartRate", "type": "int"},
                            {"name": "systolic", "type": "int"},
                            {"name": "diastolic", "type": "int"},
                            {"name": "oxygenSaturation", "type": "int"},
                            {"name": "bodyTemperature", "type": "double"},
                            {"name": "latitude", "type": "double"},
                            {"name": "longitude", "type": "double"}
                          ]
                        },
                        "blood_pressure_device_topic": {
                          "type": "record",
                          "name": "BloodPressureData",
                          "namespace": "com.health.streaming",
                          "fields": [
                            {"name": "deviceId", "type": "string"},
                            {"name": "systolic", "type": "int"},
                            {"name": "diastolic", "type": "int"},
                            {"name": "latitude", "type": "double"},
                            {"name": "longitude", "type": "double"},
                            {"name": "createdTime", "type": "long"}
                          ]
                        },
                        "heart_rate_device_topic": {
                          "type": "record",
                          "name": "HeartRateData",
                          "namespace": "com.health.streaming",
                          "fields": [
                            {"name": "deviceId", "type": "string"},
                            {"name": "value", "type": "int"},
                            {"name": "latitude", "type": "double"},
                            {"name": "longitude", "type": "double"},
                            {"name": "createdTime", "type": "long"}
                          ]
                        }
                      }
                      EOF
                      
                      # Create ping-pong demo connector configurations
                      cat > /tmp/ping-pong-connectors.json << EOF
                      {
                        "ping-mqtt-source": {
                          "name": "ping-mqtt-source",
                          "connector.class": "io.lenses.streamreactor.connect.mqtt.source.MqttSourceConnector",
                          "tasks.max": "1",
                          "connect.mqtt.hosts": "tcp://${MQTT_HOST}:1883",
                          "connect.mqtt.username": "${MQTT_USER}",
                          "connect.mqtt.password": "${MQTT_PASSWORD}",
                          "connect.mqtt.kcql": "INSERT INTO ping_topic SELECT messageId, content, timestamp, source FROM ping/messages WITHKEY(messageId)",
                          "connect.mqtt.service.quality": "1",
                          "errors.tolerance": "all"
                        }
                      }
                      EOF
                      
                      # Create ping-pong stream processing queries
                      cat > /tmp/ping-pong-queries.sql << EOF
                      -- Ping to Pong Transformation
                      INSERT INTO pong_topic
                      STORE KEY AS STRING VALUE AS AVRO
                      SELECT STREAM
                          _value.messageId AS _key,
                          STRUCT(
                            messageId := _value.messageId,
                            originalContent := _value.content,
                            response := CONCAT('pong: ', _value.content),
                            pingTimestamp := _value.timestamp,
                            pongTimestamp := UNIX_TIMESTAMP() * 1000,
                            processingTimeMs := (UNIX_TIMESTAMP() * 1000) - _value.timestamp
                          ) AS _value
                      FROM ping_topic;
                      
                      -- Ping Analytics Stream
                      INSERT INTO ping_analytics_topic
                      STORE KEY AS STRING VALUE AS AVRO
                      SELECT STREAM
                          _value.messageId AS _key,
                          STRUCT(
                            messageId := _value.messageId,
                            processingTimeMs := _value.processingTimeMs,
                            timestamp := _value.pongTimestamp,
                            messageCount := COUNT(*) OVER (RANGE INTERVAL '1' MINUTE PRECEDING)
                          ) AS _value
                      FROM pong_topic
                      WHERE _value.processingTimeMs > 0;
                      EOF
                      
                      echo "Configuration files generated successfully"
                    env:
                    - name: LENSES_LICENSE_KEY
                      value: "license_key_2SFZ0BesCNu6NFv0-EOSIvY22ChSzNWXa5nSds2l4z3y7aBgRPKCVnaeMlS57hHNVboR2kKaQ8Mtv1LFt0MPBBACGhDT5If8PmTraUM5xXLz4MYv"
                    - name: POSTGRES_HOST
                      value: "placeholder-postgres"
                    - name: POSTGRES_DB
                      value: "lenses"
                    - name: POSTGRES_USER
                      value: "lenses"
                    - name: POSTGRES_PASSWORD
                      value: "lenses"
                    - name: KAFKA_HOST
                      value: "placeholder-kafka"
                    - name: MQTT_HOST
                      value: "placeholder-mqtt"
                    - name: MQTT_USER
                      value: "realtime-user"
                    - name: MQTT_PASSWORD
                      value: "realtime-pass"
                    - name: LENSES_HQ_URL
                      value: "http://placeholder-lenses-hq:9991"
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-config-generator"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-config-generator"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"
    # Configure environment variables with proper hostnames
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
      transforms:
      - type: string
        string:
          fmt: "%s-postgres.%s.svc.cluster.local"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[5].value
      transforms:
      - type: string
        string:
          fmt: "%s-kafka.%s.svc.cluster.local"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[6].value
      transforms:
      - type: string
        string:
          fmt: "%s-mqtt.%s.svc.cluster.local"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[9].value
      transforms:
      - type: string
        string:
          fmt: "http://%s-lenses-hq.%s.svc.cluster.local:9991"
          type: Format

  # Realtime Platform Namespace - Only created when realtime field is specified
  - name: realtime-namespace
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Namespace
            metadata:
              name: placeholder-realtime
              labels:
                app.kubernetes.io/managed-by: crossplane
                app.kubernetes.io/part-of: realtime-platform
        providerConfigRef:
          name: default
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-realtime"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-realtime-namespace"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"

  # PostgreSQL Storage for Realtime Platform
  - name: realtime-postgres-storage
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: PersistentVolumeClaim
            metadata:
              name: postgres-data
              namespace: placeholder-realtime
              labels:
                app.kubernetes.io/name: postgres
                app.kubernetes.io/component: database
            spec:
              accessModes:
                - ReadWriteOnce
              storageClassName: gp2
              resources:
                requests:
                  storage: 10Gi
        providerConfigRef:
          name: default
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      transforms:
      - type: string
        string:
          fmt: "%s-realtime"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-realtime-postgres-storage"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"

  # PostgreSQL Secret
  - name: realtime-postgres-secret
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Secret
            metadata:
              name: postgres-secret
              namespace: placeholder-realtime
              labels:
                app.kubernetes.io/name: postgres
                app.kubernetes.io/component: database
            type: Opaque
            data:
              POSTGRES_DB: bGVuc2Vz  # 'lenses' base64
              POSTGRES_USER: bGVuc2Vz  # 'lenses' base64
              POSTGRES_PASSWORD: bGVuc2Vz  # 'lenses' base64
        providerConfigRef:
          name: default
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      transforms:
      - type: string
        string:
          fmt: "%s-realtime"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-realtime-postgres-secret"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"

  # PostgreSQL Deployment
  - name: realtime-postgres
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: postgres
              namespace: placeholder-realtime
              labels:
                app.kubernetes.io/name: postgres
                app.kubernetes.io/component: database
            spec:
              replicas: 1
              selector:
                matchLabels:
                  app.kubernetes.io/name: postgres
              template:
                metadata:
                  labels:
                    app.kubernetes.io/name: postgres
                    app.kubernetes.io/component: database
                spec:
                  containers:
                  - name: postgres
                    image: postgres:13
                    ports:
                    - containerPort: 5432
                      name: postgresql
                    envFrom:
                    - secretRef:
                        name: postgres-secret
                    volumeMounts:
                    - name: postgres-storage
                      mountPath: /var/lib/postgresql/data
                    resources:
                      requests:
                        memory: "256Mi"
                        cpu: "100m"
                      limits:
                        memory: "512Mi"
                        cpu: "500m"
                    livenessProbe:
                      exec:
                        command:
                        - pg_isready
                        - -U
                        - lenses
                      initialDelaySeconds: 30
                      periodSeconds: 10
                    readinessProbe:
                      exec:
                        command:
                        - pg_isready
                        - -U
                        - lenses
                      initialDelaySeconds: 5
                      periodSeconds: 5
                  volumes:
                  - name: postgres-storage
                    persistentVolumeClaim:
                      claimName: postgres-data
                  restartPolicy: Always
        providerConfigRef:
          name: default
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      transforms:
      - type: string
        string:
          fmt: "%s-realtime"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-realtime-postgres"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"

  # PostgreSQL Service
  - name: realtime-postgres-service
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Service
            metadata:
              name: postgres
              namespace: placeholder-realtime
              labels:
                app.kubernetes.io/name: postgres
                app.kubernetes.io/component: database
            spec:
              selector:
                app.kubernetes.io/name: postgres
              ports:
              - port: 5432
                targetPort: 5432
                name: postgresql
        providerConfigRef:
          name: default
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      transforms:
      - type: string
        string:
          fmt: "%s-realtime"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-realtime-postgres-service"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"

  # MQTT Deployment
  - name: realtime-mqtt
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: mqtt-broker
              namespace: placeholder-realtime
              labels:
                app.kubernetes.io/name: mqtt-broker
                app.kubernetes.io/component: messaging
            spec:
              replicas: 1
              selector:
                matchLabels:
                  app.kubernetes.io/name: mqtt-broker
              template:
                metadata:
                  labels:
                    app.kubernetes.io/name: mqtt-broker
                    app.kubernetes.io/component: messaging
                spec:
                  containers:
                  - name: mosquitto
                    image: eclipse-mosquitto
                    ports:
                    - containerPort: 1883
                      name: mqtt
                    - containerPort: 9001
                      name: websocket
                    resources:
                      requests:
                        memory: "64Mi"
                        cpu: "50m"
                      limits:
                        memory: "128Mi"
                        cpu: "100m"
                  restartPolicy: Always
        providerConfigRef:
          name: default
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      transforms:
      - type: string
        string:
          fmt: "%s-realtime"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-realtime-mqtt"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"

  # MQTT Service
  - name: realtime-mqtt-service
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Service
            metadata:
              name: mqtt-broker
              namespace: placeholder-realtime
              labels:
                app.kubernetes.io/name: mqtt-broker
                app.kubernetes.io/component: messaging
            spec:
              selector:
                app.kubernetes.io/name: mqtt-broker
              ports:
              - port: 1883
                targetPort: 1883
                name: mqtt
              - port: 9001
                targetPort: 9001
                name: websocket
        providerConfigRef:
          name: default
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      transforms:
      - type: string
        string:
          fmt: "%s-realtime"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-realtime-mqtt-service"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"

  # Kafka Deployment
  - name: realtime-kafka
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: demo-kafka
              namespace: placeholder-realtime
              labels:
                app.kubernetes.io/name: kafka
                app.kubernetes.io/component: streaming
            spec:
              replicas: 1
              selector:
                matchLabels:
                  app.kubernetes.io/name: kafka
              template:
                metadata:
                  labels:
                    app.kubernetes.io/name: kafka
                    app.kubernetes.io/component: streaming
                spec:
                  hostname: demo-kafka
                  containers:
                  - name: kafka
                    image: lensesio/fast-data-dev:3.9.0
                    ports:
                    - containerPort: 9092
                      name: kafka
                    - containerPort: 19092
                      name: docker-compose
                    - containerPort: 8081
                      name: schema-registry
                    - containerPort: 8083
                      name: kafka-connect
                    - containerPort: 16062
                      name: controller
                    env:
                    - name: ADV_HOST
                      value: "demo-kafka"
                    - name: RUNNING_SAMPLEDATA
                      value: "1"
                    - name: RUNTESTS
                      value: "0"
                    - name: KAFKA_LISTENERS
                      value: "PLAINTEXT://:9092,DOCKERCOMPOSE://:19092,CONTROLLER://:16062"
                    - name: KAFKA_ADVERTISED_LISTENERS
                      value: "PLAINTEXT://demo-kafka:9092,DOCKERCOMPOSE://demo-kafka:19092"
                    resources:
                      requests:
                        memory: "1Gi"
                        cpu: "500m"
                      limits:
                        memory: "2Gi" 
                        cpu: "1000m"
                    livenessProbe:
                      httpGet:
                        path: /
                        port: 8081
                      initialDelaySeconds: 60
                      periodSeconds: 30
                    readinessProbe:
                      httpGet:
                        path: /
                        port: 8081
                      initialDelaySeconds: 30
                      periodSeconds: 10
                  restartPolicy: Always
        providerConfigRef:
          name: default
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      transforms:
      - type: string
        string:
          fmt: "%s-realtime"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-realtime-kafka"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"

  # Kafka Service
  - name: realtime-kafka-service
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Service
            metadata:
              name: demo-kafka
              namespace: placeholder-realtime
              labels:
                app.kubernetes.io/name: kafka
                app.kubernetes.io/component: streaming
            spec:
              selector:
                app.kubernetes.io/name: kafka
              ports:
              - port: 9092
                targetPort: 9092
                name: kafka
              - port: 19092
                targetPort: 19092
                name: docker-compose
              - port: 8081
                targetPort: 8081
                name: schema-registry
              - port: 8083
                targetPort: 8083
                name: kafka-connect
              - port: 16062
                targetPort: 16062
                name: controller
        providerConfigRef:
          name: default
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      transforms:
      - type: string
        string:
          fmt: "%s-realtime"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-realtime-kafka-service"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"

  # Lenses HQ Config
  - name: realtime-lenses-hq-config
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: ConfigMap
            metadata:
              name: lenses-hq-config
              namespace: placeholder-realtime
              labels:
                app.kubernetes.io/name: lenses-hq
                app.kubernetes.io/component: stream-processing
            data:
              config.yaml: |
                lenses:
                  license:
                    key: "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJldmFsdWF0aW9uIiwiYXVkIjoibGVuc2VzIiwibmJmIjoxNjk5ODI0MDAwLCJpc3MiOiJsZW5zZXMuaW8iLCJleHAiOjE3MzE0NDY0MDAsImlhdCI6MTY5OTgyNDAwMCwianRpIjoiZXZhbHVhdGlvbiIsImZlYXR1cmVzIjpbImFsbCJdfQ.example"
                    
                  http:
                    port: 9991
                    bind: "0.0.0.0"
                    
                  authentication:
                    default:
                      enabled: true
                      username: admin
                      password: admin
                      
                  database:
                    url: "jdbc:postgresql://postgres:5432/hq"
                    username: "lenses" 
                    password: "lenses"
                    
                  kafka:
                    brokers:
                      - "demo-kafka:9092"
                    schema-registry:
                      url: "http://demo-kafka:8081"
                    connect:
                      - name: "demo-kafka-connect"
                        url: "http://demo-kafka:8083"
                        
                  security:
                    enabled: false
                    
                  monitoring:
                    enabled: true
                    
                  processors:
                    enabled: true
        providerConfigRef:
          name: default
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      transforms:
      - type: string
        string:
          fmt: "%s-realtime"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-realtime-lenses-hq-config"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"

  # Lenses HQ Deployment
  - name: realtime-lenses-hq
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: lenses-hq
              namespace: placeholder-realtime
              labels:
                app.kubernetes.io/name: lenses-hq
                app.kubernetes.io/component: stream-processing
            spec:
              replicas: 1
              selector:
                matchLabels:
                  app.kubernetes.io/name: lenses-hq
              template:
                metadata:
                  labels:
                    app.kubernetes.io/name: lenses-hq
                    app.kubernetes.io/component: stream-processing
                spec:
                  initContainers:
                  - name: wait-for-postgres
                    image: postgres
                    command:
                    - sh
                    - -c
                    - |
                      until pg_isready -h postgres -U lenses; do
                        echo "Waiting for postgres..."
                        sleep 2
                      done
                      echo "PostgreSQL is ready"
                      
                      # Create databases if they don't exist
                      export PGPASSWORD=lenses
                      psql -h postgres -U lenses -tc "SELECT 1 FROM pg_database WHERE datname = 'hq'" | grep -q 1 || \
                        psql -h postgres -U lenses -c "CREATE DATABASE hq;"
                      psql -h postgres -U lenses -tc "SELECT 1 FROM pg_database WHERE datname = 'agent1'" | grep -q 1 || \
                        psql -h postgres -U lenses -c "CREATE DATABASE agent1;"
                      psql -h postgres -U lenses -tc "SELECT 1 FROM pg_database WHERE datname = 'metabaseappdb'" | grep -q 1 || \
                        psql -h postgres -U lenses -c "CREATE DATABASE metabaseappdb;"
                  containers:
                  - name: lenses-hq
                    image: lensting/lenses-hq:6-preview
                    ports:
                    - containerPort: 9991
                      name: http
                    env:
                    - name: ACCEPT_EULA
                      value: "true"
                    volumeMounts:
                    - name: lenses-hq-config
                      mountPath: /opt/lenses/lenses.conf
                      subPath: config.yaml
                    resources:
                      requests:
                        memory: "512Mi"
                        cpu: "250m"
                      limits:
                        memory: "2Gi"
                        cpu: "1000m"
                    livenessProbe:
                      httpGet:
                        path: /api/health
                        port: 9991
                      initialDelaySeconds: 120
                      periodSeconds: 30
                    readinessProbe:
                      httpGet:
                        path: /api/health
                        port: 9991
                      initialDelaySeconds: 60
                      periodSeconds: 10
                  volumes:
                  - name: lenses-hq-config
                    configMap:
                      name: lenses-hq-config
                  restartPolicy: Always
        providerConfigRef:
          name: default
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      transforms:
      - type: string
        string:
          fmt: "%s-realtime"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-realtime-lenses-hq"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"

  # Lenses HQ Service
  - name: realtime-lenses-hq-service
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Service
            metadata:
              name: lenses-hq
              namespace: placeholder-realtime
              labels:
                app.kubernetes.io/name: lenses-hq
                app.kubernetes.io/component: stream-processing
            spec:
              selector:
                app.kubernetes.io/name: lenses-hq
              ports:
              - port: 9991
                targetPort: 9991
                name: http
        providerConfigRef:
          name: default
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      transforms:
      - type: string
        string:
          fmt: "%s-realtime"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-realtime-lenses-hq-service"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"

  # Lenses Agent Deployment
  - name: realtime-lenses-agent
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: lenses-agent
              namespace: placeholder-realtime
              labels:
                app.kubernetes.io/name: lenses-agent
                app.kubernetes.io/component: stream-processing
            spec:
              replicas: 1
              selector:
                matchLabels:
                  app.kubernetes.io/name: lenses-agent
              template:
                metadata:
                  labels:
                    app.kubernetes.io/name: lenses-agent
                    app.kubernetes.io/component: stream-processing
                spec:
                  initContainers:
                  - name: wait-for-lenses-hq
                    image: curlimages/curl:latest
                    command:
                    - sh
                    - -c
                    - |
                      until curl -f http://lenses-hq:9991/api/health; do
                        echo "Waiting for Lenses HQ..."
                        sleep 5
                      done
                      echo "Lenses HQ is ready"
                  containers:
                  - name: lenses-agent
                    image: lensting/lenses-agent:6-preview
                    env:
                    - name: DEMO_HQ_URL
                      value: "http://lenses-hq:9991"
                    - name: DEMO_HQ_USER
                      value: "admin"
                    - name: DEMO_HQ_PASSWORD
                      value: "admin"
                    - name: LENSES_HEAP_OPTS
                      value: "-Xmx1536m -Xms512m"
                    - name: ACCEPT_EULA
                      value: "true"
                    resources:
                      requests:
                        memory: "1Gi"
                        cpu: "250m"
                      limits:
                        memory: "2Gi"
                        cpu: "500m"
                    livenessProbe:
                      exec:
                        command:
                        - sh
                        - -c
                        - "ps aux | grep -v grep | grep java"
                      initialDelaySeconds: 60
                      periodSeconds: 30
                    readinessProbe:
                      exec:
                        command:
                        - sh
                        - -c
                        - "ps aux | grep -v grep | grep java"
                      initialDelaySeconds: 30
                      periodSeconds: 10
                  restartPolicy: Always
        providerConfigRef:
          name: default
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      transforms:
      - type: string
        string:
          fmt: "%s-realtime"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-realtime-lenses-agent"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"

  # Lenses Agent Service
  - name: realtime-lenses-agent-service
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Service
            metadata:
              name: lenses-agent
              namespace: placeholder-realtime
              labels:
                app.kubernetes.io/name: lenses-agent
                app.kubernetes.io/component: stream-processing
            spec:
              selector:
                app.kubernetes.io/name: lenses-agent
              ports:
              - port: 8080
                targetPort: 8080
                name: http
        providerConfigRef:
          name: default
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      transforms:
      - type: string
        string:
          fmt: "%s-realtime"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-realtime-lenses-agent-service"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"

  # Metabase Deployment
  - name: realtime-metabase
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: metabase
              namespace: placeholder-realtime
              labels:
                app.kubernetes.io/name: metabase
                app.kubernetes.io/component: analytics
            spec:
              replicas: 1
              selector:
                matchLabels:
                  app.kubernetes.io/name: metabase
              template:
                metadata:
                  labels:
                    app.kubernetes.io/name: metabase
                    app.kubernetes.io/component: analytics
                spec:
                  initContainers:
                  - name: wait-for-postgres
                    image: postgres
                    command:
                    - sh
                    - -c
                    - |
                      until pg_isready -h postgres -U lenses; do
                        echo "Waiting for postgres..."
                        sleep 2
                      done
                      echo "PostgreSQL is ready"
                  containers:
                  - name: metabase
                    image: metabase/metabase:latest
                    ports:
                    - containerPort: 3000
                      name: http
                    env:
                    - name: MB_DB_TYPE
                      value: "postgres"
                    - name: MB_DB_DBNAME
                      value: "metabaseappdb"
                    - name: MB_DB_PORT
                      value: "5432"
                    - name: MB_DB_USER
                      value: "lenses"
                    - name: MB_DB_PASS
                      value: "lenses"
                    - name: MB_DB_HOST
                      value: "postgres"
                    resources:
                      requests:
                        memory: "512Mi"
                        cpu: "250m"
                      limits:
                        memory: "1Gi"
                        cpu: "500m"
                    livenessProbe:
                      httpGet:
                        path: /api/health
                        port: 3000
                      initialDelaySeconds: 120
                      periodSeconds: 30
                    readinessProbe:
                      httpGet:
                        path: /api/health
                        port: 3000
                      initialDelaySeconds: 60
                      periodSeconds: 10
                  restartPolicy: Always
        providerConfigRef:
          name: default
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      transforms:
      - type: string
        string:
          fmt: "%s-realtime"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-realtime-metabase"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"

  # Metabase Service
  - name: realtime-metabase-service
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Service
            metadata:
              name: metabase
              namespace: placeholder-realtime
              labels:
                app.kubernetes.io/name: metabase
                app.kubernetes.io/component: analytics
            spec:
              selector:
                app.kubernetes.io/name: metabase
              ports:
              - port: 3000
                targetPort: 3000
                name: http
        providerConfigRef:
          name: default
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      transforms:
      - type: string
        string:
          fmt: "%s-realtime"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-realtime-metabase-service"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"

  # Stream Processing Setup Job
  - name: realtime-stream-processing-queries
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: ConfigMap
            metadata:
              name: stream-processing-queries
              namespace: placeholder-realtime
              labels:
                app.kubernetes.io/name: stream-processing
                app.kubernetes.io/component: configuration
            data:
              setup-streams.sql: |
                -- Blood Pressure Stream Processing
                INSERT INTO blood_pressure_device_topic
                STORE KEY AS STRING VALUE AS AVRO
                SELECT STREAM
                    _value.deviceId AS _key,
                    _value.deviceId AS deviceId,
                    _value.systolic AS systolic,
                    _value.diastolic AS diastolic,
                    _value.latitude AS latitude,
                    _value.longitude AS longitude,
                    _value.timestamp AS createdTime
                FROM device_data
                WHERE _value.deviceId IS NOT NULL;

                -- Heart Rate Stream Processing
                INSERT INTO heart_rate_device_topic
                STORE KEY AS STRING VALUE AS AVRO
                SELECT STREAM
                    _value.deviceId AS _key,
                    _value.deviceId AS deviceId,
                    _value.heartRate AS value,
                    _value.latitude AS latitude,
                    _value.longitude AS longitude,
                    _value.timestamp AS createdTime
                FROM device_data
                WHERE _value.deviceId IS NOT NULL;

                -- Health Alert Stream (for critical values)
                INSERT INTO health_alerts_topic
                STORE KEY AS STRING VALUE AS AVRO
                SELECT STREAM
                    _value.deviceId AS _key,
                    _value.deviceId AS deviceId,
                    _value.timestamp AS alertTime,
                    CASE
                      WHEN _value.heartRate > 120 THEN 'HIGH_HEART_RATE'
                      WHEN _value.heartRate < 50 THEN 'LOW_HEART_RATE'
                      WHEN _value.systolic > 140 THEN 'HIGH_BLOOD_PRESSURE'
                      WHEN _value.systolic < 90 THEN 'LOW_BLOOD_PRESSURE'
                      WHEN _value.oxygenSaturation < 95 THEN 'LOW_OXYGEN'
                      WHEN _value.bodyTemperature > 100.4 THEN 'HIGH_FEVER'
                      WHEN _value.bodyTemperature < 96.0 THEN 'LOW_TEMPERATURE'
                      ELSE 'UNKNOWN_ALERT'
                    END AS alertType,
                    _value AS rawData
                FROM device_data
                WHERE _value.heartRate > 120 OR _value.heartRate < 50
                   OR _value.systolic > 140 OR _value.systolic < 90  
                   OR _value.oxygenSaturation < 95
                   OR _value.bodyTemperature > 100.4 OR _value.bodyTemperature < 96.0;
        providerConfigRef:
          name: default
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      transforms:
      - type: string
        string:
          fmt: "%s-realtime"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-realtime-stream-processing-queries"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"

  # Stream Processing Setup Job
  - name: realtime-stream-processing-setup
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: setup-stream-processing
              namespace: placeholder-realtime
              labels:
                app.kubernetes.io/name: stream-processing
                app.kubernetes.io/component: setup
            spec:
              template:
                spec:
                  initContainers:
                  - name: wait-for-lenses-hq
                    image: curlimages/curl:latest
                    command:
                    - sh
                    - -c
                    - |
                      until curl -f http://lenses-hq:9991/api/health; do
                        echo "Waiting for Lenses HQ to be ready..."
                        sleep 10
                      done
                      echo "Lenses HQ is ready"
                      
                      # Wait additional time for Lenses to fully initialize
                      sleep 30
                  containers:
                  - name: setup-processor
                    image: curlimages/curl:latest
                    command:
                    - sh
                    - -c
                    - |
                      echo "Setting up health data stream processing..."
                      
                      # Create Kafka topics for health data streams
                      curl -X POST http://lenses-hq:9991/api/v1/kafka/topics \
                        -H "Content-Type: application/json" \
                        -u admin:admin \
                        -d '{
                          "name": "device_data",
                          "partitions": 3,
                          "replication": 1,
                          "configs": {
                            "cleanup.policy": "delete",
                            "retention.ms": "604800000"
                          }
                        }' || echo "device_data topic might already exist"

                      curl -X POST http://lenses-hq:9991/api/v1/kafka/topics \
                        -H "Content-Type: application/json" \
                        -u admin:admin \
                        -d '{
                          "name": "blood_pressure_device_topic", 
                          "partitions": 3,
                          "replication": 1
                        }' || echo "blood_pressure_device_topic might already exist"

                      curl -X POST http://lenses-hq:9991/api/v1/kafka/topics \
                        -H "Content-Type: application/json" \
                        -u admin:admin \
                        -d '{
                          "name": "heart_rate_device_topic",
                          "partitions": 3, 
                          "replication": 1
                        }' || echo "heart_rate_device_topic might already exist"

                      curl -X POST http://lenses-hq:9991/api/v1/kafka/topics \
                        -H "Content-Type: application/json" \
                        -u admin:admin \
                        -d '{
                          "name": "health_alerts_topic",
                          "partitions": 3,
                          "replication": 1
                        }' || echo "health_alerts_topic might already exist"

                      echo "Health data streaming topics created successfully"
                    volumeMounts:
                    - name: queries
                      mountPath: /queries
                    resources:
                      requests:
                        memory: "64Mi"
                        cpu: "50m"
                      limits:
                        memory: "128Mi"
                        cpu: "100m"
                  volumes:
                  - name: queries
                    configMap:
                      name: stream-processing-queries
                  restartPolicy: OnFailure
        providerConfigRef:
          name: default
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
      transforms:
      - type: string
        string:
          fmt: "%s-realtime"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-realtime-stream-processing-setup"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"

  # Realtime Platform Secrets
  - name: realtime-mqtt-secret
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Secret
            metadata:
              name: placeholder
              namespace: placeholder
            stringData:
              MQTT_HOST: "placeholder"
              MQTT_PORT: "1883"
              MQTT_USER: "realtime-user"
              MQTT_PASSWORD: "realtime-pass"
              MQTT_WEBSOCKET_PORT: "9001"
              MQTT_TOPIC_PREFIX: "health"
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-mqtt-secret"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-mqtt-secret"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"
    # Configure MQTT host
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.stringData.MQTT_HOST
      transforms:
      - type: string
        string:
          fmt: "%s-mqtt.%s.svc.cluster.local"
          type: Format

  - name: realtime-kafka-secret
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Secret
            metadata:
              name: placeholder
              namespace: placeholder
            stringData:
              KAFKA_BOOTSTRAP_SERVERS: "placeholder"
              KAFKA_SCHEMA_REGISTRY_URL: "placeholder"
              KAFKA_CONNECT_URL: "placeholder"
              KAFKA_TOPICS: "device_data,blood_pressure_device_topic,heart_rate_device_topic"
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-kafka-secret"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-kafka-secret"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"
    # Configure Kafka endpoints
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.stringData.KAFKA_BOOTSTRAP_SERVERS
      transforms:
      - type: string
        string:
          fmt: "%s-kafka.%s.svc.cluster.local:9092"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.stringData.KAFKA_SCHEMA_REGISTRY_URL
      transforms:
      - type: string
        string:
          fmt: "http://%s-kafka.%s.svc.cluster.local:8081"
          type: Format

  - name: realtime-lenses-secret
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Secret
            metadata:
              name: placeholder
              namespace: placeholder
            stringData:
              LENSES_URL: "placeholder"
              LENSES_USER: "admin"
              LENSES_PASSWORD: "admin"
              LENSES_HQ_URL: "placeholder"
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-lenses-secret"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-lenses-secret"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"
    # Configure Lenses endpoints
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.stringData.LENSES_URL
      transforms:
      - type: string
        string:
          fmt: "http://%s-lenses-hq.%s.svc.cluster.local:9991"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.stringData.LENSES_HQ_URL
      transforms:
      - type: string
        string:
          fmt: "http://%s-lenses-hq.%s.svc.cluster.local:9991"
          type: Format

  - name: realtime-metabase-secret
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Secret
            metadata:
              name: placeholder
              namespace: placeholder
            stringData:
              METABASE_URL: "placeholder"
              METABASE_USER: "admin@example.com"
              METABASE_PASSWORD: "metabase123"
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-metabase-secret"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-metabase-secret"
    # Only create if realtime parameter is specified
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "": "false"
          "*": "true"
    # Configure Metabase endpoint
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.stringData.METABASE_URL
      transforms:
      - type: string
        string:
          fmt: "http://%s-metabase.%s.svc.cluster.local:3000"

  # Update OAM Application with new webservice component
  - name: update-oam-application
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: default
            spec:
              template:
                spec:
                  serviceAccountName: crossplane-github-provider
                  restartPolicy: OnFailure
                  containers:
                  - name: oam-updater
                    image: alpine/git:latest
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      echo "Updating OAM Application with webservice component for $SERVICE_NAME..."
                      
                      TEMP_DIR="/tmp/oam-update-$APP_CONTAINER"
                      mkdir -p $TEMP_DIR
                      cd $TEMP_DIR
                      
                      # Clone the GitOps repository
                      git clone https://$GITHUB_TOKEN@github.com/$GITHUB_USER/$APP_CONTAINER-gitops.git .
                      
                      # Configure git
                      git config user.name "ApplicationClaim OAM Updater"
                      git config user.email "applicationclaim@platform.local"
                      
                      # Check if OAM application file exists
                      if [ ! -f "oam/applications/application.yaml" ]; then
                        echo " OAM application file not found"
                        exit 1
                      fi
                      
                      echo " Current OAM Application:"
                      cat oam/applications/application.yaml
                      
                      # Create new component definition
                      COMPONENT_YAML="
                        - name: $SERVICE_NAME
                          type: webservice
                          properties:
                            name: $SERVICE_NAME
                            language: $LANGUAGE
                            framework: $FRAMEWORK"
                      
                      # Add database if specified
                      if [ "$DATABASE" != "none" ] && [ -n "$DATABASE" ]; then
                        COMPONENT_YAML="${COMPONENT_YAML}
                            database: $DATABASE"
                      fi
                      
                      # Add cache if specified
                      if [ "$CACHE" != "none" ] && [ -n "$CACHE" ]; then
                        COMPONENT_YAML="${COMPONENT_YAML}
                            cache: $CACHE"
                      fi
                      
                      # Add AppContainer reference
                      COMPONENT_YAML="${COMPONENT_YAML}
                            appContainer: $APP_CONTAINER
                            exposeApi: true"
                      
                      # Check if components array is empty
                      if grep -q "components: \[\]" oam/applications/application.yaml; then
                        echo " Adding first component to empty OAM Application..."
                        
                        # Replace empty components array with the new component
                        sed -i "s/components: \[\]/components:$COMPONENT_YAML/" oam/applications/application.yaml
                        
                      elif grep -q "components:" oam/applications/application.yaml; then
                        echo " Adding component to existing OAM Application..."
                        
                        # Find the line number of components: and add the new component
                        COMPONENTS_LINE=$(grep -n "components:" oam/applications/application.yaml | cut -d: -f1)
                        
                        # Create temp file with the new component added
                        head -n $COMPONENTS_LINE oam/applications/application.yaml > temp_app.yaml
                        echo "$COMPONENT_YAML" | sed 's/^/        /' >> temp_app.yaml
                        tail -n +$((COMPONENTS_LINE + 1)) oam/applications/application.yaml >> temp_app.yaml
                        
                        mv temp_app.yaml oam/applications/application.yaml
                        
                      else
                        echo " No components section found in OAM Application"
                        exit 1
                      fi
                      
                      echo " Updated OAM Application:"
                      cat oam/applications/application.yaml
                      
                      # Commit and push changes
                      git add oam/applications/application.yaml
                      git commit -m "Add $SERVICE_NAME webservice component to OAM Application

- Language: $LANGUAGE
- Framework: $FRAMEWORK
- Database: $DATABASE
- Cache: $CACHE
- AppContainer: $APP_CONTAINER

Generated by ApplicationClaim composition"
                      
                      git push
                      
                      echo " Successfully updated OAM Application with $SERVICE_NAME webservice component"
                    env:
                    - name: SERVICE_NAME
                      value: "placeholder"
                    - name: APP_CONTAINER
                      value: "placeholder"
                    - name: LANGUAGE
                      value: "placeholder"
                    - name: FRAMEWORK
                      value: "placeholder"
                    - name: DATABASE
                      value: "placeholder"
                    - name: CACHE
                      value: "placeholder"
                    - name: GITHUB_TOKEN
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: token
                    - name: GITHUB_USER
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: user
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-oam-updater"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-oam-updater"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.language
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.framework
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[3].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.database
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[4].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.cache
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[5].value
          type: Format