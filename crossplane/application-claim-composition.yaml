apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: application-claim-composition
  labels:
    crossplane.io/xrd: xapplicationclaims.platform.example.org
    provider: github-kubernetes-helm
spec:
  writeConnectionSecretsToNamespace: crossplane-system
  compositeTypeRef:
    apiVersion: platform.example.org/v1alpha1
    kind: XApplicationClaim
  resources:
  
  # Add microservice to existing AppContainer source repository
  - name: add-microservice-to-container
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: default
            spec:
              template:
                metadata:
                  annotations:
                    sidecar.istio.io/inject: "false"
                spec:
                  serviceAccountName: crossplane-github-provider
                  restartPolicy: OnFailure
                  containers:
                  - name: microservice-creator
                    image: alpine:3.18
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      # Install git, curl, and jq
                      apk add --no-cache git curl jq
                      echo "Adding microservice $SERVICE_NAME to AppContainer $APP_CONTAINER..."
                      
                      TEMP_DIR="/tmp/app-container-$APP_CONTAINER"
                      mkdir -p $TEMP_DIR
                      cd $TEMP_DIR
                      
                      # Clone the AppContainer repository using GitHub token
                      git clone https://$GITHUB_TOKEN@github.com/$GITHUB_USER/$APP_CONTAINER.git .
                      
                      # Determine template repository based on service type
                      if [ "$LANGUAGE" = "python" ] && [ "$FRAMEWORK" = "fastapi" ]; then
                        TEMPLATE_REPO="onion-architecture-template"
                        echo "ðŸ—ï¸ Using onion architecture template for Python/FastAPI service"
                      elif [ "$LANGUAGE" = "rasa" ] && [ "$FRAMEWORK" = "chatbot" ]; then
                        TEMPLATE_REPO="chat-template"
                        echo "ðŸ¤– Using chat template for RASA chatbot service"
                      elif [ "$LANGUAGE" = "nodejs" ] && [ "$FRAMEWORK" = "graphql-gateway" ]; then
                        TEMPLATE_REPO="graphql-federation-gateway-template"
                        echo "ðŸŒ Using GraphQL federation gateway template for Node.js/GraphQL service"
                      else
                        echo "âŒ Unsupported service type: $LANGUAGE/$FRAMEWORK"
                        exit 1
                      fi
                      
                      # Clone template repository
                      TEMPLATE_DIR="/tmp/template-$SERVICE_NAME"
                      mkdir -p $TEMPLATE_DIR
                      git clone https://$GITHUB_TOKEN@github.com/$GITHUB_USER/$TEMPLATE_REPO.git $TEMPLATE_DIR
                      
                      # Create microservice directory and copy template
                      mkdir -p microservices/$SERVICE_NAME
                      
                      if [ "$LANGUAGE" = "python" ] && [ "$FRAMEWORK" = "fastapi" ]; then
                        # Copy onion architecture template
                        cp -r $TEMPLATE_DIR/* microservices/$SERVICE_NAME/
                        cd microservices/$SERVICE_NAME
                        
                        # Customize template for the specific service
                        sed -i "s/template-service/$SERVICE_NAME/g" pyproject.toml README.md
                        sed -i "s/Template Service/$SERVICE_NAME Service/g" README.md
                        
                        # Update any hardcoded references
                        find . -name "*.py" -exec sed -i "s/template_service/$SERVICE_NAME/g" {} \;
                        find . -name "*.md" -exec sed -i "s/template-service/$SERVICE_NAME/g" {} \;
                        
                        echo "âœ… Successfully created onion architecture microservice from template"
                      elif [ "$LANGUAGE" = "rasa" ] && [ "$FRAMEWORK" = "chatbot" ]; then
                        # Copy chat template structure 
                        cp -r $TEMPLATE_DIR/microservices/chat-template/* microservices/$SERVICE_NAME/
                        cd microservices/$SERVICE_NAME
                        
                        # Customize template for the specific service
                        sed -i "s/chat-template/$SERVICE_NAME/g" README.md docker-compose.yml
                        sed -i "s/Development Bot/$SERVICE_NAME Bot/g" docker-compose.yml
                        sed -i "s/Customer Support Bot/$SERVICE_NAME Support Bot/g" domain.yml
                        
                        # Update OAM files
                        find oam/ -name "*.yaml" -exec sed -i "s/chat-template/$SERVICE_NAME/g" {} \;
                        
                        echo "âœ… Successfully created RASA chatbot microservice from template"
                      elif [ "$LANGUAGE" = "nodejs" ] && [ "$FRAMEWORK" = "graphql-gateway" ]; then
                        # Copy GraphQL gateway template structure
                        cp -r $TEMPLATE_DIR/microservices/graphql-gateway/* microservices/$SERVICE_NAME/
                        cd microservices/$SERVICE_NAME
                        
                        # Debug: Show what was actually copied
                        echo "ðŸ“‹ Files copied from template:"
                        ls -la
                        echo "ðŸ“‹ Template package.json content:"
                        [ -f "package.json" ] && head -20 package.json || echo "âŒ package.json not found"
                        
                        # Customize template for the specific service (handle missing files gracefully)
                        [ -f "package.json" ] && sed -i "s/graphql-gateway/$SERVICE_NAME/g" package.json
                        [ -f "README.md" ] && sed -i "s/graphql-gateway/$SERVICE_NAME/g" README.md && sed -i "s/GraphQL Gateway/$SERVICE_NAME Gateway/g" README.md
                        [ -f "docker-compose.yml" ] && sed -i "s/graphql-gateway/$SERVICE_NAME/g" docker-compose.yml
                        [ -f "package.json" ] && sed -i "s/Federation Gateway/$SERVICE_NAME Federation Gateway/g" package.json
                        
                        # Ensure we have the latest GraphQL Mesh dependencies
                        if [ -f "package.json" ]; then
                          echo "ðŸ“¦ Verifying GraphQL Mesh dependencies..."
                          if ! grep -q "@graphql-mesh/runtime" package.json; then
                            echo "âš ï¸  Missing GraphQL Mesh dependencies - force updating from latest template"
                            # Re-copy package.json and package-lock.json from template to ensure latest dependencies
                            cp $TEMPLATE_DIR/microservices/graphql-gateway/package.json .
                            cp $TEMPLATE_DIR/microservices/graphql-gateway/package-lock.json .
                            # Re-apply service name customization
                            sed -i "s/graphql-gateway/$SERVICE_NAME/g" package.json
                            sed -i "s/Federation Gateway/$SERVICE_NAME Federation Gateway/g" package.json
                            echo "âœ… Updated package.json with latest GraphQL Mesh dependencies"
                          else
                            echo "âœ… GraphQL Mesh dependencies already present"
                          fi
                        fi
                        
                        # Update Kubernetes manifests
                        find . -name "*.yaml" -exec sed -i "s/graphql-gateway/$SERVICE_NAME/g" {} \;
                        find . -name "*.yaml" -exec sed -i "s/APP_CONTAINER_PLACEHOLDER/$APP_CONTAINER/g" {} \;
                        
                        echo "âœ… Successfully created GraphQL federation gateway microservice from template"
                      fi
                      
                      # Create service README
                      cat > README.md << EOF
                      # $SERVICE_NAME
                      
                      CLAUDE.md-compliant microservice with Onion Architecture and 12-Factor principles.
                      
                      ## Architecture
                      
                      This microservice follows the Onion Architecture pattern:
                      
                      - **Domain Layer**: Business rules (`src/domain/`)
                      - **Application Layer**: Use cases (`src/application/`)
                      - **Interface Layer**: REST/API endpoints (`src/interface/`)
                      - **Infrastructure Layer**: Database, external services (`src/infrastructure/`)
                      
                      ## Development
                      
                      ### Prerequisites
                      - Python 3.11+
                      - Poetry
                      
                      ### Setup
                      ```bash
                      poetry install
                      poetry run pytest  # Run TDD tests
                      poetry run python src/main.py  # Run locally
                      ```
                      
                      ### Testing (TDD)
                      ```bash
                      poetry run pytest -v
                      ```
                      
                      ### Linting
                      ```bash
                      poetry run black src/
                      poetry run isort src/
                      poetry run mypy src/
                      ```
                      
                      ## Deployment
                      
                      This service is automatically deployed via the AppContainer CI/CD pipeline when changes are pushed to the main branch.
                      EOF
                      
                      # Update microservices README
                      cd ../../
                      if grep -q "- (Services will be listed here as they are added)" microservices/README.md; then
                        sed -i "s/- (Services will be listed here as they are added)/- $SERVICE_NAME ($LANGUAGE\/$FRAMEWORK)/" microservices/README.md
                      else
                        echo "- $SERVICE_NAME ($LANGUAGE/$FRAMEWORK)" >> microservices/README.md
                      fi
                      
                      # Commit and push
                      git config user.name "ApplicationClaim"
                      git config user.email "applicationclaim@platform.local"
                      git add .
                      git commit -m "Add $SERVICE_NAME microservice ($LANGUAGE/$FRAMEWORK)
                      
                      - Implements CLAUDE.md Onion Architecture
                      - Follows 12-Factor App principles
                      - Includes TDD test structure with pytest
                      - Dependency injection ready
                      - FastAPI with health checks
                      - Multi-stage Dockerfile
                      - Poetry for dependency management"
                      git push
                      
                      echo "Microservice $SERVICE_NAME added to AppContainer $APP_CONTAINER successfully"
                    env:
                    - name: APP_CONTAINER
                      value: placeholder
                    - name: SERVICE_NAME
                      value: placeholder
                    - name: LANGUAGE
                      value: placeholder
                    - name: FRAMEWORK
                      value: placeholder
                    - name: GITHUB_TOKEN
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: token
                    - name: GITHUB_USER
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: user
                    - name: DOCKER_REGISTRY
                      valueFrom:
                        secretKeyRef:
                          name: docker-credentials
                          key: registry
                    - name: DOCKER_USER
                      valueFrom:
                        secretKeyRef:
                          name: docker-credentials
                          key: username
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-microservice-creator"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.language
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.framework
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[3].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-microservice-creator"

  # Add CI/CD workflows to AppContainer repository (unified repository pattern)
  - name: add-gitops-manifests
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: default
            spec:
              template:
                metadata:
                  annotations:
                    sidecar.istio.io/inject: "false"
                spec:
                  serviceAccountName: crossplane-github-provider
                  restartPolicy: OnFailure
                  containers:
                  - name: gitops-manifest-creator
                    image: alpine:3.18
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      # Install git, curl, and jq
                      apk add --no-cache git curl jq
                      echo "Adding GitOps manifests for $SERVICE_NAME in $APP_CONTAINER-gitops..."
                      
                      TEMP_DIR="/tmp/gitops-$APP_CONTAINER"
                      mkdir -p $TEMP_DIR
                      cd $TEMP_DIR
                      
                      # Clone the AppContainer GitOps repository
                      git clone https://$GITHUB_TOKEN@github.com/$GITHUB_USER/$APP_CONTAINER-gitops.git .
                      
                      # Create manifests directory for the service
                      mkdir -p manifests/$SERVICE_NAME
                      cd manifests/$SERVICE_NAME
                      
                      # Create ConfigMap for environment variables
                      cat > configmap.yaml << EOF
                      apiVersion: v1
                      kind: ConfigMap
                      metadata:
                        name: $SERVICE_NAME-config
                        namespace: default
                      data:
                        APP_ENV: "production"
                        SERVICE_NAME: "$SERVICE_NAME"
                      EOF
                      
                      # Add database config if needed
                      if [ "$DATABASE" = "postgres" ]; then
                        cat >> configmap.yaml << EOF
                        DATABASE_URL: "postgresql://\$DATABASE_USER:\$DATABASE_PASSWORD@$APP_CONTAINER-postgres-rw.$APP_CONTAINER.svc.cluster.local:5432/$SERVICE_NAME"
                      EOF
                      fi
                      
                      # Add cache config if needed  
                      if [ "$CACHE" = "redis" ]; then
                        cat >> configmap.yaml << EOF
                        REDIS_URL: "redis://:\$REDIS_PASSWORD@$APP_CONTAINER-redis-master.$APP_CONTAINER.svc.cluster.local:6379/0"
                      EOF
                      fi
                      
                      
                      # Commit and push GitOps manifests
                      cd ../..
                      git config user.name "ApplicationClaim GitOps"
                      git config user.email "applicationclaim-gitops@platform.local"
                      git add manifests/$SERVICE_NAME/
                      
                      # Only commit if there are changes
                      if ! git diff --cached --quiet; then
                        git commit -m "Add GitOps manifests for $SERVICE_NAME microservice
                      
                      - Add ConfigMap for environment variables
                      - Ready for ArgoCD deployment  
                      - Service: $SERVICE_NAME in AppContainer: $APP_CONTAINER"
                        git push
                        echo "âœ… GitOps manifests added for $SERVICE_NAME"
                      else
                        echo "âœ… GitOps manifests already exist for $SERVICE_NAME"
                      fi
                    env:
                    - name: APP_CONTAINER
                      value: placeholder
                    - name: SERVICE_NAME
                      value: placeholder
                    - name: DATABASE
                      value: placeholder
                    - name: CACHE
                      value: placeholder
                    - name: GITHUB_TOKEN
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: token
                    - name: GITHUB_USER
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: user
                    - name: DOCKER_REGISTRY
                      valueFrom:
                        secretKeyRef:
                          name: docker-credentials
                          key: registry
                    - name: DOCKER_USER
                      valueFrom:
                        secretKeyRef:
                          name: docker-credentials
                          key: username
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-gitops-creator"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.database
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.cache
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[3].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-gitops-creator"

  # NOTE: PostgreSQL and Redis are now managed by OAM ComponentDefinitions in the vCluster
  # The infrastructure resources below are removed as per ADR-035
  
  # Register vCluster with ArgoCD for OAM deployment
  - name: register-vcluster-argocd
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: default
            spec:
              template:
                metadata:
                  annotations:
                    sidecar.istio.io/inject: "false"
                spec:
                  serviceAccountName: crossplane-admin
                  restartPolicy: OnFailure
                  containers:
                  - name: register-argocd
                    image: alpine/k8s:1.28.4
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      echo "ðŸ”— Registering vCluster with ArgoCD for OAM deployment..."
                      
                      # Skip if deploying to host cluster
                      if [ "${VCLUSTER_NAME}" = "host" ] || [ -z "${VCLUSTER_NAME}" ]; then
                        echo "ðŸ  Deploying to host cluster - skipping vCluster registration"
                        exit 0
                      fi
                      
                      # Install required tools
                      apk add --no-cache curl jq
                      
                      # Install ArgoCD CLI
                      echo "ðŸ“¦ Installing ArgoCD CLI..."
                      curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
                      chmod +x /usr/local/bin/argocd
                      
                      # Install vcluster CLI
                      echo "ðŸ“¦ Installing vCluster CLI..."
                      curl -L -o /usr/local/bin/vcluster https://github.com/loft-sh/vcluster/releases/latest/download/vcluster-linux-amd64
                      chmod +x /usr/local/bin/vcluster
                      
                      # Wait for vCluster to be ready
                      echo "â³ Waiting for vCluster to be ready..."
                      for i in $(seq 1 60); do
                        if kubectl get secret -n ${VCLUSTER_NAMESPACE} | grep -q "vc-${VCLUSTER_NAME}"; then
                          echo "âœ… vCluster secret found"
                          break
                        fi
                        echo "Waiting for vCluster secret... ($i/60)"
                        sleep 5
                      done
                      
                      # Get vCluster kubeconfig using vcluster CLI
                      echo "ðŸ“¥ Getting vCluster kubeconfig..."
                      vcluster connect ${VCLUSTER_NAME} -n ${VCLUSTER_NAMESPACE} --print > /tmp/vcluster.kubeconfig || {
                        # Fallback to manual extraction
                        kubectl get secret vc-${VCLUSTER_NAME} -n ${VCLUSTER_NAMESPACE} \
                          -o jsonpath='{.data.config}' | base64 -d > /tmp/vcluster.kubeconfig
                      }
                      
                      # ArgoCD Configuration
                      ARGOCD_INGRESS_URL="${ARGOCD_INGRESS_URL:-af433f091b55640038c23af3a641d716-112208284.us-west-2.elb.amazonaws.com}"
                      ARGOCD_PASSWORD=$(kubectl get secret argocd-initial-admin-secret -n argocd -o jsonpath="{.data.password}" | base64 -d)
                      
                      # Login to ArgoCD
                      echo "ðŸ” Logging into ArgoCD..."
                      argocd login ${ARGOCD_INGRESS_URL}:80 \
                        --grpc-web-root-path /argocd \
                        --username admin \
                        --password ${ARGOCD_PASSWORD} \
                        --insecure \
                        --plaintext || {
                          echo "âš ï¸ Failed to login to ArgoCD, continuing anyway"
                        }
                      
                      # Register vCluster with ArgoCD using CLI
                      echo "ðŸ“ Registering vCluster with ArgoCD..."
                      
                      # Check if already registered
                      if argocd cluster list | grep -q "${VCLUSTER_NAME}"; then
                        echo "Cluster already registered, removing old registration"
                        argocd cluster rm ${VCLUSTER_NAME} -y 2>/dev/null || true
                      fi
                      
                      # Add the cluster
                      CONTEXT_NAME=$(kubectl config get-contexts --kubeconfig=/tmp/vcluster.kubeconfig -o name | head -1)
                      argocd cluster add ${CONTEXT_NAME} \
                        --kubeconfig /tmp/vcluster.kubeconfig \
                        --name ${VCLUSTER_NAME} \
                        --yes || {
                          echo "âš ï¸ Failed to add vCluster to ArgoCD"
                          # Continue anyway as this might be a transient issue
                        }
                      
                      echo "âœ… vCluster registered with ArgoCD successfully"
                    env:
                    - name: VCLUSTER_NAME
                      value: placeholder
                    - name: VCLUSTER_NAMESPACE
                      value: placeholder
                    - name: APP_NAME
                      value: placeholder
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-register-argocd"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-register-argocd"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.targetVCluster
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
      policy:
        fromFieldPath: Optional
    - type: FromCompositeFieldPath
      fromFieldPath: spec.targetVCluster
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
      policy:
        fromFieldPath: Optional
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].value
  
  # Update OAM Application with new webservice component
  - name: update-oam-application
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: default
            spec:
              template:
                metadata:
                  annotations:
                    sidecar.istio.io/inject: "false"
                spec:
                  serviceAccountName: crossplane-github-provider
                  restartPolicy: OnFailure
                  containers:
                  - name: oam-updater
                    image: alpine:3.18
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      # Install git, curl, jq, and kubectl
                      apk add --no-cache git curl jq
                      curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
                      chmod +x kubectl
                      mv kubectl /usr/local/bin/
                      echo "Updating OAM Application with webservice component for $SERVICE_NAME..."
                      
                      TEMP_DIR="/tmp/oam-update-$APP_CONTAINER"
                      mkdir -p $TEMP_DIR
                      cd $TEMP_DIR
                      
                      # Clone the GitOps repository
                      git clone https://$GITHUB_TOKEN@github.com/$GITHUB_USER/$APP_CONTAINER-gitops.git .
                      
                      # Configure git
                      git config user.name "ApplicationClaim OAM Updater"
                      git config user.email "applicationclaim@platform.local"
                      
                      # Determine target vCluster from ApplicationClaim spec or annotation
                      echo "ðŸ” Looking up ApplicationClaim: $SERVICE_NAME in namespace: default"
                      kubectl get applicationclaim $SERVICE_NAME -n default -o yaml | head -20
                      
                      VCLUSTER_TARGET=$(kubectl get applicationclaim $SERVICE_NAME -n default -o jsonpath='{.spec.targetVCluster}' 2>/dev/null || echo "")
                      echo "   spec.targetVCluster value: '$VCLUSTER_TARGET'"
                      
                      if [ -z "$VCLUSTER_TARGET" ]; then
                        echo "   spec.targetVCluster is empty, checking annotation..."
                        VCLUSTER_TARGET=$(kubectl get applicationclaim $SERVICE_NAME -n default -o jsonpath='{.metadata.annotations.webservice\.oam\.dev/vcluster}' 2>/dev/null || echo "")
                        echo "   annotation value: '$VCLUSTER_TARGET'"
                      fi
                      
                      if [ -z "$VCLUSTER_TARGET" ]; then
                        echo "   No vCluster target found, using default..."
                        VCLUSTER_TARGET="development-vcluster"
                      fi
                      echo "ðŸŽ¯ Target vCluster: $VCLUSTER_TARGET"
                      
                      # Create vCluster-specific directory structure
                      mkdir -p vcluster/$VCLUSTER_TARGET/applications/$SERVICE_NAME
                      
                      # Check if this is an OAM-driven ApplicationClaim (should NOT update OAM to avoid circular dependency)
                      # Default to api-driven if not explicitly set
                      SOURCE="${BOOTSTRAP_SOURCE:-api-driven}"
                      
                      if [ "$SOURCE" == "OAM-driven" ]; then
                        echo "ðŸ”„ OAM-driven ApplicationClaim detected (source: $SOURCE)"
                        echo "âš ï¸  Skipping OAM update to avoid circular dependency"
                        echo "â„¹ï¸  User should manually update OAM Application if needed"
                        exit 0
                      fi
                      
                      echo "âœ… Processing ApplicationClaim (source: $SOURCE)"
                      
                      echo "ðŸ”„ API-driven ApplicationClaim detected - proceeding with OAM update"
                      
                      # Check if OAM application file exists
                      if [ ! -f "oam/applications/application.yaml" ]; then
                        echo "âŒ OAM application file not found"
                        exit 1
                      fi
                      
                      echo "ðŸ“‹ Current OAM Application:"
                      cat oam/applications/application.yaml
                      
                      # Check if component already exists in OAM Application
                      COMPONENT_EXISTS=false
                      if grep -q "name: $SERVICE_NAME" oam/applications/application.yaml; then
                        echo "âš ï¸  Component '$SERVICE_NAME' already exists in OAM Application"
                        echo "ðŸ”„ Component will be replaced with ApplicationClaim specifications..."
                        COMPONENT_EXISTS=true
                      else
                        echo "âœ… Component '$SERVICE_NAME' not found - proceeding with addition"
                      fi
                      
                      # Create new component definition - choose correct ComponentDefinition based on framework
                      if [ "$FRAMEWORK" = "chatbot" ]; then
                        COMPONENT_TYPE="rasa-chatbot"
                        COMPONENT_PORT="5005"
                      else
                        COMPONENT_TYPE="webservice"
                        COMPONENT_PORT="8080"
                      fi
                      
                      # Determine registry based on configuration
                      # Check if we should use ACR or Docker Hub
                      DEFAULT_REGISTRY="${DEFAULT_REGISTRY:-acr}"  # Default to ACR
                      
                      if [ "$DEFAULT_REGISTRY" = "acr" ]; then
                        IMAGE_REGISTRY="healthidpuaeacr.azurecr.io"
                        IMAGE_PREFIX=""
                      else
                        IMAGE_REGISTRY="docker.io"
                        IMAGE_PREFIX="socrates12345/"
                      fi
                      
                      COMPONENT_YAML="
                        - name: $SERVICE_NAME
                          type: $COMPONENT_TYPE
                          properties:
                            name: $SERVICE_NAME
                            image: ${IMAGE_REGISTRY}/${IMAGE_PREFIX}$SERVICE_NAME:latest
                            language: $LANGUAGE
                            framework: $FRAMEWORK
                            port: $COMPONENT_PORT
                            healthPath: /health"
                      
                      # Add realtime platform integration if specified
                      if [ -n "$REALTIME_PLATFORM" ] && [ "$REALTIME_PLATFORM" != "none" ]; then
                        COMPONENT_YAML="${COMPONENT_YAML}
                            realtime: $REALTIME_PLATFORM
                            websocket: true"
                      fi
                      
                      # Add database if specified
                      if [ "$DATABASE" != "none" ] && [ -n "$DATABASE" ]; then
                        COMPONENT_YAML="${COMPONENT_YAML}
                            database: $DATABASE"
                      fi
                      
                      # Add cache if specified
                      if [ "$CACHE" != "none" ] && [ -n "$CACHE" ]; then
                        COMPONENT_YAML="${COMPONENT_YAML}
                            cache: $CACHE"
                      fi
                      
                      # Add AppContainer reference
                      COMPONENT_YAML="${COMPONENT_YAML}
                            appContainer: $APP_CONTAINER
                            exposeApi: true"
                      
                      # If component exists, we'll replace it entirely
                      if [ "$COMPONENT_EXISTS" = "true" ]; then
                        echo "ðŸ”„ Replacing existing component..."
                        
                        # Create a new OAM application with just our component (simpler approach)
                        # Keep everything before components section
                        sed -n '1,/components:/p' oam/applications/application.yaml > temp_app.yaml
                        
                        # Add our component
                        echo "$COMPONENT_YAML" | sed 's/^/        /' >> temp_app.yaml
                        
                        # Keep everything after policies (if exists) or add policies section
                        if grep -q "policies:" oam/applications/application.yaml; then
                          sed -n '/policies:/,$p' oam/applications/application.yaml >> temp_app.yaml
                        fi
                        
                        mv temp_app.yaml oam/applications/application.yaml
                        
                      elif grep -q "components: \[\]" oam/applications/application.yaml; then
                        echo "ðŸ”„ Adding first component to empty OAM Application..."
                        
                        # Replace empty components array with the new component
                        sed -i "s/components: \[\]/components:$COMPONENT_YAML/" oam/applications/application.yaml
                        
                      elif grep -q "components:" oam/applications/application.yaml; then
                        echo "ðŸ”„ Adding component to existing OAM Application..."
                        
                        # Find the line number of components: and add the new component
                        COMPONENTS_LINE=$(grep -n "components:" oam/applications/application.yaml | cut -d: -f1)
                        
                        # Create temp file with the new component added
                        head -n $COMPONENTS_LINE oam/applications/application.yaml > temp_app.yaml
                        echo "$COMPONENT_YAML" | sed 's/^/        /' >> temp_app.yaml
                        tail -n +$((COMPONENTS_LINE + 1)) oam/applications/application.yaml >> temp_app.yaml
                        
                        mv temp_app.yaml oam/applications/application.yaml
                        
                      else
                        echo "âŒ No components section found in OAM Application"
                        exit 1
                      fi
                      
                      # Add or update topology policy for multi-cluster deployment
                      # Check if targetVCluster is "host" - if so, skip topology policy
                      if [ "$VCLUSTER_TARGET" = "host" ]; then
                        echo "ðŸ  Deploying to host cluster - skipping topology policy"
                        # Remove any existing topology policy if present
                        if grep -q "deploy-to-vcluster" oam/applications/application.yaml; then
                          echo "Removing existing topology policy for host deployment..."
                          # Remove the policy section
                          sed -i '/- name: deploy-to-vcluster/,+4d' oam/applications/application.yaml
                          # If policies section is now empty, remove it too
                          if grep -q "policies: \[\]" oam/applications/application.yaml; then
                            sed -i '/policies: \[\]/d' oam/applications/application.yaml
                          fi
                        fi
                      else
                        echo "ðŸŽ¯ Adding topology policy for vCluster deployment..."
                        if ! grep -q "policies:" oam/applications/application.yaml; then
                          echo "  policies:" >> oam/applications/application.yaml
                          echo "  - name: deploy-to-vcluster" >> oam/applications/application.yaml
                          echo "    type: topology" >> oam/applications/application.yaml
                          echo "    properties:" >> oam/applications/application.yaml
                          echo "      clusters: [\"$VCLUSTER_TARGET\"]" >> oam/applications/application.yaml
                          echo "      namespace: \"default\"" >> oam/applications/application.yaml
                        else
                          # Update existing policy
                          if grep -q "deploy-to-vcluster" oam/applications/application.yaml; then
                            echo "ðŸ”„ Updating existing topology policy..."
                            # Update the clusters line
                            sed -i "s/clusters: \[.*\]/clusters: [\"$VCLUSTER_TARGET\"]/" oam/applications/application.yaml
                            sed -i "s/namespace: \".*\"/namespace: \"default\"/" oam/applications/application.yaml
                          else
                            # Add new policy to existing policies section
                            echo "  - name: deploy-to-vcluster" >> oam/applications/application.yaml
                            echo "    type: topology" >> oam/applications/application.yaml
                            echo "    properties:" >> oam/applications/application.yaml
                            echo "      clusters: [\"$VCLUSTER_TARGET\"]" >> oam/applications/application.yaml
                            echo "      namespace: \"default\"" >> oam/applications/application.yaml
                          fi
                        fi
                      fi
                      
                      echo "âœ… Updated OAM Application with topology policy:"
                      cat oam/applications/application.yaml
                      
                      # Create vCluster-specific manifests
                      echo "ðŸ“ Creating vCluster-specific manifests for $VCLUSTER_TARGET..."
                      
                      # Create ApplicationClaim for vCluster processing
                      cat > vcluster/$VCLUSTER_TARGET/applications/$SERVICE_NAME/application-claim.yaml << EOF
                      apiVersion: platform.example.org/v1alpha1
                      kind: ApplicationClaim
                      metadata:
                        name: $SERVICE_NAME
                        namespace: default
                        annotations:
                          webservice.oam.dev/source: "$BOOTSTRAP_SOURCE"
                          webservice.oam.dev/processed-by: "host-cluster-composition"
                      spec:
                        appContainer: $APP_CONTAINER
                        name: $SERVICE_NAME
                        language: $LANGUAGE
                        framework: $FRAMEWORK
                        database: $DATABASE
                        cache: $CACHE
                      EOF
                      
                      # Create OAM Application for vCluster KubeVela processing
                      # ALWAYS use default namespace for OAM Application (where WorkloadDefinitions exist)
                      # The topology policy will handle deployment to the correct location
                      OAM_NAMESPACE="default"
                      
                      cat > vcluster/$VCLUSTER_TARGET/applications/$SERVICE_NAME/oam-application.yaml << EOF
                      apiVersion: core.oam.dev/v1beta1
                      kind: Application
                      metadata:
                        name: $SERVICE_NAME-app
                        namespace: $OAM_NAMESPACE
                      spec:
                        components:
                        - name: $SERVICE_NAME
                          type: webservice
                          properties:
                            image: "docker.io/socrates12345/$SERVICE_NAME:v1.0.0"
                            port: 8080
                            healthPath: "/health"
                            language: $LANGUAGE
                            framework: $FRAMEWORK
                      $(if [ "$DATABASE" != "none" ]; then
                      echo "      database: $DATABASE
                            envFrom:
                            - secretRef:
                                name: \"${SERVICE_NAME}-db-secret\""
                      fi)
                            environment:
                              LOG_LEVEL: "INFO"
                              AGENT_TYPE: "$SERVICE_NAME"
                        policies:
                        - name: deploy-to-vcluster
                          type: topology
                          properties:
                            clusters: ["$VCLUSTER_TARGET"]
                            namespace: "default"
                      EOF
                      
                      # Create ArgoCD Application for this service
                      cat > vcluster/$VCLUSTER_TARGET/applications/$SERVICE_NAME/argocd-app.yaml << EOF
                      apiVersion: argoproj.io/v1alpha1
                      kind: Application
                      metadata:
                        name: $SERVICE_NAME
                        namespace: argocd
                      spec:
                        project: default
                        source:
                          repoURL: https://github.com/$GITHUB_USER/$APP_CONTAINER-gitops
                          targetRevision: main
                          path: vcluster/$VCLUSTER_TARGET/applications/$SERVICE_NAME
                          directory:
                            include: '{application-claim.yaml,oam-application.yaml}'
                        destination:
                          server: https://kubernetes.default.svc
                          namespace: default
                        syncPolicy:
                          automated:
                            prune: true
                            selfHeal: true
                      EOF
                      
                      echo "âœ… Created vCluster-specific manifests in vcluster/$VCLUSTER_TARGET/applications/$SERVICE_NAME/"
                      
                      # Commit and push changes
                      git add oam/applications/application.yaml
                      git add vcluster/$VCLUSTER_TARGET/applications/$SERVICE_NAME/
                      git commit -m "Add $SERVICE_NAME webservice component to OAM Application (Target: $VCLUSTER_TARGET, Lang: $LANGUAGE, Framework: $FRAMEWORK, DB: $DATABASE, Cache: $CACHE)"
                      
                      git push
                      
                      echo "ðŸŽ‰ Successfully updated OAM Application with $SERVICE_NAME webservice component"
                    env:
                    - name: SERVICE_NAME
                      value: "placeholder"
                    - name: APP_CONTAINER
                      value: "placeholder"
                    - name: LANGUAGE
                      value: "placeholder"
                    - name: FRAMEWORK
                      value: "placeholder"
                    - name: DATABASE
                      value: "placeholder"
                    - name: CACHE
                      value: "placeholder"
                    - name: DEFAULT_REGISTRY
                      value: "acr"  # Default to ACR for UAE deployment
                    - name: REALTIME_PLATFORM
                      value: ""
                    - name: BOOTSTRAP_SOURCE
                      value: "placeholder"
                    - name: GITHUB_TOKEN
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: token
                    - name: GITHUB_USER
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: user
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-oam-updater"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-oam-updater"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.language
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.framework
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[3].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.database
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[4].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.cache
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[5].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.realtime
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[7].value
      policy:
        fromFieldPath: Optional
    - type: FromCompositeFieldPath
      fromFieldPath: metadata.annotations["webservice.oam.dev/source"]
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[8].value
      policy:
        fromFieldPath: Optional
      transforms:
      - type: string
        string:
          fmt: "%s"

  # Create Chat Service Repository (conditional on language=rasa and framework=chatbot)
  - name: create-chat-service-repository
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: default
            spec:
              template:
                metadata:
                  annotations:
                    sidecar.istio.io/inject: "false"
                spec:
                  serviceAccountName: crossplane-github-provider
                  restartPolicy: OnFailure
                  containers:
                  - name: chat-repo-creator
                    image: alpine:3.18
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      
                      # Check if this is a RASA chatbot service
                      if [ "$LANGUAGE" != "rasa" ] || [ "$FRAMEWORK" != "chatbot" ]; then
                        echo "âŒ Skipping chat repository creation - not a RASA chatbot service"
                        echo "   Language: $LANGUAGE (expected: rasa)"  
                        echo "   Framework: $FRAMEWORK (expected: chatbot)"
                        echo "âœ… Chat repository creation skipped successfully"
                        exit 0
                      fi
                      
                      # Install git, curl, and jq
                      apk add --no-cache git curl jq
                      echo "Adding Rasa chatbot microservice $SERVICE_NAME to unified repository $APP_CONTAINER..."
                      
                      # Clone unified AppContainer repository
                      TEMP_DIR="/tmp/unified-repo-$SERVICE_NAME"
                      mkdir -p $TEMP_DIR
                      cd $TEMP_DIR
                      
                      # First check if AppContainer repository exists
                      REPO_EXISTS=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
                        https://api.github.com/repos/$GITHUB_USER/$APP_CONTAINER | jq -r '.name // "null"')
                      
                      if [ "$REPO_EXISTS" = "null" ]; then
                        echo "âŒ AppContainer repository $APP_CONTAINER does not exist yet"
                        echo "â³ Waiting for AppContainer to be created by other jobs..."
                        exit 1
                      fi
                      
                      echo "âœ… AppContainer repository exists, cloning..."
                      git clone https://$GITHUB_TOKEN@github.com/$GITHUB_USER/$APP_CONTAINER.git .
                      
                      # Check if microservice already exists
                      if [ -d "microservices/$SERVICE_NAME" ]; then
                        echo "âš ï¸  Microservice $SERVICE_NAME already exists in $APP_CONTAINER"
                        echo "ðŸ”„ Updating existing microservice..."
                      else
                        echo "âž• Adding new microservice $SERVICE_NAME to $APP_CONTAINER"
                        
                        # Clone chat-template to get the template
                        TEMPLATE_DIR="/tmp/chat-template"
                        git clone https://$GITHUB_TOKEN@github.com/$GITHUB_USER/chat-template.git $TEMPLATE_DIR
                        
                        # Copy template microservice structure
                        mkdir -p microservices/$SERVICE_NAME
                        cp -r $TEMPLATE_DIR/microservices/chat-template/* microservices/$SERVICE_NAME/
                        
                        # Add chat-specific GitHub Actions workflow if not exists
                        if [ ! -f ".github/workflows/chat-gitops.yml" ]; then
                          cp $TEMPLATE_DIR/.github/workflows/chat-gitops.yml .github/workflows/
                        fi
                        
                        rm -rf $TEMPLATE_DIR
                      fi
                      
                      # Customize for the specific service
                      sed -i "s/chat-template/$SERVICE_NAME/g" microservices/$SERVICE_NAME/docker-compose.yml
                      sed -i "s/Development Bot/$SERVICE_NAME Bot/g" microservices/$SERVICE_NAME/docker-compose.yml
                      sed -i "s/Customer Support Bot/$SERVICE_NAME Support Bot/g" microservices/$SERVICE_NAME/domain.yml
                      
                      # Update OAM files with correct service name
                      find microservices/$SERVICE_NAME/oam/ -name "*.yaml" -exec sed -i "s/chat-template/$SERVICE_NAME/g" {} \;
                      
                      # Set git configuration
                      git config user.name "Crossplane Bot"
                      git config user.email "crossplane@health-service-idp.local"
                      
                      # Add and commit changes to unified repository
                      git add microservices/$SERVICE_NAME/
                      if [ -f ".github/workflows/chat-gitops.yml" ]; then
                        git add .github/workflows/chat-gitops.yml
                      fi
                      
                      # Check if there are changes to commit
                      if git diff --staged --quiet; then
                        echo "âš ï¸  No changes to commit for $SERVICE_NAME"
                      else
                        git commit -m "feat: add RASA chatbot microservice $SERVICE_NAME" -m "- Add complete RASA chatbot implementation with dual-container pattern" -m "- Include Rasa server and Actions server configurations" -m "- Add chat-specific GitHub Actions workflow for Docker builds" -m "- Support for natural language understanding and custom actions" -m "- Ready for OAM deployment with knative services" -m "ðŸ¤– Generated with [Claude Code](https://claude.ai/code)" -m "Co-Authored-By: Claude <noreply@anthropic.com>"
                        
                        git push origin main
                        echo "âœ… RASA chatbot microservice $SERVICE_NAME added to unified repository $APP_CONTAINER"
                      fi
                    env:
                    - name: SERVICE_NAME
                      value: placeholder
                    - name: LANGUAGE
                      value: placeholder
                    - name: FRAMEWORK
                      value: placeholder
                    - name: APP_CONTAINER
                      value: placeholder
                    - name: GITHUB_TOKEN
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: token
                    - name: GITHUB_USER
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: user
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-chat-repo-creator"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-chat-repo-creator"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.language
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.framework
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[3].value
    # Only deploy if language is rasa and framework is chatbot
    - type: FromCompositeFieldPath
      fromFieldPath: spec.language
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "rasa": "true"
          "python": "false"
          "java": "false"
          "nodejs": "false"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.framework
      toFieldPath: metadata.labels["crossplane.io/chatbot-enable"]
      transforms:
      - type: map
        map:
          "chatbot": "true"
          "fastapi": "false"
          "springboot": "false"
          "graphql-gateway": "false"

  # Repository status synchronizer - gets repository URL from AppContainerClaim
  - name: repository-status-sync
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: default
            spec:
              template:
                metadata:
                  annotations:
                    sidecar.istio.io/inject: "false"
                spec:
                  serviceAccountName: crossplane-github-provider
                  restartPolicy: OnFailure
                  containers:
                  - name: repository-sync
                    image: alpine/k8s:1.28.4
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      echo "ðŸ”„ Synchronizing repository status from AppContainerClaim..."
                      
                      # Wait for AppContainerClaim to be ready and get repository URL
                      APP_CONTAINER="$APP_CONTAINER_NAME"
                      SERVICE_NAME="$SERVICE_NAME"
                      NAMESPACE="$NAMESPACE"
                      
                      echo "Waiting for AppContainerClaim $APP_CONTAINER to be ready..."
                      
                      TIMEOUT=300
                      ELAPSED=0
                      
                      while [ $ELAPSED -lt $TIMEOUT ]; do
                        # Check if AppContainerClaim exists and get repository URL
                        REPO_URL=$(kubectl get appcontainerclaim "$APP_CONTAINER" -n "$NAMESPACE" -o jsonpath='{.status.sourceRepository.url}' 2>/dev/null || echo "")
                        CLONE_URL=$(kubectl get appcontainerclaim "$APP_CONTAINER" -n "$NAMESPACE" -o jsonpath='{.status.sourceRepository.cloneUrl}' 2>/dev/null || echo "")
                        
                        if [ -n "$REPO_URL" ]; then
                          echo "âœ… Found repository URL: $REPO_URL"
                          echo "âœ… Found clone URL: $CLONE_URL"
                          
                          # Find associated Knative service
                          KNATIVE_SERVICE=""
                          if kubectl get ksvc "$SERVICE_NAME" -n "$NAMESPACE" >/dev/null 2>&1; then
                            KNATIVE_SERVICE="$SERVICE_NAME"
                          elif kubectl get ksvc "${SERVICE_NAME}-realtime-service" -n "$NAMESPACE" >/dev/null 2>&1; then
                            KNATIVE_SERVICE="${SERVICE_NAME}-realtime-service"
                          elif kubectl get ksvc "${SERVICE_NAME}-service" -n "$NAMESPACE" >/dev/null 2>&1; then
                            KNATIVE_SERVICE="${SERVICE_NAME}-service"
                          fi
                          
                          echo "Found Knative Service: $KNATIVE_SERVICE"
                          
                          # Update ApplicationClaim status
                          kubectl patch applicationclaim "$SERVICE_NAME" -n "$NAMESPACE" --type=merge --subresource=status -p "{
                            \"status\": {
                              \"repository\": {
                                \"url\": \"$REPO_URL\",
                                \"cloneUrl\": \"$CLONE_URL\"
                              },
                              \"application\": {
                                \"knativeService\": \"$KNATIVE_SERVICE\"
                              }
                            }
                          }"
                          
                          echo "âœ… ApplicationClaim status synchronized from AppContainerClaim"
                          exit 0
                        fi
                        
                        echo "Waiting for AppContainerClaim repository status... (${ELAPSED}s/${TIMEOUT}s)"
                        sleep 10
                        ELAPSED=$((ELAPSED + 10))
                      done
                      
                      echo "âŒ Timeout waiting for AppContainerClaim repository status"
                      exit 1
                    env:
                    - name: SERVICE_NAME
                      value: placeholder
                    - name: APP_CONTAINER_NAME
                      value: placeholder
                    - name: NAMESPACE
                      value: placeholder
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-repo-sync"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-repo-sync"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
    - type: FromCompositeFieldPath  
      fromFieldPath: spec.namespace
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].value
    - type: FromCompositeFieldPath
      fromFieldPath: metadata.namespace  
      toFieldPath: spec.forProvider.manifest.metadata.namespace


  # Setup ArgoCD application for GitOps sync
  - name: argocd-app-setup
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: default
            spec:
              template:
                metadata:
                  annotations:
                    sidecar.istio.io/inject: "false"
                spec:
                  serviceAccountName: crossplane-github-provider
                  restartPolicy: OnFailure
                  containers:
                  - name: argocd-setup
                    image: alpine/k8s:1.28.4
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      echo "ðŸ”§ Setting up ArgoCD for $SERVICE_NAME..."
                      
                      # Wait for GitOps repo to be ready
                      sleep 30
                      
                      # Direct kubectl approach (simpler for in-cluster)
                      echo "ðŸ“ Creating ArgoCD Application via kubectl..."
                      
                      # Add repository secret for authentication
                      echo "ðŸ”‘ Creating repository secret..."
                      cat <<EOFS | kubectl apply -f -
                      apiVersion: v1
                      kind: Secret
                      metadata:
                        name: repo-$APP_CONTAINER-gitops
                        namespace: argocd
                        labels:
                          argocd.argoproj.io/secret-type: repository
                      type: Opaque
                      stringData:
                        type: git
                        url: https://github.com/$GITHUB_USER/$APP_CONTAINER-gitops
                        username: $GITHUB_USER
                        password: $GITHUB_TOKEN
                      EOFS
                      
                      echo "âœ… Repository secret created"
                      
                      # Determine target vCluster
                      if [ -n "$TARGET_VCLUSTER" ] && [ "$TARGET_VCLUSTER" != "" ]; then
                        echo "ðŸŽ¯ Deploying to vCluster: $TARGET_VCLUSTER"
                        # For vCluster deployments, we need to register the vCluster first
                        # The actual application will be applied to the vCluster once registered
                        DEST_SERVER="https://kubernetes.default.svc"
                        # Use apps directory which contains the App of Apps pattern
                        APP_PATH="apps"
                      else
                        echo "ðŸŽ¯ Deploying to default cluster"
                        DEST_SERVER="https://kubernetes.default.svc"
                        APP_PATH="apps"
                      fi
                      
                      # Create ArgoCD Application
                      cat <<EOFA | kubectl apply -f -
                      apiVersion: argoproj.io/v1alpha1
                      kind: Application
                      metadata:
                        name: $SERVICE_NAME-app
                        namespace: argocd
                        finalizers:
                          - resources-finalizer.argocd.argoproj.io
                      spec:
                        project: default
                        source:
                          repoURL: https://github.com/$GITHUB_USER/$APP_CONTAINER-gitops
                          targetRevision: main
                          path: $APP_PATH
                        destination:
                          server: $DEST_SERVER
                          namespace: default
                        syncPolicy:
                          automated:
                            prune: true
                            selfHeal: true
                          syncOptions:
                            - CreateNamespace=true
                      EOFA
                      
                      echo "âœ… ArgoCD Application created"
                      
                      # Trigger initial sync
                      echo "ðŸ”„ Triggering initial sync..."
                      kubectl patch application $SERVICE_NAME-app -n argocd --type merge -p '{"operation":{"sync":{"revision":"HEAD"}}}' || echo "Sync triggered"
                      
                      echo "ðŸŽ‰ ArgoCD setup completed for $SERVICE_NAME"
                      echo "ðŸ“Š Application will be synced to namespace: default"
                      echo "ðŸ”— Repository: https://github.com/$GITHUB_USER/$APP_CONTAINER-gitops"
                    env:
                    - name: SERVICE_NAME
                      value: "placeholder"
                    - name: APP_CONTAINER
                      value: "placeholder"
                    - name: TARGET_VCLUSTER
                      value: "placeholder"
                    - name: GITHUB_TOKEN
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: token
                    - name: GITHUB_USER
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: user
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-argocd-setup"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-argocd-setup"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.targetVCluster
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].value
