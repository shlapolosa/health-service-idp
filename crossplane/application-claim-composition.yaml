apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: application-claim-composition
  labels:
    crossplane.io/xrd: xapplicationclaims.platform.example.org
    provider: github-kubernetes-helm
spec:
  writeConnectionSecretsToNamespace: crossplane-system
  compositeTypeRef:
    apiVersion: platform.example.org/v1alpha1
    kind: XApplicationClaim
  resources:
  
  # Add microservice to existing AppContainer source repository
  - name: add-microservice-to-container
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: default
            spec:
              template:
                spec:
                  serviceAccountName: crossplane-github-provider
                  restartPolicy: OnFailure
                  containers:
                  - name: microservice-creator
                    image: alpine/git:latest
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      echo "Adding microservice $SERVICE_NAME to AppContainer $APP_CONTAINER..."
                      
                      TEMP_DIR="/tmp/app-container-$APP_CONTAINER"
                      mkdir -p $TEMP_DIR
                      cd $TEMP_DIR
                      
                      # Clone the AppContainer repository using GitHub token
                      git clone https://$GITHUB_TOKEN@github.com/$GITHUB_USER/$APP_CONTAINER.git .
                      
                      # Create microservice directory
                      mkdir -p microservices/$SERVICE_NAME
                      cd microservices/$SERVICE_NAME
                      
                      # Create CLAUDE.md-compliant Onion Architecture structure
                      mkdir -p src/domain
                      mkdir -p src/application  
                      mkdir -p src/infrastructure
                      mkdir -p src/interface
                      mkdir -p tests/unit
                      mkdir -p tests/integration
                      mkdir -p manifest
                      
                      if [ "$LANGUAGE" = "python" ] && [ "$FRAMEWORK" = "fastapi" ]; then
                        # Python FastAPI microservice with CLAUDE.md structure
                        cat > pyproject.toml << EOF
                      [tool.poetry]
                      name = "$SERVICE_NAME"
                      version = "0.1.0"
                      description = "CLAUDE.md-compliant FastAPI microservice"
                      authors = ["Generated by ApplicationClaim"]
                      
                      [tool.poetry.dependencies]
                      python = "^3.11"
                      fastapi = "^0.104.0"
                      uvicorn = "^0.24.0"
                      pydantic = "^2.0.0"
                      sqlalchemy = "^2.0.0"
                      
                      [tool.poetry.group.dev.dependencies]
                      pytest = "^7.4.0"
                      pytest-asyncio = "^0.21.0"
                      black = "^23.0.0"
                      isort = "^5.12.0"
                      mypy = "^1.5.0"
                      
                      [build-system]
                      requires = ["poetry-core"]
                      build-backend = "poetry.core.masonry.api"
                      EOF
                      
                        # Domain layer
                        cat > src/domain/models.py << EOF
                      """Domain models following CLAUDE.md Onion Architecture"""
                      from abc import ABC, abstractmethod
                      from typing import Optional
                      from pydantic import BaseModel
                      
                      class Entity(BaseModel):
                          """Base domain entity"""
                          id: Optional[str] = None
                      
                      class DomainService(ABC):
                          """Base domain service interface"""
                          pass
                      EOF
                      
                        # Application layer
                        cat > src/application/use_cases.py << EOF
                      """Application use cases following CLAUDE.md principles"""
                      from abc import ABC, abstractmethod
                      from typing import Generic, TypeVar
                      
                      T = TypeVar('T')
                      
                      class UseCase(ABC, Generic[T]):
                          """Base use case following CLAUDE.md patterns"""
                          
                          @abstractmethod
                          async def execute(self, request: T) -> dict:
                              pass
                      EOF
                      
                        # Infrastructure layer
                        cat > src/infrastructure/repositories.py << EOF
                      """Infrastructure repositories with dependency injection"""
                      from abc import ABC, abstractmethod
                      from typing import List, Optional
                      
                      class Repository(ABC):
                          """Base repository interface for dependency injection"""
                          pass
                      EOF
                      
                        # Interface layer (FastAPI)
                        cat > src/interface/api.py << EOF
                      """FastAPI interface layer following CLAUDE.md 12-factor principles"""
                      import os
                      from fastapi import FastAPI, Depends
                      from pydantic import BaseModel
                      
                      # 12-Factor: Config from environment
                      DATABASE_URL = os.getenv("DATABASE_URL", "")
                      REDIS_URL = os.getenv("REDIS_URL", "")
                      
                      app = FastAPI(
                          title="$SERVICE_NAME",
                          description="CLAUDE.md-compliant microservice with Onion Architecture",
                          version="0.1.0"
                      )
                      
                      class HealthResponse(BaseModel):
                          status: str
                          service: str
                      
                      @app.get("/health", response_model=HealthResponse)
                      async def health_check():
                          """Health check endpoint for Kubernetes probes"""
                          return HealthResponse(status="healthy", service="$SERVICE_NAME")
                      
                      @app.get("/ready", response_model=HealthResponse)
                      async def readiness_check():
                          """Readiness check endpoint for Kubernetes probes"""
                          return HealthResponse(status="ready", service="$SERVICE_NAME")
                      
                      @app.get("/")
                      async def root():
                          """Root endpoint"""
                          return {"message": "Hello from $SERVICE_NAME", "architecture": "onion"}
                      EOF
                      
                        # Main application entry point
                        cat > src/main.py << EOF
                      """Main application entry point following 12-factor principles"""
                      import os
                      import uvicorn
                      from interface.api import app
                      
                      if __name__ == "__main__":
                          # 12-Factor: Port binding
                          port = int(os.getenv("PORT", 8080))
                          uvicorn.run(app, host="0.0.0.0", port=port)
                      EOF
                      
                        # Multi-stage Dockerfile optimized for microservices build context
                        cat > Dockerfile << EOF
                      # Multi-stage build for production
                      FROM python:3.11-slim as builder
                      
                      # Install Poetry and basic build tools
                      RUN apt-get update && apt-get install -y curl gcc && rm -rf /var/lib/apt/lists/*
                      RUN pip install poetry
                      
                      # Set working directory for build
                      WORKDIR /build
                      
                      # Copy dependency files
                      COPY pyproject.toml ./
                      
                      # Configure poetry and install dependencies without dev packages (no-root to skip project install)
                      RUN poetry config virtualenvs.create false \
                          && poetry install --only=main --no-root --no-interaction --no-ansi
                      
                      # Production stage
                      FROM python:3.11-slim as production
                      
                      # Install curl for health checks
                      RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*
                      
                      # Create non-root user (security best practice)
                      RUN useradd --create-home --shell /bin/bash app
                      
                      # Copy installed packages from builder
                      COPY --from=builder /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages
                      COPY --from=builder /usr/local/bin /usr/local/bin
                      
                      # Set working directory
                      WORKDIR /app
                      
                      # Copy application code
                      COPY --chown=app:app src/ src/
                      
                      # Switch to non-root user
                      USER app
                      
                      # Set PYTHONPATH for proper module imports
                      ENV PYTHONPATH=/app/src
                      
                      # 12-Factor: Port binding
                      EXPOSE 8080
                      
                      # Health check with better error handling
                      HEALTHCHECK --interval=30s --timeout=10s --start-period=15s --retries=3 \
                        CMD curl -f http://localhost:8080/health || exit 1
                      
                      # Start application
                      CMD ["python", "-m", "src.main"]
                      EOF
                      
                        # TDD Tests
                        cat > tests/test_main.py << EOF
                      """TDD tests following CLAUDE.md principles"""
                      import pytest
                      from fastapi.testclient import TestClient
                      from src.interface.api import app
                      
                      client = TestClient(app)
                      
                      def test_health_check():
                          """Test health endpoint (TDD Red-Green-Refactor)"""
                          response = client.get("/health")
                          assert response.status_code == 200
                          data = response.json()
                          assert data["status"] == "healthy"
                          assert data["service"] == "$SERVICE_NAME"
                      
                      def test_readiness_check():
                          """Test readiness endpoint"""
                          response = client.get("/ready")
                          assert response.status_code == 200
                          data = response.json()
                          assert data["status"] == "ready"
                      
                      def test_root_endpoint():
                          """Test root endpoint"""
                          response = client.get("/")
                          assert response.status_code == 200
                          data = response.json()
                          assert "Hello from" in data["message"]
                          assert data["architecture"] == "onion"
                      EOF
                      fi
                      
                      # Create service README
                      cat > README.md << EOF
                      # $SERVICE_NAME
                      
                      CLAUDE.md-compliant microservice with Onion Architecture and 12-Factor principles.
                      
                      ## Architecture
                      
                      This microservice follows the Onion Architecture pattern:
                      
                      - **Domain Layer**: Business rules (`src/domain/`)
                      - **Application Layer**: Use cases (`src/application/`)
                      - **Interface Layer**: REST/API endpoints (`src/interface/`)
                      - **Infrastructure Layer**: Database, external services (`src/infrastructure/`)
                      
                      ## Development
                      
                      ### Prerequisites
                      - Python 3.11+
                      - Poetry
                      
                      ### Setup
                      ```bash
                      poetry install
                      poetry run pytest  # Run TDD tests
                      poetry run python src/main.py  # Run locally
                      ```
                      
                      ### Testing (TDD)
                      ```bash
                      poetry run pytest -v
                      ```
                      
                      ### Linting
                      ```bash
                      poetry run black src/
                      poetry run isort src/
                      poetry run mypy src/
                      ```
                      
                      ## Deployment
                      
                      This service is automatically deployed via the AppContainer CI/CD pipeline when changes are pushed to the main branch.
                      EOF
                      
                      # Update microservices README
                      cd ../../
                      if grep -q "- (Services will be listed here as they are added)" microservices/README.md; then
                        sed -i "s/- (Services will be listed here as they are added)/- $SERVICE_NAME ($LANGUAGE\/$FRAMEWORK)/" microservices/README.md
                      else
                        echo "- $SERVICE_NAME ($LANGUAGE/$FRAMEWORK)" >> microservices/README.md
                      fi
                      
                      # Commit and push
                      git config user.name "ApplicationClaim"
                      git config user.email "applicationclaim@platform.local"
                      git add .
                      git commit -m "Add $SERVICE_NAME microservice ($LANGUAGE/$FRAMEWORK)
                      
                      - Implements CLAUDE.md Onion Architecture
                      - Follows 12-Factor App principles
                      - Includes TDD test structure with pytest
                      - Dependency injection ready
                      - FastAPI with health checks
                      - Multi-stage Dockerfile
                      - Poetry for dependency management"
                      git push
                      
                      echo "Microservice $SERVICE_NAME added to AppContainer $APP_CONTAINER successfully"
                    env:
                    - name: APP_CONTAINER
                      value: placeholder
                    - name: SERVICE_NAME
                      value: placeholder
                    - name: LANGUAGE
                      value: placeholder
                    - name: FRAMEWORK
                      value: placeholder
                    - name: GITHUB_TOKEN
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: token
                    - name: GITHUB_USER
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: user
                    - name: DOCKER_REGISTRY
                      valueFrom:
                        secretKeyRef:
                          name: docker-credentials
                          key: registry
                    - name: DOCKER_USER
                      valueFrom:
                        secretKeyRef:
                          name: docker-credentials
                          key: username
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-microservice-creator"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.language
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.framework
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[3].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-microservice-creator"

  # Add GitOps manifests for the new microservice
  - name: add-gitops-manifests
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: default
            spec:
              template:
                spec:
                  serviceAccountName: crossplane-github-provider
                  restartPolicy: OnFailure
                  containers:
                  - name: gitops-manifest-creator
                    image: alpine/git:latest
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      echo "Adding GitOps manifests for $SERVICE_NAME in $APP_CONTAINER-gitops..."
                      
                      TEMP_DIR="/tmp/gitops-$APP_CONTAINER"
                      mkdir -p $TEMP_DIR
                      cd $TEMP_DIR
                      
                      # Clone the GitOps repository using GitHub token
                      git clone https://$GITHUB_TOKEN@github.com/$GITHUB_USER/$APP_CONTAINER-gitops.git .
                      
                      # Create manifests directory for the service
                      mkdir -p manifests/$SERVICE_NAME
                      cd manifests/$SERVICE_NAME
                      
                      
                      # Create ConfigMap for environment variables
                      cat > configmap.yaml << EOF
                      apiVersion: v1
                      kind: ConfigMap
                      metadata:
                        name: $SERVICE_NAME-config
                        namespace: $APP_CONTAINER
                      data:
                        APP_ENV: "production"
                        SERVICE_NAME: "$SERVICE_NAME"
                      EOF
                      
                      # Add database config if needed
                      if [ "$DATABASE" = "postgres" ]; then
                        cat >> configmap.yaml << EOF
                        DATABASE_URL: "postgresql://\$DATABASE_USER:\$DATABASE_PASSWORD@$APP_CONTAINER-postgres-rw.$APP_CONTAINER.svc.cluster.local:5432/$SERVICE_NAME"
                      EOF
                      fi
                      
                      # Add cache config if needed  
                      if [ "$CACHE" = "redis" ]; then
                        cat >> configmap.yaml << EOF
                        REDIS_URL: "redis://:\$REDIS_PASSWORD@$APP_CONTAINER-redis-master.$APP_CONTAINER.svc.cluster.local:6379/0"
                      EOF
                      fi
                      
                      
                      # Commit and push GitOps changes
                      cd ..
                      git config user.name "ApplicationClaim GitOps"
                      git config user.email "applicationclaim-gitops@platform.local"
                      git add .
                      git commit -m "Add GitOps manifests for $SERVICE_NAME microservice
                      
                      - Add ConfigMap for environment variables  
                      - Ready for OAM Application inline component definition
                      - Ready for ArgoCD ApplicationSet deployment"
                      git push
                      
                      echo "GitOps manifests for $SERVICE_NAME added successfully"
                    env:
                    - name: APP_CONTAINER
                      value: placeholder
                    - name: SERVICE_NAME
                      value: placeholder
                    - name: DATABASE
                      value: placeholder
                    - name: CACHE
                      value: placeholder
                    - name: GITHUB_TOKEN
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: token
                    - name: GITHUB_USER
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: user
                    - name: DOCKER_REGISTRY
                      valueFrom:
                        secretKeyRef:
                          name: docker-credentials
                          key: registry
                    - name: DOCKER_USER
                      valueFrom:
                        secretKeyRef:
                          name: docker-credentials
                          key: username
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-gitops-creator"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.database
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.cache
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[3].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-gitops-creator"

  # PostgreSQL Database (conditional on spec.database=postgres)
  - name: postgres-database
    base:
      apiVersion: helm.crossplane.io/v1beta1
      kind: Release
      spec:
        forProvider:
          chart:
            name: postgresql
            repository: https://charts.bitnami.com/bitnami
            version: "13.2.24"
          namespace: placeholder
          skipCreateNamespace: false
          values:
            auth:
              enablePostgresUser: true
              postgresPassword: "placeholder"
              username: "placeholder"
              password: "placeholder"
              database: "placeholder"
            primary:
              persistence:
                enabled: true
                size: 10Gi
                storageClass: gp2
              resources:
                requests:
                  memory: 256Mi
                  cpu: 250m
                limits:
                  memory: 512Mi
                  cpu: 500m
              readinessProbe:
                enabled: true
                initialDelaySeconds: 30
                periodSeconds: 10
              livenessProbe:
                enabled: true
                initialDelaySeconds: 30
                periodSeconds: 10
            metrics:
              enabled: true
              serviceMonitor:
                enabled: false
            backup:
              enabled: false
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-postgres"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.auth.database
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.auth.username
    # Generate random passwords (in production, use External Secrets)
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.auth.postgresPassword
      transforms:
      - type: string
        string:
          fmt: "%s-postgres-admin-pass"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.auth.password
      transforms:
      - type: string
        string:
          fmt: "%s-user-pass"
    # Status patches for database connection info
    - type: ToCompositeFieldPath
      fromFieldPath: status.atProvider.state
      toFieldPath: status.infrastructure.database.ready
      transforms:
      - type: map
        map:
          "deployed": true
          "failed": false
      policy:
        fromFieldPath: Optional
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: status.infrastructure.database.endpoint
      transforms:
      - type: string
        string:
          fmt: "%s-postgresql.%s.svc.cluster.local:5432"
      policy:
        fromFieldPath: Optional
    # Only deploy if database is postgres
    - type: FromCompositeFieldPath
      fromFieldPath: spec.database
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "postgres": "true"
          "none": "false"

  # Redis Cache (conditional on spec.cache=redis)
  - name: redis-cache
    base:
      apiVersion: helm.crossplane.io/v1beta1
      kind: Release
      spec:
        forProvider:
          chart:
            name: redis
            repository: https://charts.bitnami.com/bitnami
            version: "18.4.0"
          namespace: placeholder
          skipCreateNamespace: false
          values:
            auth:
              enabled: true
              password: "placeholder"
            master:
              persistence:
                enabled: true
                size: 5Gi
                storageClass: gp2
              resources:
                requests:
                  memory: 128Mi
                  cpu: 100m
                limits:
                  memory: 256Mi
                  cpu: 200m
            replica:
              replicaCount: 1
              persistence:
                enabled: true
                size: 5Gi
                storageClass: gp2
              resources:
                requests:
                  memory: 128Mi
                  cpu: 100m
                limits:
                  memory: 256Mi
                  cpu: 200m
            metrics:
              enabled: true
              serviceMonitor:
                enabled: false
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-redis"
    # Generate random password (in production, use External Secrets)
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.auth.password
      transforms:
      - type: string
        string:
          fmt: "%s-redis-pass"
    # Status patches for cache connection info
    - type: ToCompositeFieldPath
      fromFieldPath: status.atProvider.state
      toFieldPath: status.infrastructure.cache.ready
      transforms:
      - type: map
        map:
          "deployed": true
          "failed": false
      policy:
        fromFieldPath: Optional
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: status.infrastructure.cache.endpoint
      transforms:
      - type: string
        string:
          fmt: "%s-redis-master.%s.svc.cluster.local:6379"
      policy:
        fromFieldPath: Optional
    # Only deploy if cache is redis
    - type: FromCompositeFieldPath
      fromFieldPath: spec.cache
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "redis": "true"
          "none": "false"

  # Database Secret (PostgreSQL credentials)
  - name: postgres-secret
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Secret
            metadata:
              name: placeholder
              namespace: placeholder
              labels:
                app.kubernetes.io/managed-by: "crossplane"
                app.kubernetes.io/component: "secret-integration"
                app.kubernetes.io/part-of: "application-infrastructure"
                realtime.platform.example.org/discoverable: "true"
                webservice.example.org/integration-type: "database"
              annotations:
                webservice.example.org/secret-type: "cross-component-integration"
                webservice.example.org/service-type: "db"
            type: Opaque
            stringData:
              # Plain text values - Kubernetes will base64 encode automatically
              DATABASE_URL: ""
              DB_HOST: ""
              DB_PORT: "5432"
              DB_NAME: ""
              DB_USER: ""
              DB_PASSWORD: ""
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-db-secret"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-db-secret"
    # Only create if database is postgres
    - type: FromCompositeFieldPath
      fromFieldPath: spec.database
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "postgres": "true"
          "none": "false"
    # Patch secret values with plain text (Kubernetes will base64 encode)
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.DB_HOST
      transforms:
      - type: string
        string:
          fmt: "%s-postgresql.%s.svc.cluster.local"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.DB_NAME
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.DB_USER
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.DB_PASSWORD
      transforms:
      - type: string
        string:
          fmt: "%s-user-pass"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.DATABASE_URL
      transforms:
      - type: string
        string:
          fmt: "postgresql://%s:%s-user-pass@claims-postgresql.claims.svc.cluster.local:5432/%s"
          type: Format

  # Cache Secret (Redis credentials)
  - name: redis-secret
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Secret
            metadata:
              name: placeholder
              namespace: placeholder
              labels:
                app.kubernetes.io/managed-by: "crossplane"
                app.kubernetes.io/component: "secret-integration"
                app.kubernetes.io/part-of: "application-infrastructure"
                realtime.platform.example.org/discoverable: "true"
                webservice.example.org/integration-type: "cache"
              annotations:
                webservice.example.org/secret-type: "cross-component-integration"
                webservice.example.org/service-type: "redis"
            type: Opaque
            stringData:
              # Plain text values - Kubernetes will base64 encode automatically
              REDIS_URL: ""
              REDIS_HOST: ""
              REDIS_PORT: "6379"
              REDIS_PASSWORD: ""
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-redis-secret"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-redis-secret"
    # Only create if cache is redis
    - type: FromCompositeFieldPath
      fromFieldPath: spec.cache
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "redis": "true"
          "none": "false"
    # Patch Redis secret values
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.REDIS_HOST
      transforms:
      - type: string
        string:
          fmt: "%s-redis-master.%s.svc.cluster.local"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.REDIS_PASSWORD
      transforms:
      - type: string
        string:
          fmt: "%s-redis-pass"
          type: Format
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.stringData.REDIS_URL
      transforms:
      - type: string
        string:
          fmt: "redis://:%s-redis-pass@claims-redis-master.claims.svc.cluster.local:6379/0"
          type: Format

  # Update OAM Application with new webservice component
  - name: update-oam-application
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: default
            spec:
              template:
                spec:
                  serviceAccountName: crossplane-github-provider
                  restartPolicy: OnFailure
                  containers:
                  - name: oam-updater
                    image: alpine/git:latest
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      echo "Updating OAM Application with webservice component for $SERVICE_NAME..."
                      
                      TEMP_DIR="/tmp/oam-update-$APP_CONTAINER"
                      mkdir -p $TEMP_DIR
                      cd $TEMP_DIR
                      
                      # Clone the GitOps repository
                      git clone https://$GITHUB_TOKEN@github.com/$GITHUB_USER/$APP_CONTAINER-gitops.git .
                      
                      # Configure git
                      git config user.name "ApplicationClaim OAM Updater"
                      git config user.email "applicationclaim@platform.local"
                      
                      # Check if this is an API-driven ApplicationClaim (should update OAM)
                      # vs OAM-driven ApplicationClaim (should NOT update OAM to avoid circular dependency)
                      SOURCE="${BOOTSTRAP_SOURCE:-api-driven}"
                      
                      if [ "$SOURCE" != "api-driven" ]; then
                        echo "🔄 OAM-driven ApplicationClaim detected (source: $SOURCE)"
                        echo "⚠️  Skipping OAM update to avoid circular dependency"
                        echo "ℹ️  User should manually update OAM Application if needed"
                        exit 0
                      fi
                      
                      echo "🔄 API-driven ApplicationClaim detected - proceeding with OAM update"
                      
                      # Check if OAM application file exists
                      if [ ! -f "oam/applications/application.yaml" ]; then
                        echo "❌ OAM application file not found"
                        exit 1
                      fi
                      
                      echo "📋 Current OAM Application:"
                      cat oam/applications/application.yaml
                      
                      # Check if component already exists in OAM Application
                      if grep -q "name: $SERVICE_NAME" oam/applications/application.yaml; then
                        echo "⚠️  Component '$SERVICE_NAME' already exists in OAM Application"
                        echo "🔄 Skipping update to avoid duplication"
                        echo "ℹ️  If you need to update the component, modify the OAM Application directly"
                        exit 0
                      fi
                      
                      echo "✅ Component '$SERVICE_NAME' not found - proceeding with addition"
                      
                      # Create new component definition for enhanced webservice ComponentDefinition
                      COMPONENT_YAML="
                        - name: $SERVICE_NAME
                          type: webservice
                          properties:
                            name: $SERVICE_NAME
                            image: $SERVICE_NAME:latest
                            language: $LANGUAGE
                            framework: $FRAMEWORK
                            port: 8080
                            healthPath: /health"
                      
                      # Add realtime platform integration if specified
                      if [ -n "$REALTIME_PLATFORM" ] && [ "$REALTIME_PLATFORM" != "none" ]; then
                        COMPONENT_YAML="${COMPONENT_YAML}
                            realtime: $REALTIME_PLATFORM
                            websocket: true"
                      fi
                      
                      # Add database if specified
                      if [ "$DATABASE" != "none" ] && [ -n "$DATABASE" ]; then
                        COMPONENT_YAML="${COMPONENT_YAML}
                            database: $DATABASE"
                      fi
                      
                      # Add cache if specified
                      if [ "$CACHE" != "none" ] && [ -n "$CACHE" ]; then
                        COMPONENT_YAML="${COMPONENT_YAML}
                            cache: $CACHE"
                      fi
                      
                      # Add AppContainer reference
                      COMPONENT_YAML="${COMPONENT_YAML}
                            appContainer: $APP_CONTAINER
                            exposeApi: true"
                      
                      # Check if components array is empty
                      if grep -q "components: \[\]" oam/applications/application.yaml; then
                        echo "🔄 Adding first component to empty OAM Application..."
                        
                        # Replace empty components array with the new component
                        sed -i "s/components: \[\]/components:$COMPONENT_YAML/" oam/applications/application.yaml
                        
                      elif grep -q "components:" oam/applications/application.yaml; then
                        echo "🔄 Adding component to existing OAM Application..."
                        
                        # Find the line number of components: and add the new component
                        COMPONENTS_LINE=$(grep -n "components:" oam/applications/application.yaml | cut -d: -f1)
                        
                        # Create temp file with the new component added
                        head -n $COMPONENTS_LINE oam/applications/application.yaml > temp_app.yaml
                        echo "$COMPONENT_YAML" | sed 's/^/        /' >> temp_app.yaml
                        tail -n +$((COMPONENTS_LINE + 1)) oam/applications/application.yaml >> temp_app.yaml
                        
                        mv temp_app.yaml oam/applications/application.yaml
                        
                      else
                        echo "❌ No components section found in OAM Application"
                        exit 1
                      fi
                      
                      echo "✅ Updated OAM Application:"
                      cat oam/applications/application.yaml
                      
                      # Commit and push changes
                      git add oam/applications/application.yaml
                      git commit -m "Add $SERVICE_NAME webservice component to OAM Application - Language $LANGUAGE Framework $FRAMEWORK Database $DATABASE Cache $CACHE - Generated by ApplicationClaim composition"
                      
                      git push
                      
                      echo "🎉 Successfully updated OAM Application with $SERVICE_NAME webservice component"
                    env:
                    - name: SERVICE_NAME
                      value: "placeholder"
                    - name: APP_CONTAINER
                      value: "placeholder"
                    - name: LANGUAGE
                      value: "placeholder"
                    - name: FRAMEWORK
                      value: "placeholder"
                    - name: DATABASE
                      value: "placeholder"
                    - name: CACHE
                      value: "placeholder"
                    - name: BOOTSTRAP_SOURCE
                      value: "placeholder"
                    - name: GITHUB_TOKEN
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: token
                    - name: GITHUB_USER
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: user
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-oam-updater"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-oam-updater"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.language
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.framework
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[3].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.database
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[4].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.cache
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[5].value
    - type: FromCompositeFieldPath
      fromFieldPath: metadata.annotations["webservice.oam.dev/source"]
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[6].value
      policy:
        fromFieldPath: Optional
      transforms:
      - type: string
        string:
          fmt: "%s"

  # Create Chat Service Repository (conditional on language=rasa and framework=chatbot)
  - name: create-chat-service-repository
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: default
            spec:
              template:
                spec:
                  serviceAccountName: crossplane-github-provider
                  restartPolicy: OnFailure
                  containers:
                  - name: chat-repo-creator
                    image: alpine/git:latest
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      echo "Creating Rasa chatbot repository for $SERVICE_NAME..."
                      
                      # Clone health-service-chat-template
                      TEMP_DIR="/tmp/chat-repo-$SERVICE_NAME"
                      mkdir -p $TEMP_DIR
                      cd $TEMP_DIR
                      
                      git clone https://$GITHUB_TOKEN@github.com/$GITHUB_USER/health-service-chat-template.git .
                      rm -rf .git
                      
                      # Customize for the specific service
                      sed -i "s/chat-template/$SERVICE_NAME/g" README.md
                      sed -i "s/Development Bot/$SERVICE_NAME Bot/g" docker-compose.yml
                      
                      # Update domain.yml with service-specific bot name
                      sed -i "s/Customer Support Bot/$SERVICE_NAME Support Bot/g" domain.yml
                      
                      # Create new repository
                      git init
                      git config user.name "ApplicationClaim Chat Creator"
                      git config user.email "applicationclaim@platform.local"
                      git add .
                      git commit -m "Initial Rasa chatbot setup for $SERVICE_NAME
                      
                      - Based on health-service-chat-template
                      - Includes dual-container Dockerfile setup
                      - Ready for chat-gitops.yml pipeline
                      - Configured for OAM rasa-chatbot ComponentDefinition"
                      
                      # Create GitHub repository and push
                      curl -X POST \
                        -H "Authorization: token $GITHUB_TOKEN" \
                        -H "Content-Type: application/json" \
                        -d "{\"name\":\"$SERVICE_NAME\",\"description\":\"Rasa chatbot for $SERVICE_NAME\",\"private\":false}" \
                        https://api.github.com/user/repos
                      
                      git remote add origin https://github.com/$GITHUB_USER/$SERVICE_NAME.git
                      git push -u origin main
                      
                      echo "Rasa chatbot repository $SERVICE_NAME created successfully"
                    env:
                    - name: SERVICE_NAME
                      value: placeholder
                    - name: GITHUB_TOKEN
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: token
                    - name: GITHUB_USER
                      valueFrom:
                        secretKeyRef:
                          name: github-credentials
                          key: user
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-chat-repo-creator"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-chat-repo-creator"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
    # Only deploy if language is rasa and framework is chatbot
    - type: FromCompositeFieldPath
      fromFieldPath: spec.language
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "rasa": "true"
          "python": "false"
          "java": "false"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.framework
      toFieldPath: metadata.labels["crossplane.io/chatbot-enable"]
      transforms:
      - type: map
        map:
          "chatbot": "true"
          "fastapi": "false"
          "springboot": "false"