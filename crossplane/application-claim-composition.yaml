apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: application-claim-composition
  labels:
    crossplane.io/xrd: xapplicationclaims.platform.example.org
    provider: github-kubernetes-helm
spec:
  writeConnectionSecretsToNamespace: crossplane-system
  compositeTypeRef:
    apiVersion: platform.example.org/v1alpha1
    kind: XApplicationClaim
  environment:
    environmentRefs:
    - type: Selector
      selector:
        matchLabels:
        - key: environment
          type: Value
          value: default
  resources:
  
  # Add microservice to existing AppContainer source repository
  - name: add-microservice-to-container
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: default
            spec:
              template:
                spec:
                  serviceAccountName: crossplane-github-provider
                  restartPolicy: OnFailure
                  containers:
                  - name: microservice-creator
                    image: alpine/git:latest
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      echo "Adding microservice $SERVICE_NAME to AppContainer $APP_CONTAINER..."
                      
                      TEMP_DIR="/tmp/app-container-$APP_CONTAINER"
                      mkdir -p $TEMP_DIR
                      cd $TEMP_DIR
                      
                      # Clone the AppContainer repository
                      git clone https://github.com/socrates12345/$APP_CONTAINER.git .
                      
                      # Create microservice directory
                      mkdir -p microservices/$SERVICE_NAME
                      cd microservices/$SERVICE_NAME
                      
                      # Create CLAUDE.md-compliant Onion Architecture structure
                      mkdir -p src/domain
                      mkdir -p src/application  
                      mkdir -p src/infrastructure
                      mkdir -p src/interface
                      mkdir -p tests/unit
                      mkdir -p tests/integration
                      mkdir -p manifest
                      
                      if [ "$LANGUAGE" = "python" ] && [ "$FRAMEWORK" = "fastapi" ]; then
                        # Python FastAPI microservice with CLAUDE.md structure
                        cat > pyproject.toml << 'EOF'
                      [tool.poetry]
                      name = "$SERVICE_NAME"
                      version = "0.1.0"
                      description = "CLAUDE.md-compliant FastAPI microservice"
                      authors = ["Generated by ApplicationClaim"]
                      
                      [tool.poetry.dependencies]
                      python = "^3.11"
                      fastapi = "^0.104.0"
                      uvicorn = "^0.24.0"
                      pydantic = "^2.0.0"
                      sqlalchemy = "^2.0.0"
                      
                      [tool.poetry.group.dev.dependencies]
                      pytest = "^7.4.0"
                      pytest-asyncio = "^0.21.0"
                      black = "^23.0.0"
                      isort = "^5.12.0"
                      mypy = "^1.5.0"
                      
                      [build-system]
                      requires = ["poetry-core"]
                      build-backend = "poetry.core.masonry.api"
                      EOF
                      
                        # Domain layer
                        cat > src/domain/models.py << 'EOF'
                      """Domain models following CLAUDE.md Onion Architecture"""
                      from abc import ABC, abstractmethod
                      from typing import Optional
                      from pydantic import BaseModel
                      
                      class Entity(BaseModel):
                          """Base domain entity"""
                          id: Optional[str] = None
                      
                      class DomainService(ABC):
                          """Base domain service interface"""
                          pass
                      EOF
                      
                        # Application layer
                        cat > src/application/use_cases.py << 'EOF'
                      """Application use cases following CLAUDE.md principles"""
                      from abc import ABC, abstractmethod
                      from typing import Generic, TypeVar
                      
                      T = TypeVar('T')
                      
                      class UseCase(ABC, Generic[T]):
                          """Base use case following CLAUDE.md patterns"""
                          
                          @abstractmethod
                          async def execute(self, request: T) -> dict:
                              pass
                      EOF
                      
                        # Infrastructure layer
                        cat > src/infrastructure/repositories.py << 'EOF'
                      """Infrastructure repositories with dependency injection"""
                      from abc import ABC, abstractmethod
                      from typing import List, Optional
                      
                      class Repository(ABC):
                          """Base repository interface for dependency injection"""
                          pass
                      EOF
                      
                        # Interface layer (FastAPI)
                        cat > src/interface/api.py << 'EOF'
                      """FastAPI interface layer following CLAUDE.md 12-factor principles"""
                      import os
                      from fastapi import FastAPI, Depends
                      from pydantic import BaseModel
                      
                      # 12-Factor: Config from environment
                      DATABASE_URL = os.getenv("DATABASE_URL", "")
                      REDIS_URL = os.getenv("REDIS_URL", "")
                      
                      app = FastAPI(
                          title="$SERVICE_NAME",
                          description="CLAUDE.md-compliant microservice with Onion Architecture",
                          version="0.1.0"
                      )
                      
                      class HealthResponse(BaseModel):
                          status: str
                          service: str
                      
                      @app.get("/health", response_model=HealthResponse)
                      async def health_check():
                          """Health check endpoint for Kubernetes probes"""
                          return HealthResponse(status="healthy", service="$SERVICE_NAME")
                      
                      @app.get("/ready", response_model=HealthResponse)
                      async def readiness_check():
                          """Readiness check endpoint for Kubernetes probes"""
                          return HealthResponse(status="ready", service="$SERVICE_NAME")
                      
                      @app.get("/")
                      async def root():
                          """Root endpoint"""
                          return {"message": "Hello from $SERVICE_NAME", "architecture": "onion"}
                      EOF
                      
                        # Main application entry point
                        cat > src/main.py << 'EOF'
                      """Main application entry point following 12-factor principles"""
                      import os
                      import uvicorn
                      from interface.api import app
                      
                      if __name__ == "__main__":
                          # 12-Factor: Port binding
                          port = int(os.getenv("PORT", 8080))
                          uvicorn.run(app, host="0.0.0.0", port=port)
                      EOF
                      
                        # Multi-stage Dockerfile
                        cat > Dockerfile << 'EOF'
                      # Multi-stage build for production
                      FROM python:3.11-slim as builder
                      
                      # Install Poetry
                      RUN pip install poetry
                      
                      # Copy dependency files
                      COPY pyproject.toml poetry.lock* ./
                      
                      # Configure poetry and install dependencies
                      RUN poetry config virtualenvs.create false \
                          && poetry install --no-dev --no-interaction --no-ansi
                      
                      # Production stage
                      FROM python:3.11-slim as production
                      
                      # Create non-root user (security best practice)
                      RUN useradd --create-home --shell /bin/bash app
                      
                      # Copy installed packages from builder
                      COPY --from=builder /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages
                      COPY --from=builder /usr/local/bin /usr/local/bin
                      
                      # Set working directory
                      WORKDIR /app
                      
                      # Copy application code
                      COPY --chown=app:app src/ src/
                      
                      # Switch to non-root user
                      USER app
                      
                      # 12-Factor: Port binding
                      EXPOSE 8080
                      
                      # Health check
                      HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
                        CMD curl -f http://localhost:8080/health || exit 1
                      
                      # Start application
                      CMD ["python", "-m", "src.main"]
                      EOF
                      
                        # TDD Tests
                        cat > tests/test_main.py << 'EOF'
                      """TDD tests following CLAUDE.md principles"""
                      import pytest
                      from fastapi.testclient import TestClient
                      from src.interface.api import app
                      
                      client = TestClient(app)
                      
                      def test_health_check():
                          """Test health endpoint (TDD Red-Green-Refactor)"""
                          response = client.get("/health")
                          assert response.status_code == 200
                          data = response.json()
                          assert data["status"] == "healthy"
                          assert data["service"] == "$SERVICE_NAME"
                      
                      def test_readiness_check():
                          """Test readiness endpoint"""
                          response = client.get("/ready")
                          assert response.status_code == 200
                          data = response.json()
                          assert data["status"] == "ready"
                      
                      def test_root_endpoint():
                          """Test root endpoint"""
                          response = client.get("/")
                          assert response.status_code == 200
                          data = response.json()
                          assert "Hello from" in data["message"]
                          assert data["architecture"] == "onion"
                      EOF
                      fi
                      
                      # Create service README
                      cat > README.md << 'EOF'
                      # $SERVICE_NAME
                      
                      CLAUDE.md-compliant microservice with Onion Architecture and 12-Factor principles.
                      
                      ## Architecture
                      
                      This microservice follows the Onion Architecture pattern:
                      
                      - **Domain Layer**: Business rules (`src/domain/`)
                      - **Application Layer**: Use cases (`src/application/`)
                      - **Interface Layer**: REST/API endpoints (`src/interface/`)
                      - **Infrastructure Layer**: Database, external services (`src/infrastructure/`)
                      
                      ## Development
                      
                      ### Prerequisites
                      - Python 3.11+
                      - Poetry
                      
                      ### Setup
                      ```bash
                      poetry install
                      poetry run pytest  # Run TDD tests
                      poetry run python src/main.py  # Run locally
                      ```
                      
                      ### Testing (TDD)
                      ```bash
                      poetry run pytest -v
                      ```
                      
                      ### Linting
                      ```bash
                      poetry run black src/
                      poetry run isort src/
                      poetry run mypy src/
                      ```
                      
                      ## Deployment
                      
                      This service is automatically deployed via the AppContainer CI/CD pipeline when changes are pushed to the main branch.
                      EOF
                      
                      # Update microservices README
                      cd ../../
                      if grep -q "- (Services will be listed here as they are added)" microservices/README.md; then
                        sed -i "s/- (Services will be listed here as they are added)/- $SERVICE_NAME ($LANGUAGE\/$FRAMEWORK)/" microservices/README.md
                      else
                        echo "- $SERVICE_NAME ($LANGUAGE/$FRAMEWORK)" >> microservices/README.md
                      fi
                      
                      # Commit and push
                      git config user.name "ApplicationClaim"
                      git config user.email "applicationclaim@platform.local"
                      git add .
                      git commit -m "Add $SERVICE_NAME microservice ($LANGUAGE/$FRAMEWORK)
                      
                      - Implements CLAUDE.md Onion Architecture
                      - Follows 12-Factor App principles
                      - Includes TDD test structure with pytest
                      - Dependency injection ready
                      - FastAPI with health checks
                      - Multi-stage Dockerfile
                      - Poetry for dependency management"
                      git push
                      
                      echo "Microservice $SERVICE_NAME added to AppContainer $APP_CONTAINER successfully"
                    env:
                    - name: APP_CONTAINER
                      value: placeholder
                    - name: SERVICE_NAME
                      value: placeholder
                    - name: LANGUAGE
                      value: placeholder
                    - name: FRAMEWORK
                      value: placeholder
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-microservice-creator"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.language
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.framework
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[3].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-microservice-creator"

  # Add GitOps manifests for the new microservice
  - name: add-gitops-manifests
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: placeholder
              namespace: default
            spec:
              template:
                spec:
                  serviceAccountName: crossplane-github-provider
                  restartPolicy: OnFailure
                  containers:
                  - name: gitops-manifest-creator
                    image: alpine/git:latest
                    command:
                    - /bin/sh
                    - -c
                    - |
                      set -e
                      echo "Adding GitOps manifests for $SERVICE_NAME in $APP_CONTAINER-gitops..."
                      
                      TEMP_DIR="/tmp/gitops-$APP_CONTAINER"
                      mkdir -p $TEMP_DIR
                      cd $TEMP_DIR
                      
                      # Clone the GitOps repository
                      git clone https://github.com/socrates12345/$APP_CONTAINER-gitops.git .
                      
                      # Create manifests directory for the service
                      mkdir -p manifests/$SERVICE_NAME
                      cd manifests/$SERVICE_NAME
                      
                      # Create Knative Service manifest with cost optimization
                      cat > knative-service.yaml << EOF
                      apiVersion: serving.knative.dev/v1
                      kind: Service
                      metadata:
                        name: $SERVICE_NAME
                        namespace: $APP_CONTAINER
                        annotations:
                          # Cost optimization: Scale to zero when not in use
                          autoscaling.knative.dev/min-scale: "0"
                          autoscaling.knative.dev/max-scale: "5"
                          autoscaling.knative.dev/target: "50"
                          autoscaling.knative.dev/metric: "concurrency"
                          # Karpenter optimization
                          karpenter.sh/do-not-evict: "false"
                          cluster-autoscaler.kubernetes.io/safe-to-evict: "true"
                          # Internal only for cost savings
                          serving.knative.dev/visibility: "cluster-local"
                      spec:
                        template:
                          metadata:
                            annotations:
                              autoscaling.knative.dev/min-scale: "0"
                              autoscaling.knative.dev/max-scale: "5"
                              autoscaling.knative.dev/target: "50"
                              autoscaling.knative.dev/scale-to-zero-pod-retention-period: "30s"
                              # Queue proxy resource optimization
                              queue.sidecar.serving.knative.dev/cpu-resource-request: "25m"
                              queue.sidecar.serving.knative.dev/memory-resource-request: "50Mi"
                              queue.sidecar.serving.knative.dev/cpu-resource-limit: "100m"
                              queue.sidecar.serving.knative.dev/memory-resource-limit: "100Mi"
                          spec:
                            # Lower concurrency for better resource utilization
                            containerConcurrency: 50
                            # Shorter timeout for cost optimization
                            timeoutSeconds: 300
                            containers:
                            - image: docker.io/socrates12345/$SERVICE_NAME:latest
                              ports:
                              - containerPort: 8080
                                name: http1
                              env:
                              - name: APP_NAME
                                value: $SERVICE_NAME
                              - name: LOG_LEVEL
                                value: "INFO"
                              - name: PORT
                                value: "8080"
                              envFrom:
                              - configMapRef:
                                  name: $SERVICE_NAME-config
                                  optional: true
                              - secretRef:
                                  name: $SERVICE_NAME-postgres-secret
                                  optional: true
                              - secretRef:
                                  name: $SERVICE_NAME-redis-secret
                                  optional: true
                              # Health checks optimized for cold starts
                              livenessProbe:
                                httpGet:
                                  path: /health
                                  port: 8080
                                initialDelaySeconds: 15
                                periodSeconds: 15
                                timeoutSeconds: 5
                                failureThreshold: 3
                              readinessProbe:
                                httpGet:
                                  path: /health
                                  port: 8080
                                initialDelaySeconds: 5
                                periodSeconds: 10
                                timeoutSeconds: 3
                                successThreshold: 1
                                failureThreshold: 3
                              # Minimal resource requests for cost optimization
                              resources:
                                requests:
                                  cpu: 100m
                                  memory: 128Mi
                                limits:
                                  cpu: 500m
                                  memory: 256Mi
                              # Security context
                              securityContext:
                                allowPrivilegeEscalation: false
                                runAsNonRoot: true
                                runAsUser: 1001
                                capabilities:
                                  drop:
                                  - ALL
                                seccompProfile:
                                  type: RuntimeDefault
                      EOF
                      
                      # Create ConfigMap for environment variables
                      cat > configmap.yaml << EOF
                      apiVersion: v1
                      kind: ConfigMap
                      metadata:
                        name: $SERVICE_NAME-config
                        namespace: $APP_CONTAINER
                      data:
                        APP_ENV: "production"
                        SERVICE_NAME: "$SERVICE_NAME"
                      EOF
                      
                      # Add database config if needed
                      if [ "$DATABASE" = "postgres" ]; then
                        cat >> configmap.yaml << EOF
                        DATABASE_URL: "postgresql://\$DATABASE_USER:\$DATABASE_PASSWORD@$APP_CONTAINER-postgres-rw.$APP_CONTAINER.svc.cluster.local:5432/$SERVICE_NAME"
                      EOF
                      fi
                      
                      # Add cache config if needed  
                      if [ "$CACHE" = "redis" ]; then
                        cat >> configmap.yaml << EOF
                        REDIS_URL: "redis://:\$REDIS_PASSWORD@$APP_CONTAINER-redis-master.$APP_CONTAINER.svc.cluster.local:6379/0"
                      EOF
                      fi
                      
                      # Create OAM Component
                      cd ../../oam
                      cat > $SERVICE_NAME.yaml << EOF
                      apiVersion: core.oam.dev/v1beta1
                      kind: Component
                      metadata:
                        name: $SERVICE_NAME
                        namespace: $APP_CONTAINER
                        labels:
                          app.oam.dev/component: $SERVICE_NAME
                          app.oam.dev/name: $APP_CONTAINER
                      spec:
                        workload:
                          apiVersion: serving.knative.dev/v1
                          kind: Service
                          metadata:
                            name: $SERVICE_NAME
                          spec:
                            template:
                              spec:
                                containers:
                                - name: $SERVICE_NAME
                                  image: docker.io/socrates12345/$SERVICE_NAME:latest
                                  ports:
                                  - containerPort: 8080
                                  env:
                                  - name: APP_NAME
                                    value: $SERVICE_NAME
                        parameters:
                        - name: image
                          fieldPaths:
                          - "spec.template.spec.containers[0].image"
                        - name: replicas
                          fieldPaths:
                          - "metadata.annotations[autoscaling.knative.dev/minScale]"
                      EOF
                      
                      # Commit and push GitOps changes
                      cd ..
                      git config user.name "ApplicationClaim GitOps"
                      git config user.email "applicationclaim-gitops@platform.local"
                      git add .
                      git commit -m "Add GitOps manifests for $SERVICE_NAME microservice
                      
                      - Add Knative Service for $SERVICE_NAME
                      - Add ConfigMap for environment variables  
                      - Add OAM Component definition
                      - Configure autoscaling and health checks
                      - Ready for ArgoCD ApplicationSet deployment"
                      git push
                      
                      echo "GitOps manifests for $SERVICE_NAME added successfully"
                    env:
                    - name: APP_CONTAINER
                      value: placeholder
                    - name: SERVICE_NAME
                      value: placeholder
                    - name: DATABASE
                      value: placeholder
                    - name: CACHE
                      value: placeholder
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-gitops-creator"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.database
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.cache
      toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[3].value
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-gitops-creator"

  # PostgreSQL Database (conditional on spec.database=postgres)
  - name: postgres-database
    base:
      apiVersion: helm.crossplane.io/v1beta1
      kind: Release
      spec:
        forProvider:
          chart:
            name: postgresql
            repository: https://charts.bitnami.com/bitnami
            version: "13.2.24"
          namespace: placeholder
          skipCreateNamespace: false
          values:
            auth:
              enablePostgresUser: true
              postgresPassword: "placeholder"
              username: "placeholder"
              password: "placeholder"
              database: "placeholder"
            primary:
              persistence:
                enabled: true
                size: 10Gi
                storageClass: gp2
              resources:
                requests:
                  memory: 256Mi
                  cpu: 250m
                limits:
                  memory: 512Mi
                  cpu: 500m
              readinessProbe:
                enabled: true
                initialDelaySeconds: 30
                periodSeconds: 10
              livenessProbe:
                enabled: true
                initialDelaySeconds: 30
                periodSeconds: 10
            metrics:
              enabled: true
              serviceMonitor:
                enabled: false
            backup:
              enabled: false
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-postgres"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.auth.database
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.auth.username
    # Generate random passwords (in production, use External Secrets)
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.auth.postgresPassword
      transforms:
      - type: string
        string:
          fmt: "%s-postgres-admin-pass"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.auth.password
      transforms:
      - type: string
        string:
          fmt: "%s-user-pass"
    # Status patches for database connection info
    - type: ToCompositeFieldPath
      fromFieldPath: status.atProvider.state
      toFieldPath: status.infrastructure.database.ready
      transforms:
      - type: map
        map:
          "deployed": true
          "failed": false
      policy:
        fromFieldPath: Optional
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: status.infrastructure.database.endpoint
      transforms:
      - type: string
        string:
          fmt: "%s-postgresql.%s.svc.cluster.local:5432"
      policy:
        fromFieldPath: Optional
    # Only deploy if database is postgres
    - type: FromCompositeFieldPath
      fromFieldPath: spec.database
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "postgres": "true"
          "none": "false"

  # Redis Cache (conditional on spec.cache=redis)
  - name: redis-cache
    base:
      apiVersion: helm.crossplane.io/v1beta1
      kind: Release
      spec:
        forProvider:
          chart:
            name: redis
            repository: https://charts.bitnami.com/bitnami
            version: "18.4.0"
          namespace: placeholder
          skipCreateNamespace: false
          values:
            auth:
              enabled: true
              password: "placeholder"
            master:
              persistence:
                enabled: true
                size: 5Gi
                storageClass: gp2
              resources:
                requests:
                  memory: 128Mi
                  cpu: 100m
                limits:
                  memory: 256Mi
                  cpu: 200m
            replica:
              replicaCount: 1
              persistence:
                enabled: true
                size: 5Gi
                storageClass: gp2
              resources:
                requests:
                  memory: 128Mi
                  cpu: 100m
                limits:
                  memory: 256Mi
                  cpu: 200m
            metrics:
              enabled: true
              serviceMonitor:
                enabled: false
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-redis"
    # Generate random password (in production, use External Secrets)
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.values.auth.password
      transforms:
      - type: string
        string:
          fmt: "%s-redis-pass"
    # Status patches for cache connection info
    - type: ToCompositeFieldPath
      fromFieldPath: status.atProvider.state
      toFieldPath: status.infrastructure.cache.ready
      transforms:
      - type: map
        map:
          "deployed": true
          "failed": false
      policy:
        fromFieldPath: Optional
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: status.infrastructure.cache.endpoint
      transforms:
      - type: string
        string:
          fmt: "%s-redis-master.%s.svc.cluster.local:6379"
      policy:
        fromFieldPath: Optional
    # Only deploy if cache is redis
    - type: FromCompositeFieldPath
      fromFieldPath: spec.cache
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "redis": "true"
          "none": "false"

  # Database Secret (PostgreSQL credentials)
  - name: postgres-secret
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Secret
            metadata:
              name: placeholder
              namespace: placeholder
            type: Opaque
            data:
              # Base64 encoded values (in production, use External Secrets)
              DATABASE_URL: placeholder
              DB_HOST: placeholder
              DB_PORT: NTQzMg==  # 5432
              DB_NAME: placeholder
              DB_USER: placeholder
              DB_PASSWORD: placeholder
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-postgres-secret"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-postgres-secret"
    # Only create if database is postgres
    - type: FromCompositeFieldPath
      fromFieldPath: spec.database
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "postgres": "true"
          "none": "false"

  # Cache Secret (Redis credentials)
  - name: redis-secret
    base:
      apiVersion: kubernetes.crossplane.io/v1alpha1
      kind: Object
      spec:
        forProvider:
          manifest:
            apiVersion: v1
            kind: Secret
            metadata:
              name: placeholder
              namespace: placeholder
            type: Opaque
            data:
              # Base64 encoded values (in production, use External Secrets)
              REDIS_URL: placeholder
              REDIS_HOST: placeholder
              REDIS_PORT: NjM3OQ==  # 6379
              REDIS_PASSWORD: placeholder
        providerConfigRef:
          name: kubernetes-provider
    patches:
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: spec.forProvider.manifest.metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-redis-secret"
    - type: FromCompositeFieldPath
      fromFieldPath: spec.appContainer
      toFieldPath: spec.forProvider.manifest.metadata.namespace
    - type: FromCompositeFieldPath
      fromFieldPath: spec.name
      toFieldPath: metadata.name
      transforms:
      - type: string
        string:
          fmt: "%s-redis-secret"
    # Only create if cache is redis
    - type: FromCompositeFieldPath
      fromFieldPath: spec.cache
      toFieldPath: metadata.labels["crossplane.io/enable"]
      transforms:
      - type: map
        map:
          "redis": "true"
          "none": "false"