# Ping-Pong Realtime Service Template
# This is a template application that demonstrates how to build services
# that consume realtime platform capabilities for MQTT → Kafka → Stream Processing → WebSocket

apiVersion: core.oam.dev/v1beta1
kind: Application
metadata:
  name: ping-pong-realtime-service
  namespace: default
  annotations:
    oam.dev/description: "Template application demonstrating full realtime platform integration"
    oam.dev/template: "true"
spec:
  components:
  
  # Realtime Platform Infrastructure
  - name: ping-pong-platform
    type: webservice
    properties:
      name: ping-pong-platform
      language: python
      framework: fastapi
      image: "socrates12345/ping-pong-platform:latest"
      realtime: "ping-pong-streaming"  # References the realtime platform component
      # The realtime parameter automatically injects these secrets:
      # - ping-pong-streaming-mqtt-secret (MQTT broker connection)
      # - ping-pong-streaming-kafka-secret (Kafka connection)
      # - ping-pong-streaming-db-secret (Database connection)
      # - ping-pong-streaming-metabase-secret (Analytics dashboard)
      # - ping-pong-streaming-lenses-secret (Stream processing UI)
      websocket: true  # Enable WebSocket endpoints
      streaming:
        enabled: true
        topics: 
          - "ping_topic"
          - "pong_topic"
        consumerGroup: "ping-pong-service"
        autoOffsetReset: "latest"
      environment:
        # Service-specific configuration
        SERVICE_NAME: "ping-pong-demo"
        PING_MQTT_TOPIC: "ping/messages"
        PONG_WEBSOCKET_ENDPOINT: "/ws/pong"
        STREAM_PROCESSING_ENABLED: "true"
        LOG_LEVEL: "INFO"
      exposeApi: true
    traits:
    - type: ingress
      properties:
        domain: ping-pong.demo.local
        path: "/"

  # Data Generator Service (for testing)
  - name: ping-data-generator
    type: webservice
    properties:
      name: ping-data-generator
      language: python
      framework: fastapi
      image: "socrates12345/ping-data-generator:latest"
      realtime: "ping-pong-streaming"  # Uses same realtime platform
      environment:
        MQTT_TOPIC: "ping/messages"
        MESSAGE_INTERVAL: "5"  # Send ping every 5 seconds
        SERVICE_TYPE: "DATA_GENERATOR"
      exposeApi: true
    traits:
    - type: ingress
      properties:
        domain: ping-generator.demo.local
        path: "/api"

---
# Example ApplicationClaim for the Ping-Pong Service
apiVersion: platform.example.org/v1alpha1
kind: ApplicationClaim
metadata:
  name: ping-pong-demo
  namespace: default
spec:
  name: ping-pong-service
  language: python
  framework: fastapi
  realtime: "ping-pong-streaming"  # This triggers realtime platform provisioning
  websocket: true
  streaming:
    enabled: true
    topics:
      - "ping_topic"
      - "pong_topic"
    consumerGroup: "ping-pong-group"
  environment:
    PING_MQTT_TOPIC: "ping/messages"
    PONG_WEBSOCKET_PATH: "/ws/pong"

---
# Avro Schema Definitions for Ping-Pong Messages
apiVersion: v1
kind: ConfigMap
metadata:
  name: ping-pong-schemas
  namespace: default
data:
  ping-message.avsc: |
    {
      "type": "record",
      "name": "PingMessage",
      "namespace": "com.example.pingpong",
      "doc": "Schema for ping messages in the ping-pong demo",
      "fields": [
        {
          "name": "messageId",
          "type": "string",
          "doc": "Unique identifier for the message"
        },
        {
          "name": "content",
          "type": "string",
          "doc": "The ping message content"
        },
        {
          "name": "timestamp",
          "type": "long",
          "doc": "Unix timestamp when the message was created"
        },
        {
          "name": "source",
          "type": "string",
          "default": "ping-generator",
          "doc": "Source of the ping message"
        }
      ]
    }
  
  pong-message.avsc: |
    {
      "type": "record", 
      "name": "PongMessage",
      "namespace": "com.example.pingpong",
      "doc": "Schema for pong response messages",
      "fields": [
        {
          "name": "messageId",
          "type": "string",
          "doc": "Original message ID from the ping"
        },
        {
          "name": "originalContent", 
          "type": "string",
          "doc": "Original ping message content"
        },
        {
          "name": "response",
          "type": "string",
          "doc": "The pong response content"
        },
        {
          "name": "pingTimestamp",
          "type": "long",
          "doc": "Original ping timestamp"
        },
        {
          "name": "pongTimestamp",
          "type": "long", 
          "doc": "Timestamp when the pong was generated"
        },
        {
          "name": "processingTimeMs",
          "type": "long",
          "doc": "Time taken to process the ping into pong (milliseconds)"
        }
      ]
    }

---
# Stream Processing Configuration for Ping-Pong
apiVersion: v1
kind: ConfigMap
metadata:
  name: ping-pong-stream-queries
  namespace: default
data:
  ping-to-pong-transformation.sql: |
    -- Transform ping messages to pong responses
    INSERT INTO pong_topic
    STORE KEY AS STRING VALUE AS AVRO
    SELECT STREAM
        _value.messageId AS _key,
        STRUCT(
          messageId := _value.messageId,
          originalContent := _value.content,
          response := CONCAT('pong: ', _value.content),
          pingTimestamp := _value.timestamp,
          pongTimestamp := UNIX_TIMESTAMP() * 1000,
          processingTimeMs := (UNIX_TIMESTAMP() * 1000) - _value.timestamp
        ) AS _value
    FROM ping_topic;

  ping-analytics.sql: |
    -- Create analytics stream for message processing metrics
    INSERT INTO ping_analytics_topic
    STORE KEY AS STRING VALUE AS AVRO
    SELECT STREAM
        _value.messageId AS _key,
        STRUCT(
          messageId := _value.messageId,
          processingTimeMs := _value.processingTimeMs,
          timestamp := _value.pongTimestamp,
          messageCount := COUNT(*) OVER (RANGE INTERVAL '1' MINUTE PRECEDING)
        ) AS _value
    FROM pong_topic
    WHERE _value.processingTimeMs > 0;

---
# Kafka Topics Configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: ping-pong-kafka-topics
  namespace: default
data:
  topics.yaml: |
    topics:
      - name: ping_topic
        partitions: 3
        replicationFactor: 1
        config:
          retention.ms: 86400000  # 24 hours
          cleanup.policy: delete
          max.message.bytes: 1000000
        schema:
          key: string
          value: com.example.pingpong.PingMessage
      
      - name: pong_topic
        partitions: 3
        replicationFactor: 1
        config:
          retention.ms: 86400000  # 24 hours
          cleanup.policy: delete
          max.message.bytes: 1000000
        schema:
          key: string
          value: com.example.pingpong.PongMessage
      
      - name: ping_analytics_topic
        partitions: 1
        replicationFactor: 1
        config:
          retention.ms: 604800000  # 7 days
          cleanup.policy: delete
          segment.ms: 3600000  # 1 hour segments

---
# MQTT Connector Configuration for Ping-Pong
apiVersion: v1
kind: ConfigMap
metadata:
  name: ping-pong-connectors
  namespace: default
data:
  mqtt-source-connector.json: |
    {
      "name": "ping-mqtt-source",
      "config": {
        "connector.class": "io.lenses.streamreactor.connect.mqtt.source.MqttSourceConnector",
        "tasks.max": "1",
        "connect.mqtt.hosts": "tcp://ping-pong-streaming-mqtt:1883",
        "connect.mqtt.username": "realtime-user",
        "connect.mqtt.password": "realtime-pass",
        "connect.mqtt.kcql": "INSERT INTO ping_topic SELECT messageId, content, timestamp, source FROM ping/messages WITHKEY(messageId)",
        "connect.mqtt.service.quality": "1",
        "connect.mqtt.timeout": "1000",
        "connect.mqtt.clean": "true",
        "connect.mqtt.keep.alive": "1000",
        "errors.tolerance": "all",
        "errors.log.enable": "true",
        "errors.log.include.messages": "true"
      }
    }

---
# Example Python FastAPI Service Code Template
apiVersion: v1
kind: ConfigMap
metadata:
  name: ping-pong-service-template
  namespace: default
data:
  main.py: |
    """
    Ping-Pong Realtime Service Template
    
    This FastAPI service demonstrates how to:
    1. Consume MQTT messages via Kafka
    2. Process messages with stream processing
    3. Expose real-time data via WebSocket
    4. Connect to realtime platform components
    """
    import asyncio
    import json
    import logging
    import os
    from datetime import datetime
    from typing import Dict, List
    
    import websockets
    from fastapi import FastAPI, WebSocket, WebSocketDisconnect
    from fastapi.responses import HTMLResponse
    from aiokafka import AIOKafkaConsumer, AIOKafkaProducer
    from pydantic import BaseModel
    
    # Environment variables automatically injected by realtime platform
    KAFKA_BOOTSTRAP_SERVERS = os.getenv("KAFKA_BOOTSTRAP_SERVERS", "localhost:9092")
    KAFKA_SCHEMA_REGISTRY_URL = os.getenv("KAFKA_SCHEMA_REGISTRY_URL", "http://localhost:8081")
    MQTT_HOST = os.getenv("MQTT_HOST", "localhost")
    MQTT_PORT = int(os.getenv("MQTT_PORT", "1883"))
    MQTT_USER = os.getenv("MQTT_USER", "realtime-user")
    MQTT_PASSWORD = os.getenv("MQTT_PASSWORD", "realtime-pass")
    
    # Service configuration
    PONG_TOPIC = "pong_topic"
    WEBSOCKET_PATH = "/ws/pong"
    
    app = FastAPI(
        title="Ping-Pong Realtime Service",
        description="Template service demonstrating realtime platform integration",
        version="1.0.0"
    )
    
    # WebSocket connection manager
    class ConnectionManager:
        def __init__(self):
            self.active_connections: List[WebSocket] = []
        
        async def connect(self, websocket: WebSocket):
            await websocket.accept()
            self.active_connections.append(websocket)
            logging.info(f"WebSocket connected. Total connections: {len(self.active_connections)}")
        
        def disconnect(self, websocket: WebSocket):
            self.active_connections.remove(websocket)
            logging.info(f"WebSocket disconnected. Total connections: {len(self.active_connections)}")
        
        async def broadcast(self, message: dict):
            if self.active_connections:
                message_str = json.dumps(message)
                disconnected = []
                for connection in self.active_connections:
                    try:
                        await connection.send_text(message_str)
                    except Exception as e:
                        logging.error(f"Error sending to WebSocket: {e}")
                        disconnected.append(connection)
                
                # Clean up disconnected connections
                for conn in disconnected:
                    if conn in self.active_connections:
                        self.active_connections.remove(conn)
    
    manager = ConnectionManager()
    
    # Pydantic models
    class PongMessage(BaseModel):
        messageId: str
        originalContent: str
        response: str
        pingTimestamp: int
        pongTimestamp: int
        processingTimeMs: int
    
    class ServiceStatus(BaseModel):
        service: str = "ping-pong-realtime"
        status: str = "running"
        timestamp: str
        connections: int
        kafka_connected: bool = True
        mqtt_connected: bool = True
        realtime_platform: str = "ping-pong-streaming"
    
    # Kafka consumer for pong messages
    async def kafka_consumer():
        consumer = AIOKafkaConsumer(
            PONG_TOPIC,
            bootstrap_servers=KAFKA_BOOTSTRAP_SERVERS,
            group_id="ping-pong-websocket-group",
            auto_offset_reset="latest"
        )
        
        await consumer.start()
        logging.info(f"Kafka consumer started for topic: {PONG_TOPIC}")
        
        try:
            async for message in consumer:
                try:
                    # Decode the Avro message (simplified JSON for demo)
                    pong_data = json.loads(message.value.decode('utf-8'))
                    
                    # Create structured message for WebSocket clients
                    websocket_message = {
                        "type": "pong",
                        "data": pong_data,
                        "timestamp": datetime.utcnow().isoformat(),
                        "topic": PONG_TOPIC
                    }
                    
                    # Broadcast to all connected WebSocket clients
                    await manager.broadcast(websocket_message)
                    logging.info(f"Broadcasted pong message: {pong_data.get('messageId', 'unknown')}")
                    
                except Exception as e:
                    logging.error(f"Error processing Kafka message: {e}")
                    
        except Exception as e:
            logging.error(f"Kafka consumer error: {e}")
        finally:
            await consumer.stop()
    
    # Background task to start Kafka consumer
    @app.on_event("startup")
    async def startup_event():
        asyncio.create_task(kafka_consumer())
        logging.info("Ping-Pong Realtime Service started")
    
    # Health check endpoint
    @app.get("/health")
    async def health():
        return {"status": "healthy", "service": "ping-pong-realtime"}
    
    # Service status endpoint
    @app.get("/", response_model=ServiceStatus)
    async def get_status():
        return ServiceStatus(
            timestamp=datetime.utcnow().isoformat(),
            connections=len(manager.active_connections)
        )
    
    # WebSocket endpoint for real-time pong messages
    @app.websocket(WEBSOCKET_PATH)
    async def websocket_endpoint(websocket: WebSocket):
        await manager.connect(websocket)
        try:
            while True:
                # Keep connection alive and handle client messages
                data = await websocket.receive_text()
                # Echo back any messages (optional)
                await websocket.send_text(f"Echo: {data}")
        except WebSocketDisconnect:
            manager.disconnect(websocket)
    
    # Demo HTML page to test WebSocket connection
    @app.get("/demo", response_class=HTMLResponse)
    async def demo_page():
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <title>Ping-Pong Realtime Demo</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 40px; }
                #messages { border: 1px solid #ccc; height: 400px; overflow-y: scroll; padding: 10px; }
                .message { margin: 5px 0; padding: 5px; background: #f0f0f0; border-radius: 3px; }
                .pong { background: #e8f5e8; }
                button { padding: 10px 20px; margin: 5px; }
            </style>
        </head>
        <body>
            <h1>Ping-Pong Realtime Demo</h1>
            <p>This page demonstrates real-time message streaming from MQTT → Kafka → WebSocket</p>
            
            <button onclick="connect()">Connect</button>
            <button onclick="disconnect()">Disconnect</button>
            <span id="status">Disconnected</span>
            
            <div id="messages"></div>
            
            <script>
                let ws = null;
                
                function connect() {
                    ws = new WebSocket(`ws://${window.location.host}/ws/pong`);
                    
                    ws.onopen = function() {
                        document.getElementById('status').textContent = 'Connected';
                        addMessage('Connected to WebSocket', 'system');
                    };
                    
                    ws.onmessage = function(event) {
                        const data = JSON.parse(event.data);
                        if (data.type === 'pong') {
                            addMessage(`Pong: ${data.data.response} (Processing: ${data.data.processingTimeMs}ms)`, 'pong');
                        }
                    };
                    
                    ws.onclose = function() {
                        document.getElementById('status').textContent = 'Disconnected';
                        addMessage('WebSocket disconnected', 'system');
                    };
                }
                
                function disconnect() {
                    if (ws) {
                        ws.close();
                    }
                }
                
                function addMessage(text, type) {
                    const messages = document.getElementById('messages');
                    const div = document.createElement('div');
                    div.className = `message ${type}`;
                    div.textContent = `${new Date().toLocaleTimeString()}: ${text}`;
                    messages.appendChild(div);
                    messages.scrollTop = messages.scrollHeight;
                }
            </script>
        </body>
        </html>
        """

  data_generator.py: |
    """
    Ping Data Generator
    
    Generates ping messages and publishes them to MQTT for testing the ping-pong flow
    """
    import asyncio
    import json
    import logging
    import os
    import uuid
    from datetime import datetime
    from fastapi import FastAPI
    import paho.mqtt.client as mqtt
    
    # Environment variables from realtime platform
    MQTT_HOST = os.getenv("MQTT_HOST", "localhost")
    MQTT_PORT = int(os.getenv("MQTT_PORT", "1883"))
    MQTT_USER = os.getenv("MQTT_USER", "realtime-user")
    MQTT_PASSWORD = os.getenv("MQTT_PASSWORD", "realtime-pass")
    MQTT_TOPIC = os.getenv("MQTT_TOPIC", "ping/messages")
    MESSAGE_INTERVAL = int(os.getenv("MESSAGE_INTERVAL", "5"))
    
    app = FastAPI(title="Ping Data Generator", version="1.0.0")
    
    # MQTT client setup
    mqtt_client = mqtt.Client()
    mqtt_client.username_pw_set(MQTT_USER, MQTT_PASSWORD)
    
    async def generate_ping_messages():
        """Generate and publish ping messages to MQTT"""
        message_count = 0
        
        while True:
            try:
                message_count += 1
                ping_message = {
                    "messageId": str(uuid.uuid4()),
                    "content": f"Hello from ping #{message_count}",
                    "timestamp": int(datetime.utcnow().timestamp() * 1000),
                    "source": "ping-generator"
                }
                
                # Publish to MQTT
                mqtt_client.publish(MQTT_TOPIC, json.dumps(ping_message))
                logging.info(f"Published ping message #{message_count}")
                
                await asyncio.sleep(MESSAGE_INTERVAL)
                
            except Exception as e:
                logging.error(f"Error generating ping message: {e}")
                await asyncio.sleep(MESSAGE_INTERVAL)
    
    @app.on_event("startup")
    async def startup():
        # Connect to MQTT broker
        mqtt_client.connect(MQTT_HOST, MQTT_PORT, 60)
        mqtt_client.loop_start()
        
        # Start message generation
        asyncio.create_task(generate_ping_messages())
        logging.info("Ping data generator started")
    
    @app.get("/health")
    async def health():
        return {"status": "healthy", "service": "ping-data-generator"}
    
    @app.get("/")
    async def status():
        return {
            "service": "ping-data-generator",
            "mqtt_host": MQTT_HOST,
            "mqtt_topic": MQTT_TOPIC,
            "interval_seconds": MESSAGE_INTERVAL
        }

  requirements.txt: |
    fastapi>=0.104.0
    uvicorn>=0.24.0
    aiokafka>=0.8.10
    paho-mqtt>=1.6.1
    websockets>=11.0
    pydantic>=2.0.0

  Dockerfile: |
    FROM python:3.11-slim
    
    WORKDIR /app
    
    COPY requirements.txt .
    RUN pip install --no-cache-dir -r requirements.txt
    
    COPY . .
    
    EXPOSE 8080
    
    CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8080"]