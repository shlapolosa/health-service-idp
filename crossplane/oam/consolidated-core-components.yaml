# Core OAM Component Definitions
# This file contains only the components that don't have standalone files
# Components included: webservice, kafka, redis, mongodb, application-infrastructure, vcluster, neon-postgres, clickhouse

---
# Enhanced webservice ComponentDefinition with automatic infrastructure bootstrap
apiVersion: core.oam.dev/v1beta1
kind: ComponentDefinition
metadata:
  name: webservice
  annotations:
    definition.oam.dev/description: "Enhanced webservice with automatic infrastructure bootstrap via embedded workflows"
spec:
  workload:
    definition:
      apiVersion: serving.knative.dev/v1
      kind: Service
    type: services.serving.knative.dev
  schematic:
    cue:
      template: |
        output: {
          apiVersion: "serving.knative.dev/v1"
          kind: "Service"
          metadata: {
            name: context.name
            namespace: context.namespace
            labels: {
              "app.kubernetes.io/name": context.name
              "app.kubernetes.io/component": "web-service"
              "app.kubernetes.io/managed-by": "kubevela"
              if parameter.enableGraphQLFederation != _|_ {
                if parameter.enableGraphQLFederation == true {
                  "graphql.federation/enabled": "true"
                }
              }
            }
            annotations: {
              // Multi-cluster deployment support
              if parameter.targetEnvironment != _|_ {
                "app.oam.dev/cluster": parameter.targetEnvironment
              }
              if parameter.language != _|_ {
                "webservice.oam.dev/bootstrap": "true"
                "webservice.oam.dev/language": parameter.language
                "webservice.oam.dev/framework": parameter.framework
                if parameter.source != _|_ {
                  "webservice.oam.dev/source": parameter.source
                }
                if parameter.source == _|_ {
                  "webservice.oam.dev/source": "api-driven"
                }
              }
              if parameter.realtime != _|_ {
                "realtime.platform.example.org/integration": parameter.realtime
                "webservice.oam.dev/secret-discovery": "enabled"
                "webservice.oam.dev/secret-pattern": parameter.realtime + "-*-secret"
              }
              if parameter.enableGraphQLFederation != _|_ {
                if parameter.enableGraphQLFederation == true {
                  "graphql.federation/enabled": "true"
                  if parameter.openApiPath != _|_ {
                    "graphql.federation/openapi-path": parameter.openApiPath
                  }
                  if parameter.apiVersion != _|_ {
                    "graphql.federation/api-version": parameter.apiVersion
                  }
                }
              }
            }
          }
          spec: {
            template: {
              metadata: {
                annotations: {
                  "autoscaling.knative.dev/minScale": "0"
                  "autoscaling.knative.dev/maxScale": "10"
                  "run.googleapis.com/execution-environment": "gen2"
                }
                labels: {
                  "app.kubernetes.io/name": context.name
                  "app.kubernetes.io/version": parameter.version
                }
              }
              spec: {
                serviceAccountName: "knative-docker-sa"
                // Add image pull secrets based on registry
                if parameter.registrySecret != _|_ {
                  imagePullSecrets: [{
                    name: parameter.registrySecret
                  }]
                }
                if parameter.registry != _|_ {
                  if parameter.registry == "acr" {
                    imagePullSecrets: [{
                      name: "acr-credentials"
                    }]
                  }
                }
                containers: [{
                  // Use the image parameter directly (always provided)
                  image: parameter.image
                  ports: [{
                    containerPort: parameter.port
                    name: "http1"
                  }]
                  resources: {
                    limits: {
                      cpu: parameter.resources.cpu
                      memory: parameter.resources.memory
                    }
                    requests: {
                      cpu: "100m"
                      memory: "128Mi"
                    }
                  }
                  env: [
                    for k, v in parameter.environment {
                      name: k
                      value: v
                    }
                  ] + [
                    if parameter.realtime != _|_ {
                      {
                        name: "REALTIME_PLATFORM_NAME"
                        value: parameter.realtime
                      }
                    },
                    if parameter.realtime != _|_ {
                      {
                        name: "REALTIME_INTEGRATION_ENABLED"
                        value: "true"
                      }
                    },
                    if parameter.realtime != _|_ {
                      {
                        name: "WEBSERVICE_NAME"
                        value: context.name
                      }
                    }
                  ]
                  if parameter.envFrom != _|_ || parameter.realtime != _|_ {
                    envFrom: [
                      if parameter.envFrom != _|_ {
                        for envRef in parameter.envFrom {
                          envRef
                        }
                      }
                    ] + [
                      if parameter.realtime != _|_ {
                        {
                          secretRef: {
                            name: parameter.realtime + "-kafka-secret"
                            optional: true
                          }
                        }
                      },
                      if parameter.realtime != _|_ {
                        {
                          secretRef: {
                            name: parameter.realtime + "-mqtt-secret" 
                            optional: true
                          }
                        }
                      },
                      if parameter.realtime != _|_ {
                        {
                          secretRef: {
                            name: parameter.realtime + "-db-secret"
                            optional: true
                          }
                        }
                      },
                      if parameter.realtime != _|_ {
                        {
                          secretRef: {
                            name: parameter.realtime + "-metabase-secret"
                            optional: true
                          }
                        }
                      },
                      if parameter.realtime != _|_ {
                        {
                          secretRef: {
                            name: parameter.realtime + "-lenses-secret"
                            optional: true
                          }
                        }
                      }
                    ]
                  }
                  // Health checks for robust deployment
                  livenessProbe: {
                    httpGet: {
                      path: parameter.healthPath
                      port: parameter.port
                    }
                    initialDelaySeconds: 30
                    periodSeconds: 10
                  }
                  readinessProbe: {
                    httpGet: {
                      path: parameter.healthPath
                      port: parameter.port
                    }
                    initialDelaySeconds: 5
                    periodSeconds: 5
                  }
                }]
              }
            }
          }
        }
        
        // Secondary Outputs: Infrastructure Bootstrap via Argo Workflow (when language specified)
        if parameter.language != _|_ {
          outputs: {
            // Create Job to trigger Argo Workflow for microservice creation
            "workflow-trigger": {
              apiVersion: "batch/v1"
              kind: "Job"
              metadata: {
                name: context.name + "-workflow-trigger"
                namespace: context.namespace
                labels: {
                  "app.kubernetes.io/name": context.name
                  "app.kubernetes.io/component": "workflow-trigger"
                  "app.kubernetes.io/managed-by": "kubevela"
                }
                annotations: {
                  "webservice.oam.dev/trigger-type": "argo-workflow"
                  "webservice.oam.dev/workflow-template": "microservice-standard-contract"
                  if parameter.source != _|_ {
                    "webservice.oam.dev/source": parameter.source
                  }
                  if parameter.source == _|_ {
                    "webservice.oam.dev/source": "OAM-driven"
                  }
                }
              }
              spec: {
                template: {
                  spec: {
                    serviceAccountName: "argo-workflows-client"
                    restartPolicy: "Never"
                    volumes: []
                    containers: [{
                      name: "workflow-trigger"
                      image: "curlimages/curl:latest"
                      command: ["/bin/sh", "-c"]
                      volumeMounts: []
                      args: [
                        "echo 'ðŸš€ Triggering Argo Workflow for microservice: " + context.name + "'\n" +
                        "cat > /tmp/workflow.json << 'WORKFLOW_EOF'\n" +
                        "{\n" +
                        "  \"namespace\": \"argo\",\n" +
                        "  \"serverDryRun\": false,\n" +
                        "  \"workflow\": {\n" +
                        "    \"metadata\": {\n" +
                        "      \"generateName\": \"microservice-creation-\",\n" +
                        "      \"namespace\": \"argo\",\n" +
                        "      \"labels\": {\n" +
                        "        \"created-by\": \"oam-componentdefinition\",\n" +
                        "        \"microservice-name\": \"" + context.name + "\",\n" +
                        "        \"source\": \"" + (*"oam-driven" | parameter.source) + "\"\n" +
                        "      }\n" +
                        "    },\n" +
                        "    \"spec\": {\n" +
                        "      \"workflowTemplateRef\": {\n" +
                        "        \"name\": \"microservice-standard-contract\"\n" +
                        "      },\n" +
                        "      \"arguments\": {\n" +
                        "        \"parameters\": [\n" +
                        "          {\"name\": \"resource-name\", \"value\": \"" + context.name + "\"},\n" +
                        "          {\"name\": \"resource-type\", \"value\": \"microservice\"},\n" +
                        "          {\"name\": \"namespace\", \"value\": \"" + context.namespace + "\"},\n" +
                        "          {\"name\": \"user\", \"value\": \"oam-system\"},\n" +
                        "          {\"name\": \"description\", \"value\": \"OAM-driven microservice via ComponentDefinition\"},\n" +
                        "          {\"name\": \"github-org\", \"value\": \"shlapolosa\"},\n" +
                        "          {\"name\": \"docker-registry\", \"value\": \"docker.io/socrates12345\"},\n" +
                        "          {\"name\": \"slack-channel\", \"value\": \"#oam-notifications\"},\n" +
                        "          {\"name\": \"slack-user-id\", \"value\": \"OAM\"},\n" +
                        "          {\"name\": \"bootstrap-source\", \"value\": \"OAM-driven\"},\n" +
                        "          {\"name\": \"security-enabled\", \"value\": \"true\"},\n" +
                        "          {\"name\": \"observability-enabled\", \"value\": \"true\"},\n" +
                        "          {\"name\": \"backup-enabled\", \"value\": \"false\"},\n" +
                        "          {\"name\": \"environment-tier\", \"value\": \"development\"},\n" +
                        "          {\"name\": \"auto-create-dependencies\", \"value\": \"true\"},\n" +
                        "          {\"name\": \"resource-size\", \"value\": \"medium\"},\n" +
                        "          {\"name\": \"microservice-language\", \"value\": \"" + parameter.language + "\"},\n" +
                        "          {\"name\": \"microservice-framework\", \"value\": \"" + parameter.framework + "\"},\n" +
                        "          {\"name\": \"microservice-database\", \"value\": \"" + (*parameter.database | "none") + "\"},\n" +
                        "          {\"name\": \"microservice-cache\", \"value\": \"" + (*parameter.cache | "none") + "\"},\n" +
                        "          {\"name\": \"microservice-realtime\", \"value\": \"" + (*parameter.realtime | "") + "\"},\n" +
                        "          {\"name\": \"microservice-expose-api\", \"value\": \"false\"},\n" +
                        "          {\"name\": \"target-vcluster\", \"value\": \"\"},\n" +
                        "          {\"name\": \"parent-appcontainer\", \"value\": \"" + (*parameter.repository | "") + "\"},\n" +
                        "          {\"name\": \"repository-name\", \"value\": \"" + (*parameter.repository | "") + "\"}\n" +
                        "        ]\n" +
                        "      }\n" +
                        "    }\n" +
                        "  }\n" +
                        "}\n" +
                        "WORKFLOW_EOF\n" +
                        "echo 'ðŸ“‹ Workflow JSON created, submitting to Argo...'\n" +
                        "cat /tmp/workflow.json\n" +
                        "RESPONSE=$(curl -s -w 'HTTPSTATUS:%{http_code}' -X POST -H 'Content-Type: application/json' -H 'Accept: application/json' -d @/tmp/workflow.json http://argo-server.argo.svc.cluster.local:2746/api/v1/workflows/argo)\n" +
                        "HTTP_STATUS=$(echo $RESPONSE | tr -d '\\n' | sed -e 's/.*HTTPSTATUS://')\n" +
                        "BODY=$(echo $RESPONSE | sed -e 's/HTTPSTATUS:.*//g')\n" +
                        "echo 'ðŸ“Š HTTP Status:' $HTTP_STATUS\n" +
                        "echo 'ðŸ“„ Response:' $BODY\n" +
                        "if [ \"$HTTP_STATUS\" -eq 200 ] || [ \"$HTTP_STATUS\" -eq 201 ]; then\n" +
                        "  echo 'âœ… Workflow submission successful!'\n" +
                        "  echo \"$BODY\" | grep -o '\"name\":\"[^\"]*\"' | head -1\n" +
                        "else\n" +
                        "  echo 'âŒ Workflow submission failed with status:' $HTTP_STATUS\n" +
                        "  echo 'Response:' $BODY\n" +
                        "  exit 1\n" +
                        "fi"
                      ]
                    }]
                  }
                }
              }
            }
          }
        }
        
        parameter: {
          // Required Parameters - Support both old and new style
          image: string  // Full image path for backward compatibility
          
          // New multi-registry parameters
          imageName?: string  // Image name without registry (e.g., "slack-api-server")
          imageTag?: *"latest" | string  // Image tag
          registry?: "dockerhub" | "acr" | "custom"  // Registry selection
          customRegistry?: string  // Custom registry URL if registry == "custom"
          registrySecret?: string  // Secret name for registry authentication
          
          port: *8080 | int
          version: *"latest" | string
          healthPath: *"/health" | string
          resources: *{
            cpu: "500m"
            memory: "512Mi"
          } | {
            cpu?: string
            memory?: string
          }
          environment: *{} | {[string]: string}
          envFrom?: [...{
            secretRef: {
              name: string
            }
          }]
          language?: string
          framework?: string
          source?: string
          realtime?: string
          repository?: string
          targetEnvironment?: string  // vCluster deployment target
          
          // GraphQL Federation Support
          enableGraphQLFederation?: bool  // Mark service for GraphQL federation
          openApiPath?: string           // Custom OpenAPI spec path (e.g., "/api/v1/openapi.json")
          apiVersion?: string            // API version for GraphQL federation (e.g., "v1", "v2")
          
          // Optional database and cache settings
          database?: string
          cache?: string
        }

---
# Native Kafka ComponentDefinition (Crossplane-managed via Helm)
apiVersion: core.oam.dev/v1beta1
kind: ComponentDefinition
metadata:
  name: kafka
  annotations:
    definition.oam.dev/description: "Native Kafka deployment via Helm (Strimzi) with Crossplane-managed lifecycle"
spec:
  workload:
    definition:
      apiVersion: helm.crossplane.io/v1beta1
      kind: Release
    type: releases.helm.crossplane.io
  schematic:
    cue:
      template: |
        output: {
          apiVersion: "helm.crossplane.io/v1beta1"
          kind: "Release"
          metadata: {
            name: context.name
            namespace: "crossplane-system"
          }
          spec: {
            forProvider: {
              chart: {
                name: "strimzi-kafka-operator"
                repository: "https://strimzi.io/charts/"
                version: "0.35.0"
              }
              namespace: context.namespace
              values: {
                kafka: {
                  replicas: parameter.replicas
                  storage: {
                    size: parameter.storageSize
                  }
                  config: {
                    "offsets.topic.replication.factor": parameter.replicas
                    "transaction.state.log.replication.factor": parameter.replicas
                    "transaction.state.log.min.isr": 2
                  }
                }
                zookeeper: {
                  replicas: 3
                  storage: {
                    size: "10Gi"
                  }
                }
              }
            }
          }
        }
        
        parameter: {
          replicas: *3 | int
          storageSize: *"100Gi" | string
        }

---
# Native Redis ComponentDefinition (Crossplane-managed via Helm)
apiVersion: core.oam.dev/v1beta1
kind: ComponentDefinition
metadata:
  name: redis
  annotations:
    definition.oam.dev/description: "Native Redis deployment via Helm with Crossplane-managed lifecycle"
spec:
  workload:
    definition:
      apiVersion: helm.crossplane.io/v1beta1
      kind: Release
    type: releases.helm.crossplane.io
  schematic:
    cue:
      template: |
        output: {
          apiVersion: "helm.crossplane.io/v1beta1"
          kind: "Release"
          metadata: {
            name: context.name
            namespace: "crossplane-system"
          }
          spec: {
            forProvider: {
              chart: {
                name: "redis"
                repository: "https://charts.bitnami.com/bitnami"
                version: "17.11.3"
              }
              namespace: context.namespace
              values: {
                auth: {
                  enabled: parameter.authEnabled
                  password: parameter.password
                }
                architecture: parameter.architecture
                master: {
                  persistence: {
                    enabled: parameter.persistenceEnabled
                    size: parameter.storageSize
                  }
                }
                replica: {
                  replicaCount: parameter.replicaCount
                  persistence: {
                    enabled: parameter.persistenceEnabled
                    size: parameter.storageSize
                  }
                }
                metrics: {
                  enabled: parameter.metricsEnabled
                }
              }
            }
          }
        }
        
        parameter: {
          authEnabled: *true | bool
          password: *"redis-password" | string
          architecture: *"replication" | "standalone" | "replication" | "sentinel"
          persistenceEnabled: *true | bool
          storageSize: *"8Gi" | string
          replicaCount: *2 | int
          metricsEnabled: *true | bool
        }

---
# Native MongoDB ComponentDefinition (Crossplane-managed via Helm)
apiVersion: core.oam.dev/v1beta1
kind: ComponentDefinition
metadata:
  name: mongodb
  annotations:
    definition.oam.dev/description: "Native MongoDB deployment via Helm with Crossplane-managed lifecycle"
spec:
  workload:
    definition:
      apiVersion: helm.crossplane.io/v1beta1
      kind: Release
    type: releases.helm.crossplane.io
  schematic:
    cue:
      template: |
        output: {
          apiVersion: "helm.crossplane.io/v1beta1"
          kind: "Release"
          metadata: {
            name: context.name
            namespace: "crossplane-system"
          }
          spec: {
            forProvider: {
              chart: {
                name: "mongodb"
                repository: "https://charts.bitnami.com/bitnami"
                version: "13.15.1"
              }
              namespace: context.namespace
              values: {
                auth: {
                  enabled: parameter.authEnabled
                  rootPassword: parameter.rootPassword
                  database: parameter.database
                  username: parameter.username
                  password: parameter.password
                }
                architecture: parameter.architecture
                replicaCount: parameter.replicaCount
                persistence: {
                  enabled: parameter.persistenceEnabled
                  size: parameter.storageSize
                }
                metrics: {
                  enabled: parameter.metricsEnabled
                }
              }
            }
          }
        }
        
        parameter: {
          authEnabled: *true | bool
          rootPassword: *"mongodb-root" | string
          database: *"mydb" | string
          username: *"user" | string
          password: *"password" | string
          architecture: *"replicaset" | "standalone" | "replicaset"
          replicaCount: *3 | int
          persistenceEnabled: *true | bool
          storageSize: *"20Gi" | string
          metricsEnabled: *true | bool
        }

---
# Application Infrastructure ComponentDefinition (Crossplane-based)
apiVersion: core.oam.dev/v1beta1
kind: ComponentDefinition
metadata:
  name: application-infrastructure
  annotations:
    definition.oam.dev/description: "Comprehensive application infrastructure with networking, storage, and compute resources"
spec:
  workload:
    definition:
      apiVersion: platform.example.org/v1alpha1
      kind: ApplicationClaim
    type: applicationclaims.platform.example.org
  schematic:
    cue:
      template: |
        output: {
          apiVersion: "platform.example.org/v1alpha1"
          kind: "ApplicationClaim"
          metadata: {
            name: context.name
            namespace: context.namespace
          }
          spec: {
            appName: context.name
            appType: parameter.appType
            environment: parameter.environment
            resources: {
              compute: {
                cpu: parameter.compute.cpu
                memory: parameter.compute.memory
                replicas: parameter.compute.replicas
              }
              storage: {
                size: parameter.storage.size
                class: parameter.storage.class
              }
              networking: {
                ingress: parameter.networking.ingress
                tls: parameter.networking.tls
              }
            }
          }
        }
        
        parameter: {
          appType: *"microservice" | "microservice" | "monolith" | "batch"
          environment: *"development" | "development" | "staging" | "production"
          compute: {
            cpu: *"500m" | string
            memory: *"1Gi" | string
            replicas: *2 | int
          }
          storage: {
            size: *"10Gi" | string
            class: *"standard" | string
          }
          networking: {
            ingress: *true | bool
            tls: *false | bool
          }
        }

---
# vCluster ComponentDefinition (Crossplane-managed)
apiVersion: core.oam.dev/v1beta1
kind: ComponentDefinition
metadata:
  name: vcluster
  annotations:
    definition.oam.dev/description: "Virtual Kubernetes cluster for multi-tenancy and isolation"
spec:
  workload:
    definition:
      apiVersion: helm.crossplane.io/v1beta1
      kind: Release
    type: releases.helm.crossplane.io
  schematic:
    cue:
      template: |
        output: {
          apiVersion: "helm.crossplane.io/v1beta1"
          kind: "Release"
          metadata: {
            name: context.name
            namespace: "crossplane-system"
          }
          spec: {
            forProvider: {
              chart: {
                name: "vcluster"
                repository: "https://charts.loft.sh"
                version: "0.15.0"
              }
              namespace: context.namespace
              values: {
                vcluster: {
                  image: parameter.image
                }
                syncer: {
                  extraArgs: parameter.syncerArgs
                }
                isolation: {
                  enabled: parameter.isolationEnabled
                }
                rbac: {
                  clusterRole: {
                    create: true
                  }
                }
                service: {
                  type: parameter.serviceType
                }
              }
            }
          }
        }
        
        parameter: {
          image: *"rancher/k3s:v1.27.1-k3s1" | string
          syncerArgs: *[] | [...string]
          isolationEnabled: *true | bool
          serviceType: *"ClusterIP" | "ClusterIP" | "LoadBalancer" | "NodePort"
        }

---
# Neon Postgres ComponentDefinition (Cloud-native serverless PostgreSQL)
apiVersion: core.oam.dev/v1beta1
kind: ComponentDefinition
metadata:
  name: neon-postgres
  annotations:
    definition.oam.dev/description: "Neon serverless PostgreSQL database with automatic scaling and branching"
spec:
  workload:
    definition:
      apiVersion: v1
      kind: Secret
    type: secrets
  schematic:
    cue:
      template: |
        import "encoding/base64"
        
        output: {
          apiVersion: "v1"
          kind: "Secret"
          metadata: {
            name: context.name + "-neon-credentials"
            namespace: context.namespace
            labels: {
              "app.kubernetes.io/name": context.name
              "app.kubernetes.io/component": "database"
              "app.kubernetes.io/managed-by": "kubevela"
              "database.type": "neon-postgres"
            }
          }
          type: "Opaque"
          data: {
            // These would be populated by an operator or controller
            "database-url": base64.Encode(null, "postgresql://user:pass@ep-xyz.neon.tech/dbname")
            "host": base64.Encode(null, "ep-xyz.neon.tech")
            "port": base64.Encode(null, "5432")
            "database": base64.Encode(null, parameter.database)
            "username": base64.Encode(null, parameter.username)
            "password": base64.Encode(null, "generated-password")
          }
        }
        
        outputs: {
          // Create External Secret to sync Neon credentials
          "external-secret": {
            apiVersion: "external-secrets.io/v1beta1"
            kind: "ExternalSecret"
            metadata: {
              name: context.name + "-neon-sync"
              namespace: context.namespace
            }
            spec: {
              secretStoreRef: {
                name: "neon-secret-store"
                kind: "SecretStore"
              }
              target: {
                name: context.name + "-neon-credentials"
                creationPolicy: "Merge"
              }
              data: [
                {
                  secretKey: "database-url"
                  remoteRef: {
                    key: context.name
                    property: "database-url"
                  }
                }
              ]
            }
          }
          
          // ConfigMap for non-sensitive configuration
          "config": {
            apiVersion: "v1"
            kind: "ConfigMap"
            metadata: {
              name: context.name + "-neon-config"
              namespace: context.namespace
            }
            data: {
              "database": parameter.database
              "region": parameter.region
              "compute-size": parameter.computeSize
              "autoscaling": "\\(parameter.autoscaling)"
              "branch": parameter.branch
            }
          }
        }
        
        parameter: {
          database: *"myapp" | string
          username: *"app_user" | string
          region: *"us-west-2" | string
          computeSize: *"0.25" | "0.25" | "0.5" | "1" | "2" | "4" | "8"
          autoscaling: *true | bool
          branch: *"main" | string
          poolerEnabled: *true | bool
          suspendTimeout: *300 | int  // Seconds of inactivity before suspend
        }

---
# ClickHouse ComponentDefinition (Analytics database)
apiVersion: core.oam.dev/v1beta1
kind: ComponentDefinition
metadata:
  name: clickhouse
  annotations:
    definition.oam.dev/description: "ClickHouse columnar database for real-time analytics"
spec:
  workload:
    definition:
      apiVersion: apps/v1
      kind: StatefulSet
    type: statefulsets.apps
  schematic:
    cue:
      template: |
        output: {
          apiVersion: "apps/v1"
          kind: "StatefulSet"
          metadata: {
            name: context.name
            namespace: context.namespace
          }
          spec: {
            serviceName: context.name
            replicas: parameter.replicas
            selector: {
              matchLabels: {
                app: context.name
              }
            }
            template: {
              metadata: {
                labels: {
                  app: context.name
                }
              }
              spec: {
                containers: [{
                  name: "clickhouse"
                  image: "clickhouse/clickhouse-server:" + parameter.version
                  ports: [{
                    containerPort: 8123
                    name: "http"
                  }, {
                    containerPort: 9000
                    name: "native"
                  }]
                  volumeMounts: [{
                    name: "data"
                    mountPath: "/var/lib/clickhouse"
                  }]
                  resources: {
                    limits: {
                      cpu: parameter.resources.cpu
                      memory: parameter.resources.memory
                    }
                    requests: {
                      cpu: "500m"
                      memory: "1Gi"
                    }
                  }
                  env: [
                    {
                      name: "CLICKHOUSE_DB"
                      value: parameter.database
                    }
                  ]
                }]
              }
            }
            volumeClaimTemplates: [{
              metadata: {
                name: "data"
              }
              spec: {
                accessModes: ["ReadWriteOnce"]
                resources: {
                  requests: {
                    storage: parameter.storageSize
                  }
                }
              }
            }]
          }
        }
        
        outputs: {
          "service": {
            apiVersion: "v1"
            kind: "Service"
            metadata: {
              name: context.name
              namespace: context.namespace
            }
            spec: {
              type: "ClusterIP"
              ports: [{
                port: 8123
                targetPort: 8123
                name: "http"
              }, {
                port: 9000
                targetPort: 9000
                name: "native"
              }]
              selector: {
                app: context.name
              }
            }
          }
        }
        
        parameter: {
          version: *"23.5" | string
          replicas: *1 | int
          database: *"default" | string
          storageSize: *"100Gi" | string
          resources: {
            cpu: *"2" | string
            memory: *"4Gi" | string
          }
        }