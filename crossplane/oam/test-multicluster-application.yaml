# Test Application for Multi-Cluster vCluster Deployment
# This demonstrates how to deploy workloads to a vCluster using targetEnvironment

---
# First, create a vCluster environment
apiVersion: core.oam.dev/v1beta1
kind: Application
metadata:
  name: test-vcluster-env
  namespace: default
spec:
  components:
  - name: test-env
    type: vcluster
    properties:
      name: test-env
      components:
        istio: true
        knative: true
        grafana: false
        prometheus: false

---
# Then, deploy applications TO the vCluster
apiVersion: core.oam.dev/v1beta1
kind: Application
metadata:
  name: test-multicluster-app
  namespace: default
spec:
  components:
  # This webservice will be deployed to the vCluster
  - name: nginx-service
    type: webservice
    properties:
      image: nginx:alpine
      port: 80
      targetEnvironment: test-env  # KEY: This targets the vCluster
      environment:
        MESSAGE: "Hello from vCluster!"
      
  # This Redis will also be deployed to the vCluster  
  - name: redis-cache
    type: redis
    properties:
      name: redis-cache
      targetEnvironment: test-env  # KEY: This also targets the vCluster
      architecture: standalone
      auth:
        enabled: false
        
  # This webservice will be deployed to the HOST cluster (no targetEnvironment)
  - name: host-service
    type: webservice
    properties:
      image: nginx:alpine
      port: 80
      environment:
        MESSAGE: "Hello from Host Cluster!"
    traits:
    - type: ingress
      properties:
        domain: test-multicluster.local
        path: /
        enableTLS: false
  
  policies:
  - name: health-check
    type: health
    properties:
      probeInterval: 30
      
---
# ConfigMap to document the expected behavior
apiVersion: v1
kind: ConfigMap
metadata:
  name: multicluster-test-expectations
  namespace: default
data:
  expected-behavior.md: |
    # Multi-Cluster Test Expected Behavior
    
    ## What Should Happen:
    
    1. **vCluster Creation**: 
       - Application `test-vcluster-env` creates a vCluster named `test-env`
       - vCluster gets Istio and Knative installed
       - KubeVela access ServiceAccount created
       - ClusterGateway configuration generated
    
    2. **vCluster Deployments**:
       - `nginx-service` → Deployed TO vCluster (has targetEnvironment: test-env)
       - `redis-cache` → Deployed TO vCluster (has targetEnvironment: test-env)
       
    3. **Host Cluster Deployments**:
       - `host-service` → Deployed ON host cluster (no targetEnvironment)
    
    ## Validation Commands:
    
    ```bash
    # Check host cluster deployments
    kubectl get ksvc host-service
    # Should show: host-service running
    
    # Check NO vCluster services on host
    kubectl get ksvc nginx-service
    kubectl get release redis-cache-redis
    # Should show: No resources found
    
    # Check vCluster context (once available)
    kubectl --context=test-env get ksvc nginx-service
    kubectl --context=test-env get release redis-cache-redis  
    # Should show: Services running in vCluster
    
    # Check KubeVela application status
    kubectl get application test-multicluster-app -n default
    # Should show: Running with components properly distributed
    ```
    
    ## Success Criteria:
    - ✅ vCluster `test-env` provisions successfully
    - ✅ Services with `targetEnvironment` deploy to vCluster
    - ✅ Services WITHOUT `targetEnvironment` deploy to host cluster
    - ✅ KubeVela can route workloads based on annotations
    - ✅ Traits (ingress) inherit cluster routing from components