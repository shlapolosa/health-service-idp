# Minimal Realtime OAM Application Example
# This demonstrates the simplest possible realtime streaming application
# using the realtime-platform ComponentDefinition with default settings

apiVersion: core.oam.dev/v1beta1
kind: Application
metadata:
  name: minimal-realtime-app
  namespace: default
  annotations:
    oam.dev/description: "Minimal example of realtime streaming application"
    oam.dev/last-updated: "2024-01-XX"
spec:
  components:
  
  # Step 1: Create the realtime platform infrastructure
  # This single component creates everything needed for streaming:
  # - PostgreSQL database
  # - Kafka cluster with Schema Registry
  # - MQTT broker for IoT devices  
  # - Lenses HQ/Agent for stream processing
  # - Metabase for analytics dashboards
  # - All connection secrets
  - name: simple-platform
    type: realtime-platform
    properties:
      name: simple-streaming
      # All other properties use sensible defaults:
      # database: postgres (default)
      # visualization: metabase (default) 
      # iot: true (default)
      # resources: 2000m CPU, 4Gi memory (default)
      # scaling: 1-3 replicas (default)

  # Step 2: Create a service that uses the realtime platform
  # The 'realtime' parameter automatically:
  # - Injects all connection environment variables
  # - Mounts connection secrets as files
  # - Configures network policies
  # - Sets up health checks
  - name: my-service
    type: webservice
    properties:
      name: simple-realtime-service
      language: python
      framework: fastapi
      image: "socrates12345/simple-realtime-service:latest"
      
      # This single line connects to the realtime platform above
      realtime: "simple-streaming"  # References the platform component name
      
      # Enable WebSocket endpoints for real-time communication
      websocket: true
      
      # Configure Kafka streaming
      streaming:
        enabled: true
        topics: ["events", "notifications"]
        consumerGroup: "simple-service-group"
      
      # Optional: Custom environment variables
      environment:
        SERVICE_TYPE: "MINIMAL_EXAMPLE"
        LOG_LEVEL: "INFO"
        WEBSOCKET_ENDPOINT: "/ws/events"
    
    # Optional: Add ingress for external access
    traits:
    - type: ingress
      properties:
        domain: simple-realtime.demo.local
        path: "/"
        https: true

---
# Alternative: Using ApplicationClaim directly
# This shows how to use the underlying ApplicationClaim interface
apiVersion: platform.example.org/v1alpha1
kind: ApplicationClaim
metadata:
  name: minimal-realtime-claim
  namespace: default
  annotations:
    claim.crossplane.io/description: "Minimal realtime application via ApplicationClaim"
spec:
  name: minimal-streaming
  language: python
  framework: fastapi
  image: "socrates12345/minimal-realtime:latest"
  
  # Enable realtime platform with default settings
  realtime: "minimal-streaming"
  websocket: true
  
  # Minimal streaming configuration
  streaming:
    enabled: true
    topics: ["data"]
  
  # Minimal resource requirements
  resources:
    cpu: "500m"
    memory: "512Mi"

---
# Example Environment Variables Automatically Injected
# When realtime: "simple-streaming" is specified, the service receives:

# Kafka Connection
# KAFKA_BOOTSTRAP_SERVERS=simple-streaming-kafka.default.svc.cluster.local:9092
# KAFKA_SCHEMA_REGISTRY_URL=http://simple-streaming-kafka.default.svc.cluster.local:8081

# MQTT Connection  
# MQTT_HOST=simple-streaming-mqtt.default.svc.cluster.local
# MQTT_PORT=1883
# MQTT_USER=realtime-user
# MQTT_PASSWORD=<auto-generated>

# Database Connection
# DB_HOST=simple-streaming-postgres.default.svc.cluster.local
# DB_PORT=5432
# DB_NAME=simplestreaming
# DB_USER=realtime
# DB_PASSWORD=<auto-generated>

# Analytics Dashboard
# METABASE_URL=http://simple-streaming-metabase.default.svc.cluster.local:3000
# METABASE_USER=admin@example.com
# METABASE_PASSWORD=<auto-generated>

# Stream Processing UI
# LENSES_URL=http://simple-streaming-lenses-hq.default.svc.cluster.local:9991
# LENSES_USER=admin
# LENSES_PASSWORD=admin

---
# Example FastAPI Service Code
# This shows what the minimal service implementation looks like:

# ```python
# from fastapi import FastAPI, WebSocket
# from kafka import KafkaConsumer, KafkaProducer
# import os
# import json
# import asyncio
# from typing import List
# 
# app = FastAPI(title="Minimal Realtime Service")
# 
# # Auto-injected connection details
# KAFKA_SERVERS = os.getenv("KAFKA_BOOTSTRAP_SERVERS")
# MQTT_HOST = os.getenv("MQTT_HOST")
# WEBSOCKET_ENDPOINT = os.getenv("WEBSOCKET_ENDPOINT", "/ws/events")
# 
# # WebSocket connection manager
# class ConnectionManager:
#     def __init__(self):
#         self.active_connections: List[WebSocket] = []
#     
#     async def connect(self, websocket: WebSocket):
#         await websocket.accept()
#         self.active_connections.append(websocket)
#     
#     def disconnect(self, websocket: WebSocket):
#         self.active_connections.remove(websocket)
#     
#     async def broadcast(self, message: str):
#         for connection in self.active_connections:
#             await connection.send_text(message)
# 
# manager = ConnectionManager()
# 
# @app.get("/")
# async def root():
#     return {
#         "service": "Minimal Realtime Service",
#         "status": "running",
#         "connections": len(manager.active_connections),
#         "kafka": KAFKA_SERVERS,
#         "mqtt": MQTT_HOST
#     }
# 
# @app.get("/health")
# async def health():
#     return {"status": "healthy"}
# 
# @app.websocket(WEBSOCKET_ENDPOINT)
# async def websocket_endpoint(websocket: WebSocket):
#     await manager.connect(websocket)
#     try:
#         # Listen for Kafka messages and broadcast to WebSocket clients
#         consumer = KafkaConsumer(
#             'events',
#             bootstrap_servers=[KAFKA_SERVERS],
#             value_deserializer=lambda m: json.loads(m.decode('utf-8'))
#         )
#         
#         for message in consumer:
#             await manager.broadcast(json.dumps(message.value))
#             
#     except Exception as e:
#         print(f"WebSocket error: {e}")
#     finally:
#         manager.disconnect(websocket)
# 
# if __name__ == "__main__":
#     import uvicorn
#     uvicorn.run(app, host="0.0.0.0", port=8080)
# ```

---
# Deployment Instructions
# 
# 1. Apply the OAM application:
#    kubectl apply -f MINIMAL-REALTIME-OAM.yaml
# 
# 2. Check deployment status:
#    kubectl get applications.core.oam.dev
#    kubectl get applicationclaims.platform.example.org
# 
# 3. Access the service:
#    curl https://simple-realtime.demo.local/
#    curl https://simple-realtime.demo.local/health
# 
# 4. Monitor the realtime platform:
#    kubectl get secrets | grep simple-streaming
#    kubectl logs -l app.oam.dev/name=simple-streaming
# 
# 5. Access analytics dashboard:
#    kubectl get secret simple-streaming-metabase-secret -o yaml
#    # Use credentials to access Metabase at the URL in the secret